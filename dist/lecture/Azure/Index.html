<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Название лекции</title>
	<meta name="description" content="">
	<meta name="keywords" content="">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h1>Название лекции</h1>
					<h3>Разработка динамичесих веб приложений</h3>
					<p>
						<small>Гладкий Максим Валерьевич / <a href="https://github.com/MaksHladki">github:MaksHladki</a></small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<h1>Архитектура Windows Azure</h1>
			</section>
			<section>
				<section>
					<h2>Эволюция Windows Azure</h2>
					<ul>
						<li>2006 - создана «команда мечты» для разработки облачной ОС RedDog</li>
						<li>2006 - команда Indigo (известная как Windows Communication Foundation) приступает к работе над экспериментальным реле
							коммуникации
						</li>
						<li>2006 - команда SQL берет на себя разработку интернет-версии своей службы</li>
						<li>2007 - три команды начинают сотрудничать друг с другом</li>
						<li>2008 - объединение команд в проект Azure: службы .NET, онлайн-службы, службы SQL. Предствлена Azure CTP</li>
					</ul>
				</section>
				<section>
					<h2>Следующий этап эволюции</h2>
					<ul>
						<li>2009 - выходит версия CTP 3, подержка доверенного и платформенного кода, геолокация, fast CGI, PHP и Java SDK. Azure
							становится открытой платформой, выпускается первый официальный SDK 1.0</li>
						<li>2010 - платформа доступка в 21 стране, реализована поддержка БД более 50 ГБ, полноценная поддержка IIS и службы удаленного
							рабочего стола</li>
						<li>2011 - инструмент SQL Azure Reporting, Scheduler SDK для поддержки ресурсоемких параллельных приложений</li>
						<li>2012 - добавлена архитектура IaaS, выпущен Python SDK. ЦОДы работают в 8 регионах мира</li>
						<li>2013 - добавлена служба Active Directory</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Windows Azure</h2>
				<blockquote>
					Windows Azure — это открытая и гибкая облачная платформа, позволяющая бы- стро создавать, развертывать и управлять приложениями
					в глобальной сети центров обработки данных под управлением Майкрософт. Приложения можно разрабатывать с помощью любого
					языка, инструмента или платформы. Кроме того, приложения в общедоступном облаке можно интегрировать с имеющейся ИТ-средой.
				</blockquote>
			</section>
			<section>
				<h2>Основные особенности</h2>
				<ul>
					<li>Открытая - поддерживаются многие ЯП и интсрументы</li>
					<li>Гибкая - разнообразие облачных служб (от утилит развертывания до SQL-хранилищ)</li>
					<li>Под управлением Майкрософт - ЦОДы в США, Европе и Азии</li>
					<li>Совместимая - многие компоненты легко интегрирутся с Windows Server</li>
					<li>Собственная сеть CDN</li>
				</ul>
			</section>
			<section>
				<h2>Основные возмоности</h2>
				<ul>
					<li>Инфраструктура</li>
					<li>Мобильные приложения</li>
					<li>Интернет</li>
					<li>Медиаконтент</li>
					<li>Интеграция</li>
					<li>Идентификация и управление доступом</li>
					<li>Большие данные</li>
					<li>Разработка и тестирование</li>
					<li>Хранение, архивация и восстановление</li>
					<li>Управление данными</li>
				</ul>
			</section>
			<section>
				<h2>Три ОС в одной концепции</h2>
				<ul>
					<li>Windows Server - платформа корпоративного уровня, фундаметр облачных вычислений</li>
					<li>System Center - интегрированная платформа для централизованного управления частными, размещенными и общедоступными облаками</li>
					<li>Windows Azure — открытая, гибкая облачная платформа для разработки, развертывания и управления приложениями и задачами,
						размещенными в глобальной сети центров обработки данных Майкрософ</li>
				</ul>
			</section>
			<section>
				<h2>Free account</h2>
				<img src="img/free-account.png" alt="">
			</section>
			<section>
				<h1>Вычислительные службы Windows Azure</h1>
			</section>
			<section>
				<h2>Типы приложений</h2>
				<p>С точки зрения пользователей</p>
				<ul>
					<li>Внутренние (on-premises app) - выполняются на компьютере пользователя</li>
					<li>Облачные - выполняются в среде Windows Azure в ЦОД</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Службы Windows Azure</h2>
					<ul>
						<li>Вычислительные службы - предоставляют компьютерные ресурсы, на которых работают облачные приложения</li>
						<li>Сетевые службы - предоставляют облачные приложения и центрам обработки данных пользователям различными способами</li>
						<li>Службы обработки данных - способы хранения, управления, защиты и анализа бизнес-данные,составление отчетов по ним</li>
						<li>Службы приложений - улучшают производительность, защиту и уровень интеграции облачных приложений, а также делают более
							простым процесс их освоения</li>
					</ul>
				</section>
				<section>
					<h3>Вычислительные службы</h3>
					<table>
						<tbody>
							<tr>
								<td>Виртуальные машины</td>
								<td>универсальная среда для создания, развертывания и управления виртуальными машинами</td>
							</tr>
							<tr>
								<td>Веб-сайты</td>
								<td>специализированная среда для создания и управления веб-сайтами, а также переноса существующих</td>
							</tr>
							<tr>
								<td>Облачные службы</td>
								<td>создание и развертывание масшатабируемое ПО любой сложности на любом ЯП</td>
							</tr>
							<tr>
								<td>Мобильные службы</td>
								<td>технологии обработки и хранения данных для мобильных систем</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Сетевые службы</h3>
					<table>
						<tbody>
							<tr>
								<td>Виртуальная сеть</td>
								<td>позволяет использовать облако в качестве расширения локального ЦОДа</td>
							</tr>
							<tr>
								<td>Диспетчер трафика</td>
								<td>масшатбирование трафика по определнным критериям: максимальная производительность, циклическое обслуживание и уровень
									отказоустойчивости
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Службы обработки данных</h3>
					<table>
						<tbody>
							<tr>
								<td>Управление данными</td>
								<td>хранение и управление данными в ВМ + MSQL, БД Azure SQL, NoSQL решениях через REST API, blob-хранилищах</td>
							</tr>
							<tr>
								<td>Бизнес-аналитика</td>
								<td>предоставляет службы SQL Server Reporting and Analysis, SharePoint Serve, Azure SQL Reporting, Azure Marketplace
									и HDInsight</td>
							</tr>
							<tr>
								<td>HDInsight</td>
								<td>специальная надстройка, позволяющая запускать Apache Hadoop в облаке Azure</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Службы обработки данных</h3>
					<table>
						<tbody>
							<tr>
								<td>Кэш</td>
								<td>распределенные решение для кэширования, ускоряющее работу облачных приложений и снижающее нагрузку на БД
								</td>
							</tr>
							<tr>
								<td>Резервное копирование</td>
								<td>средства автономной защититы данных на сервере, позволяют создавать как автоматические, так и ручные копии</td>
							</tr>
							<tr>
								<td>Диспетчер восстановления</td>
								<td>защита критически важных для бизнеса данных, приложений и служб в платформе виртуализации Hyper-V. Координация репликаций
									и восстановление частных облаков
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Службы приложений</h3>
					<table>
						<tbody>
							<tr>
								<td>Мультимедийные службы</td>
								<td>формируют процессы для создания, управления и распространения медиаконтента</td>
							</tr>
							<tr>
								<td>Обмен сообщениями</td>
								<td>шина обслуживания и очередь обеспечивают связь приложений в частном и/или общедоступном облаке</td>
							</tr>
							<tr>
								<td>Узлы уведомлений</td>
								<td>хорошо масштабируемая кросс-платформенная инфраструктура push-уведомлений для приложений, работающих на мобильных
									устройствах
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Службы приложений</h3>
					<table>
						<tbody>
							<tr>
								<td>Службы BizTalk</td>
								<td>функции B2B (Business-to-Business) и EAI (Enterprise Application Integration) для облачных и гибридных решений по
									интеграции
								</td>
							</tr>
							<tr>
								<td>Active Directory</td>
								<td>отвечает за управление идентификацией и контроль доступа для облачных приложений</td>
							</tr>
							<tr>
								<td>Многофакторная аутентификация</td>
								<td>дополнительный уровень аутентификации наряду с учетными данными пользователей, повышая защищенность доступа к локальным
									и облачным приложениям
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Общая схема</h3>
					<img src="img/service-scheme.png" alt="" height="550">
				</section>
			</section>
			<section>
				<section>
					<h2>Веб-сайты</h2>
				</section>
				<section>
					<h3>Определение от Microsoft</h3>
					<blockquote>
						Веб-сайты Windows Azure — это масштабируемая, безопасная и гибкая плат- форма, на основе которой можно создавать веб-приложения
						для бизнеса, рас- ширять охват бренда и привлекать новых клиентов
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>портал самообслуживания с галереей наиболее популярных веб-решений</li>
						<li>интсрумент WebMatrix</li>
						<li>интсрумент публикации приложений</li>
						<li>Azure SDK для Visual Studio</li>
						<li>утилиты для создания, конфигурирования и управления БД</li>
						<li>интеграция с системами контроля версий: TFS, GitHub, Bitbucket и т.д.</li>
						<li>инструмент мониторинга нагрузки и состояния ресурсов веб-приложения</li>
						<li>утилиты диагностики и тесторования</li>
						<li>конфигурация SSL-стерификатоф</li>
						<li>конфигурация версии платформы (.NET, PHP, Java и т.д)</li>
					</ul>
				</section>
				<section>
					<h3>Режимы работы веб-сайтов</h3>
					<!-- автомасштабирование -->
					<ul>
						<li>бесплатный - мультиарендная архитектура, каждому сайту выделена квота на ресурсы процессора, памяти и сети. Количество
							сайтов зависит от тарифного плана, SLA отсутствует</li>
						<li>распределенный - гарантируется SLA более низкого уровня по сравнению со стандартным режимом</li>
						<li>стандартный - можно выбрать сайты, которые будут работать на спе- циально выделенной виртуальной машине, где могут
							размещаться до 500 веб- сайтов
						</li>
					</ul>
				</section>
				<section>
					<h3>Доступность серверов</h3>
					<ul>
						<li>малый сервер (1 ядро, 1,75 ГБ оперативной памяти)</li>
						<li>средний сервер (2 ядра, 3,5 ГБ оперативной памяти)</li>
						<li>большой сервер (4 ядра, 7 ГБ оперативной памяти)</li>
					</ul>
				</section>
				<section>
					<h3>автомасштабирование</h3>
					<img src="img/auto_scale.jpg" alt="">
					<p>https://msdn.microsoft.com/ru-ru/library/hh680945(v=pandp.50).aspx</p>
				</section>
			</section>
			<section>
				<h2>Балансировка нагрузки</h2>
				<p>https://docs.microsoft.com/ru-ru/azure/application-gateway/application-gateway-introduction</p>
			</section>
			<section>
				<section>
					<h2>Виртуальные машины</h2>
				</section>
				<section>
					<h3>Определение от microsoft</h3>
					<blockquote>
						Виртуальные машины Windows Azure — это масштабируемая IaaS-платформа по запросу, позволяющая быстро подготавливать и развертывать
						в облаке сервер- ные задачи.
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>механизмы настройки, контроля и отслеживания ВМ</li>
						<li>балансировщик нагрузки между ВМ</li>
						<li>интсрумент подключения к другим облачным службам Windows Azure, на которых работают веб-роли и рабочие роли</li>
						<li>можно копировть виртуальные жесткие диски (Virtual Hard Disk, VHD) из локальной среды в Azure и на их основе создать
							новые виртуальные машины</li>
						<li>Возможно и обратное действие — выгрузить VHD из Windows Azure и запустить их локально в центре обработки данных</li>
						<li>Новые виртуальные машины можно создавать из стандартных образов, доступ- ных в галерее Windows Azure. В число стандартных
							образов входят актуальные версии Windows Server, различные сборки Linux, а также Microsoft SharePoint, Microsoft SQL
							Server и предустановленный Microsoft BizTalk Server в составе Windows Server</li>
						<li>вы можете использовать для развертывания новых виртуальных машин и собственные сборки, которые были созданы локально</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li> будет полный контроль над своими виртуальными машинами, развернутыми в облаке Windows Azure. </li>
						<li>Виртуальными машинами на базе Windows Server можно удаленно управлять по протоколу RDP (Remote Desktop Protocol) </li>
						<li>управлять средствами Windows PowerShell</li>
						<li> Виртуальные машины Linux поддерживают удаленное управление по SSH (Secure Shell)</li>
						<li>Вы также мо- жете создавать и подключать к виртуальным машинам диски для хранения ин- формации приложений</li>
						<li> Если необходимо повысить производительность виртуальных машин для ресурсоемких задач, можно выделить дополнительные
							процессорные ядра</li>
						<li>со- храняются и самостоятельно восстанавливаются после аппаратных сбоев</li>
						<li>Любые подключенные к вирту- альной машине диски также сохраняются, они резервированы BLOB-объектами хранилища Windows
							Azure. Между тем, экземпляры веб-ролей и рабочих ролей самовосстанавливаются, но не сохраняются</li>
						<li>Использование виртуальных машин тарифицируется по часам, поэтому для эко- номии средств вы можете просто отключить
							ненужные машины. </li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Основные компоненты</h2>
					<uL>
						<li>Fabric - интерфей - обеспечивает средства управления облачной платформой</li>
						<li>Compute - вычисления, обрабатывает пользовательские данные</li>
						<li>Storage - память, сервис хранения пользовательских данных</li>
						<li>Config - конфигурация</li>
						<li></li>
					</uL>
					<blockquote>
						Все компоненты являются сервисами .NET
					</blockquote>
				</section>
				<section>
					<h3>Сервис Compute</h3>
					<ul>
						<li>Решает задачи совместного выполнения огромного числа пользовательских приложений</li>
						<li>Может выполнять каждый экземпляр приложения на отдельной виртуальной машине </li>
						<li>Основная проблема - масштабирование</li>
						<li></li>
						<li></li>
						<li></li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Облачные службы</h2>
				</section>
				<section>
					<blockquote>
						С помощью облачных служб Windows Azure можно быстро создавать, развер- тывать многоуровневые приложения в облаке и управлять
						ими. Используя облачные службы, вы можете сконцентрироваться на разработке, те- стировании, развертывании и управлении
						приложением, а не тратить время на обслуживание нижележащей инфраструктуры
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Для распреде- ленной обработки и гибкого масштабирования приложения можно назначить ему несколько ролей</li>
						<li> Приложения облачных служб можно создать практически на любой популярной платформе разработки, включая .NET, Node.js,
							PHP, Java, Python и Ruby.</li>
						<li> Кроме того, в облачное приложение можно интегрировать мо- бильные службы Windows Azure и мультимедийные службы.</li>
						<li>На портале управления Windows Azure можно отслеживать работоспособность и доступность приложений в облачных службах</li>
						<li> Можно также настроить оповеще- ния в реальном времени о сбоях в работе служб или снижении их производитель- ности
						</li>
						<li>А с помощью новой функции автомасштабирования ваше приложение бу- дет автоматически получать или отдавать ресурсы по
							мере необходимости. Это удешевит обслуживание приложений в облаке, так как оплата будет взиматься только за фактически
							использованные ресурсы</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Сетевые службы Windows Azure</h2>
				</section>
				<section>
				</section>
			</section>
			<section>
				<h1>Microsoft Message Queue</h1>
			</section>
			<section>
				<h1>Azure Service Bus</h1>
			</section>
			<section>
				<h1>Application Insights</h1>
			</section>
			<section>
				<h2></h2>
				<blockquote>
					Application Insights позволяет осуществлять мониторинг доступности, производительности и использования вашего веб-приложения.
					Благодаря получаемым данным о производительности и эффективности работы приложения на практике вы можете принимать осознанные
					решения о направлении разработки в каждом жизненном цикле.
				</blockquote>
			</section>
			<section>
				<h2>Типы данных</h2>
				<ul>
					<li>Частота HTTP-запросов, время ответа, частота успешных выполнений</li>
					<li>Частота вызовов зависимостей (HTTP и SQL), время ответа, частота успешных выполнений</li>
					<li>Трассировки исключений из сервера и клиента</li>
					<li>Трассировки журналов диагностики</li>
					<li>Количество просмотров страниц, количество пользователей и сеансов, время загрузки браузера, исключения</li>
					<li>Счетчики производительности сервера</li>
					<li>Пользовательская телеметрия клиента и сервера</li>
					<li>Cегментация с учетом расположения клиента, версии браузера, версии ОС, экземпляра сервера, пользовательских измерений
						и многого другого</li>
					<li>Тесты доступности</li>
				</ul>
			</section>
			<section>
				<h4>Средства диагностики и анализа</h4>
				<ul>
					<li>Интеллектуальные и настраиваемые вручную оповещения о частоте сбоев, доступности и других показателях</li>
					<li>Диаграммы сводных показателей за определенный период времени</li>
					<li>Поиск экземпляров запросов, исключений, пользовательских событий, трассировок журналов, количества просмотров страниц,
						зависимостей и вызовов AJAX по журналам диагностики</li>
					<li>Аналитика — эффективный язык запросов для телеметрии</li>
					<li>Панели мониторинга — на них формируются диаграммы, необходимые для отслеживания компонентов приложения</li>
				</ul>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/insight_схема.png" alt="">
			</section>
			<section>
				<section>
					<h2>Аналитические средства для разработчиков</h2>
				</section>
				<section>
					<h3>Языки</h3>
					<ul>
						<li>.NET</li>
						<li>Java</li>
						<li>JavaScript</li>
						<li>Objective-C</li>
						<li>PHP</li>
						<li>Python</li>
						<li>Ruby</li>
						<li>Другие</li>
					</ul>
				</section>
				<section>
					<h3>Платформы и среды</h3>
					<ul>
						<li>Angular</li>
						<li>ASP.NET</li>
						<li>Android </li>
						<li>Docker</li>
						<li>iOS</li>
						<li>J2EE</li>
						<li>Приложение Mac OS X </li>
						<li>Node.JS</li>
						<li>UWP</li>
						<li>Другие</li>
					</ul>
				</section>
				<section>
					<h3>Платформы ведения журналов</h3>
					<ul>
						<li>Log4Net, NLog</li>
						<li>Java, Log4J или Logback</li>
						<li>Semantic Logging (SLAB)</li>
						<li>Облачное нагрузочное тестирование</li>
						<li>Подключаемый модуль LogStash</li>
					</ul>
				</section>
				<section>
					<h3>Системы управления содержимым</h3>
					<ul>
						<li>Concrete</li>
						<li>Drupal</li>
						<li>Joomla</li>
						<li>Orchard</li>
						<li>SharePoint</li>
						<li>WordPress</li>
					</ul>
				</section>
				<section>
					<h3>Экспорт и анализ данных</h3>
					<ul>
						<li>Alooma</li>
						<li>Power</li>
						<li>BI</li>
					</ul>
				</section>
				<section>
					<h3>Создание собственного пакета SDK</h3>
					<blockquote>
						Если для языка или платформы не существует пакета SDK, можно легко создать его
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Оповещения</h2>
				<ul>
					<li>Автоматическое получение оповещения превентивной диагностики, которые сообщают о необычных изменениях в частоте сбоев
						и других метриках</li>
					<li>Тесты доступности для постоянного тестирования веб-сайта из расположений по всему миру и немедленного получения сообщений
						электронной почты в случае сбоя проверки</li>
					<li>Настройте оповещения о метриках, чтобы получать оповещение о выходе метрик, таких как время отклика или доля исключений,
						за допустимые границы</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Фильтрация и предварительная обработка</h2>
					<ul>
						<li>Выборка сокращает объем данных телеметрии, не искажая статистические данные. Благодаря выборке связанные точки данных
							хранятся вместе, что облегчает навигацию между ними во время диагностики проблемы. На портале общее количество умножается,
							чтобы компенсировать выборку</li>
						<li>Фильтрация позволяет выбирать или изменять данные телеметрии в пакете SDK перед отправкой на сервер. Например, можно
							исключить запросы от роботов. При помощи фильтрации сократить трафик проще, чем при помощи выборки</li>
						<li>Инициализаторы телеметрии добавляют свойства к любым данным телеметрии, включая данные из стандартных модулей</li>
						<li>API пакета SDK используется для отправки пользовательских событий и показателей</li>
					</ul>
				</section>
				<section>
					<h3>Интерфейс ITelemetryProcessor</h3>
					<pre>
					<code class="hljs">
public interface ITelemetryProcessor
{
    void Process(ITelemetry item);
}
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim>
public class SuccessfulDependencyFilter : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }
    public SuccessfulDependencyFilter(ITelemetryProcessor next)
    {
        this.Next = next;
    }
    public void Process(ITelemetry item)
    {
        if (!OKtoSend(item)) { return; }
        ModifyItem(item);

        this.Next.Process(item);
    }
    private bool OKtoSend(ITelemetry item)
    {
        var dependency = item as DependencyTelemetry;
        if (dependency == null) return true;

        return dependency.Success != true;
    }
    private void ModifyItem(ITelemetry item)
    {
        item.Context.Properties.Add("app-time", DateTime.Now.ToLongTimeString());
    }
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Настройка App Insights</h2>
				</section>
				<section>
					<h3>Добавление новой службы</h3>
					<img src="img/IN_1.png" alt="">
				</section>
				<section>
					<h3>Настройка параметров</h3>
					<img src="img/IN_2.png" alt="">
				</section>
				<section>
					<h3>Результат настройки</h3>
					<img src="img/IN_3.png" alt="">
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/IN_4.png" alt="">
				</section>
			</section>
			<section>
				<h2>Интерфейс ITelemetry</h2>
				<pre>
						<code class="hljs">
public interface ITelemetry
{
    //  Контекст связанный с текущей телеметрией
    TelemetryContext Context { get; }

    // Отслеживания абсолютного порядка телеметрий. Состоит из двух частей: 
    // постоянный идентификатор для текущего сеанса 
    // и идентификатор для каждого события добавляется в очередь (инкрементален)
    string Sequence { get; set; }

    //  Время записи данных телеметрии
    DateTimeOffset Timestamp { get; set; }

    //  Проверяет наличие потенциально опасных (или не валидных) данных 
    void Sanitize();
}
						</code>
					</pre>
			</section>
			<section>
				<h2>
					Класс TelemetryContext
				</h2>
				<pre>
					<code class="hljs">
public sealed class TelemetryContext
{
    public TelemetryContext();
    public CloudContext Cloud { get; }
    public ComponentContext Component { get; }
    public DeviceContext Device { get; }
    public string InstrumentationKey { get; set; }
    public LocationContext Location { get; }
    public OperationContext Operation { get; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public SessionContext Session { get; }
    public UserContext User { get; }
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Класс TelemetryConfiguration</h2>
				<pre>
					<code class="hljs">
public sealed class TelemetryConfiguration : IDisposable
{
    public TelemetryConfiguration();
    public static TelemetryConfiguration Active { get; }
    public bool DisableTelemetry { get; set; }
    public string InstrumentationKey { get; set; }
    public ITelemetryChannel TelemetryChannel { get; set; }
    public IList&lt;ITelemetryInitializer&gt; TelemetryInitializers { get; }
    public TelemetryProcessorChainBuilder TelemetryProcessorChainBuilder { get; }
    public ReadOnlyCollection&lt;ITelemetryProcessor&gt; TelemetryProcessors { get; }
    public static TelemetryConfiguration CreateDefault();
    public static TelemetryConfiguration CreateFromConfiguration(string config);
    public void Dispose();
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Класс TelemetryClient</h2>
				<pre>
					<code class="hljs" data-trim>
public sealed class TelemetryClient
{
    public TelemetryClient();
    public TelemetryClient(TelemetryConfiguration configuration);
    public TelemetryContext Context { get; }
    public string InstrumentationKey { get; set; }
    public void Flush();
    public void Initialize(ITelemetry telemetry);
    public bool IsEnabled();
    public void Track(ITelemetry telemetry);
    public void TrackAvailability(AvailabilityTelemetry telemetry);
    public void TrackAvailability(string name, DateTimeOffset timeStamp, TimeSpan duration, string runLocation, bool success, string message = null);
    public void TrackEvent(EventTelemetry telemetry);
    public void TrackEvent(string eventName, IDictionary&lt;string, string&gt; properties = null, IDictionary&lt;string, double&gt; metrics = null);
    public void TrackException(ExceptionTelemetry telemetry);
    public void TrackException(Exception exception, IDictionary&lt;string, string&gt; properties = null, IDictionary&lt;string, double&gt; metrics = null);
    public void TrackMetric(MetricTelemetry telemetry);
    public void TrackMetric(string name, double value, IDictionary&lt;string, string&gt; properties = null);
    public void TrackPageView(string name);
    public void TrackPageView(PageViewTelemetry telemetry);
    public void TrackRequest(RequestTelemetry request);
    public void TrackRequest(string name, DateTimeOffset startTime, TimeSpan duration, string responseCode, bool success);
    public void TrackTrace(TraceTelemetry telemetry);
    public void TrackTrace(string message);
    public void TrackTrace(string message, IDictionary&lt;string, string&gt; properties);
    public void TrackTrace(string message, SeverityLevel severityLevel);
    public void TrackTrace(string message, SeverityLevel severityLevel, IDictionary&lt;string, string&gt; properties);
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Основные методы класса TelemetryClient</h2>
				</section>
				<section>
					<h3>Метод TrackTrace</h3>
					<blockquote>
						Используется для диагностики проблемных мест (анализ и диагностический поиск) приложения. Может использловаться как "обертка"
						для системы логирования
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message, IDictionary&lt;string, string&gt; properties);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message, SeverityLevel severityLevel);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(
    string message, 
    SeverityLevel severityLevel, 
    IDictionary&lt;string, string&gt; properties
);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(TraceTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>SeverityLevel</h3>
					<pre>
						<code class="hljs">
public enum SeverityLevel
{
    Verbose = 0,
    Information = 1,
    Warning = 2,
    Error = 3,
    Critical = 4
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс TraceTelemetry</h3>
					<blockquote>
						Используется для логирования данных. Оперирует сообщением, временем активации и дополнительными параметрами
					</blockquote>
					<pre>
						<code class="hljs">
public sealed class TraceTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public TraceTelemetry();
    public TraceTelemetry(string message);
    public TraceTelemetry(string message, SeverityLevel severityLevel);
    public TelemetryContext Context { get; }
    public string Message { get; set; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    public SeverityLevel? SeverityLevel { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackPageView</h3>
					<blockquote>
						логирует название страницы (web, mobile, desktop)-приложения, с которой пользователь работает в данный момент
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackPageView(string name);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackPageView(PageViewTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс PageViewTelemetry</h3>
					<blockquote>
						отслеживание посещаймости страниц пользователями
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public sealed class PageViewTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public PageViewTelemetry();
    public PageViewTelemetry(string pageName);
    public TelemetryContext Context { get; }
    //  Длительность посещения страницы
    public TimeSpan Duration { get; set; }
    //  Пользовательские метрики
    public IDictionary&lt;string, double&gt; Metrics { get; }
	// Имя страницы
    public string Name { get; set; }
    // Словарь для дополнительных параметров
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    // Время, когда событие произошло
    public DateTimeOffset Timestamp { get; set; }
    // URL-страницы
    public Uri Url { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackEvent</h3>
					<blockquote>
						Позволяет логировать вызовы событий в приложении для определения частотности выбора пользователем определенной функции, цели
						и т.д.
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackEvent(EventTelemetry telemetry);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackEvent(
    string eventName, 
    IDictionary&lt;string, string&gt; properties = null, 
    IDictionary&lt;string, double&gt; metrics = null
);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackRequest</h3>
					<blockquote>
						Применяется для логирования или имитации выполнения HTTP-запросов в приложении
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackRequest(RequestTelemetry request);
						</code>
					</pre>
					<pre>
						<code class="hljs">
// name: имя запроса или путь
// startTime: время инициализации запроса
// duration: продолжительность выполнения
// responseCode: status code
// success: True, если обработан успешно
public void TrackRequest(
    string name, 
    DateTimeOffset startTime, 
    TimeSpan duration, 
    string responseCode, 
    bool success
);				
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс RequestTelemetry</h3>
					<blockquote>
						Инкапсулирует информацию о HTTP-запросах в приложении
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public sealed class RequestTelemetry : 
    OperationTelemetry, ITelemetry, ISupportProperties, ISupportSampling
{
    public RequestTelemetry();
    public RequestTelemetry(string name, DateTimeOffset startTime, 
	   TimeSpan duration, string responseCode, bool success);
    public override TelemetryContext Context { get; }
    public override TimeSpan Duration { get; set; }
    public string HttpMethod { get; set; }
    // Идентификатор запроса
    public override string Id { get; set; }
    public IDictionary&lt;string, double&gt; Metrics { get; }
    //  Имя человека, выполнявшего запрос
    public override string Name { get; set; }
    public override IDictionary&lt;string, string&gt; Properties { get; }
    public string ResponseCode { get; set; }
    public override string Sequence { get; set; }
    // Идентифицирует субъект, обычно записывается хеш
    public string Source { get; set; }
    public override bool? Success { get; set; }
    public override DateTimeOffset Timestamp { get; set; }
    public Uri Url { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackMetric</h3>
					<blockquote>
						Используется для отправки метрик, которые не привязаны к конкретным событиям. Метрики отображаются в виде статистических
						графиков, но в отличие от событий, можно выполнить диагностический поиск по отдельным значениям
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackMetric(
    string name, // имя метрики
    double value, // значение метрики
    IDictionary&lt;string, string&gt; properties = null
    // дополнительные свойства для классификации и фильтрации
);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackMetric(MetricTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс MetricTelemetry</h3>
					<blockquote>
						Инкапсулирует логику отслеживания метрик
					</blockquote>
					<pre>
						<code class="hlsj" data-trim>
public sealed class MetricTelemetry : 
    ITelemetry, ISupportProperties
{
    public MetricTelemetry();
    public MetricTelemetry(string metricName, double metricValue);
    public TelemetryContext Context { get; }
    //  количество элементов
    public int? Count { get; set; }
    //  максимальное значение для метрики
    public double? Max { get; set; }
    // минимальное значение для метрики
    public double? Min { get; set; }
    public string Name { get; set; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    //  Стандартное отклонение для значения метрики
    public double? StandardDeviation { get; set; }
    public DateTimeOffset Timestamp { get; set; }
	// Значение метрики
    public double Value { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackException</h3>
					<blockquote>
						Логирует отловленные исключения. Используется для подсчета показателя частоты возникновения проблем. Включает в отчеты результат
						стека вызова функций
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackException(
    Exception exception, 
    IDictionary&lt;string, string&gt; properties = null, 
    IDictionary&lt;string, double&gt; metrics = null
);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackException(ExceptionTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс ExceptionTelemetry</h3>
					<blockquote>
						Инкапсулирует логику логирования искулючительных ситуаций
					</blockquote>
					<pre>
						<code class="hljs">
public sealed class ExceptionTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public ExceptionTelemetry();
    public ExceptionTelemetry(Exception exception);
    public TelemetryContext Context { get; }
    public Exception Exception { get; set; }
	// Информация о месте обработки и отлова исключения
    public ExceptionHandledAt HandledAt { get; set; }
    public string Message { get; set; }
    public IDictionary&lt;string, double&gt; Metrics { get; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    public SeverityLevel? SeverityLevel { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Простой пример</h2>
				</section>
				<section>
					<h3>Nuget-пакет</h3>
					<img src="img/IN_nuget.png" alt="">
				</section>
				<section>
					<h3>Какой-то класс (псевдокод)</h3>
					<pre>
							<code class="hljs" data-trim>
public class ApplicationInsight
{
    private static readonly Lazy&lt;ApplicationInsight&gt; _instance;

    private readonly TelemetryClient _tc;

    private ApplicationInsight()

    public static ApplicationInsight Instance {get;}

    private TelemetryClient InitializeTelemetry(){/**/}

    public void TrackPageView(string name){/**/}

    public void TrackException(Exception ex){/**/}

    public void TrackMetric(string metricName, int value){/**/}

    public void TrackTrace(string eventName, int number){/**/}

    public void Flush(){/**/}
}
							</code>
					</pre>
				</section>
				<section>
					<h3>Singleton</h3>
					<pre>
						<code class="hljs" data-trim>
public class ApplicationInsight
{
    private static readonly Lazy&lt;ApplicationInsight&gt; _instance = 
		new Lazy&lt;ApplicationInsight&gt;(() =&gt; new ApplicationInsight());
    private readonly TelemetryClient _tc;

    private ApplicationInsight()
    {
        _tc = InitializeTelemetry();
    }

    public static ApplicationInsight Instance
    {
        get { return _instance.Value; }
    }
    //.......................	
}					
						</code>
					</pre>
				</section>
				<section>
					<h3>Инициализация параметров</h3>
					<pre>
						<code class="hljs">
private TelemetryClient InitializeTelemetry()
{
    var tc = new TelemetryClient
    {
        InstrumentationKey =
            @"clientNotification-ddadd7d9-4bd5-411a-ab5c-c1fe3322e005;
             a518aea0-2971-4fd4-9c38-595b8ffee7ab;
             a518aea0-2971-4fd4-9c38-595b8ffee7ab"
    };

    tc.Context.User.Id = Environment.UserName;
    tc.Context.Session.Id = Guid.NewGuid().ToString();
    tc.Context.Device.OperatingSystem = Environment.OSVersion.ToString();

    return tc;
}
						</code>						
					</pre>
				</section>
				<section>
					<h3>Пример использования</h3>
					<pre>
						<code class="hljs" data-trim>
static void Main(string[] args)
{
    ApplicationInsight.Instance.TrackPageView("Home");
    ApplicationInsight.Instance.TrackPageView("Account");

    ApplicationInsight.Instance.TrackEvent("Login");
    ApplicationInsight.Instance.TrackException(
		new AuthenticationException("User not found"));

    ApplicationInsight.Instance.TrackEvent("Redirect",
        new Dictionary&lt;string, string&gt;
        {
            { "From", "Account" },
            { "To", "Shop" },
            { "DailyKey" , "DSJU-WERDT-9803"}
        });
	
    ApplicationInsight.Instance.TrackPageView("Shop");
    ApplicationInsight.Instance.TrackTrace("Overtime", 100);
    ApplicationInsight.Instance.TrackMetric("Total count", 32);

    ApplicationInsight.Instance.Flush();
}							
						</code>
					</pre>
				</section>
				<section>
					<h3>Результаты в Azure</h3>
					<img src="img/IN_5.png" alt="">
				</section>
			</section>
			<section>
				<h3>Аналитика</h3>
				<blockquote>
					Аналитика — это мощный инструмент поиска Application Insights. На этих страницах описан язык запросов аналитики приложений.
				</blockquote>
			</section>
			<section>
				<h3>Особенности языка</h3>
				<ul>
					<li>Фильтрация необработанных данных телеметрии приложения по любым полям, включая пользовательские свойства и метрики.</li>
					<li>Соединение нескольких таблиц — соотношение запросов с просмотрами страниц, вызовами зависимостей, исключениями и трассировками
						журнала.
					</li>
					<li>Сложные статистические агрегаты.</li>
					<li>Такие же мощные, как в SQL, но гораздо проще для составления сложных запросов: вместо вложенных инструкций данные передаются
						из одной простой операции в другую.</li>
					<li>Мгновенные яркие визуализации.</li>
					<li>Типичный запрос содержит исходную таблицу и ряд операторов, разделенных |.</li>
				</ul>
			</section>
			<section>
				<section>
					<h3>Поддерживаемые конструкции</h3>
					<ul>
						<li>Let: присвоение имени таблице</li>
						<li>Запросы и операторы: count, evaluate, extend, join, limit, mvexpand, parse, project, project-away, range, reduce, render
							directive, restrict clause, sort, summarize, take, top, top-nested, union, where, where-in</li>
						<li>Статистические функции: any, argmax, argmin, avg, buildschema, count, countif, dcount, dcountif, makelist, makeset,
							max, min, percentile, percentiles, percentilesw, percentilew, stdev, sum, variance</li>
						<li>Скаляры: логические литералы, логические операторы, приведения, скалярные сравнения, gettype, hash, iff, isnotnull,
							isnull, notnull, toscalar</li>
						<li>Числа: арифметические операторы, числовые литералы, abs, bin, exp, floor, gamma, log, rand, sqrt, todouble, toint,
							tolong
						</li>
					</ul>
				</section>
				<section>
					<h3>Поддерживаемые конструкции</h3>
					<ul>
						<li>Дата и время: выражения даты и времени, литералы даты и времени, ago, datepart, dayofmonth, dayofweek, dayofyear, endofday,
							endofmonth, endofweek, endofyear, getmonth, getyear, now, startofday, startofmonth, startofweek, startofyear, todatetime,
							totimespan, weekofyear</li>
						<li>Строка: GUID, маскируемые строковые литералы, cтроковые литералы, cравнение строк, countof, extract, isempty, isnot,
							empty, empty, notempty, parseurl, replace, split, strcat, strlen, substring, tolower, toupper</li>
						<li>Массивы, объекты и динамические типы: литералы массива и объекта, функции динамического объекта, динамические объекты,
							выражения пути JSON, arraylength, extractjson, parsejson, range, todynamic, treepath</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Основные операторы запроса</h3>
				<ul>
					<li>take - отображение n строк</li>
					<li>top - выборка n строк</li>
					<li>sort - сортировка для всей таблицы</li>
					<li>project - выбор, переименование и вычисление столбцов</li>
					<li>extend - вычисление столбцов</li>
					<li>summarize - агрегирование групп строк</li>
					<li>where - фильтрация по условию</li>
					<li>join - доступ к нескольким таблицам, включая запросы и исключения</li>
					<li>let - присвоение результата переменной</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Примеры запросов</h2>
				</section>
				<section>
					<h3>Пример 1</h3>
					<pre>
						<code class="hljs">
requests | top 10 by timestamp desc 

requests | sort by timestamp desc | take 10
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 2</h3>
					<pre>
						<code class="hljs">					
requests | top 10 by timestamp desc
         | project timestamp, name, resultCode
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 3</h3>
					<pre>
						<code class="hljs">
requests 
      | top 10 by timestamp desc 
      | project  
            name, 
            response = resultCode,
            timestamp, 
            ['time of day'] = floor(timestamp % 1d, 1s)
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 4</h3>
					<pre>
						<code class="hljs">
exceptions 
      | where device_Id == "browser" 
      | summarize count() 
	    by device_BrowserVersion, outerExceptionMessage 
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 5</h3>
					<pre>
						<code class="hljs">				
dependencies
    | where timestamp > ago(1d) and  client_Type == "Browser"
    | join (browserTimings | where timestamp > ago(1d))
      on operation_Id
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 6</h3>
					<pre>
					<code class="hljs">
requests 
    | where timestamp > ago(7d) and client_City == "Hyderabad"
    | summarize clients = dcount(client_IP) 
      by tod_UTC=bin(timestamp % 1d, 1h), resultCode
    | extend local_hour = (tod_UTC + 5h + 30min) % 24h + datetime("2001-01-01") 
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример 7</h3>
					<img src="img/insight_analytics.png" alt="">
				</section>
			</section>
			<section>
				<h2>Схема работы пользователя</h2>
				<img src="img/scheme-1.png" alt="">
			</section>
			<section>
				<img src="img/azure-main.png" alt="">
			</section>
			<section>
				<h1>Service Bus</h1>
			</section>
			<section>
				<h2>Сервисная шина предприятия</h2>
				<blockquote>
					Сервисная шина предприятия (enterprise service bus) — связующее программное обеспечение, обеспечивающее централизованный
					и унифицированный событийно-ориентированный обмен сообщениями между различными информационными системами на принципах
					сервис-ориентированной архитектуры
				</blockquote>
			</section>
			<section>
				<h2>Назначение</h2>
				<ul>
					<li>Концентрация обмена сообщениями между различными системами через единую точку</li>
					<li>Обеспечивается транзакционный контроль</li>
					<li>Единым механизм преобразование данных </li>
					<li>Единый механиз обеспечения сохранности сообщений</li>
				</ul>
			</section>
			<section>
				<h2>Основные характеристики</h2>
				<ul>
					<li>Поддержка синхронного и асинхронного способа вызова служб</li>
					<li>Использование защищенного транспорта, с гарантированной доставкой сообщений, поддерживающего транзакционную модель</li>
					<li>Статическая и алгоритмическая маршрутизация сообщений</li>
					<li>Доступ к данным из сторонних информационных систем с помощью специально разработанных адаптеров</li>
					<li>Обработка и преобразование сообщений</li>
					<li>Оркестровка служб (описывает как сервисы должны взаимодействовать между собой, используя для этого обмен сообщениями,
						включая бизнес-логику и последовательность действий)</li>
					<li>Разнообразные механизмы контроля и управления (аудиты, протоколирование)</li>
				</ul>
			</section>
			<section>
				<h2>Способы работы</h2>
				<ul>
					<li>Синхронный - потребитель использует один поток для вызова службы; поток передает запрос, блокируется на время выполнения
						службы и ждет ответ. Если у потребителя возникает аварийная ситуация во время блокирования при работе службы, нельзя
						повторно подключиться к этой службе после перезапуска, поэтому ответ теряется</li>
					<li>Асинхронный - потребитель использует два потока для вызова службы; один - для передачи запроса, второй – для приема
						ответ. Если у потребителя возникает аварийная ситуация во время ожидания ответа на запрос, после перезапуска потребитель
						может продолжать ожидать ответ, ответ не теряется</li>
				</ul>
			</section>
			<section>
				<h3>Примеры программных продуктов</h3>
				<ul>
					<li>Active Directory</li>
					<li>UDDI</li>
					<li>BizTalk Server</li>
					<li>MSMQ</li>
					<li>WCF</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Пример схем использований</h2>
				</section>
				<section>
					<h3>Схема канала точка-точка</h3>
					<img src="img/точка_точка.png" alt="">
				</section>
				<section>
					<h3>Схема канала публикация-подписка</h3>
					<img src="img/публикация_подписка.png" alt="">
				</section>
				<section>
					<h3>Схема канала недоставленных сообщений</h3>
					<img src="img/недоставленное_сообщение.png" alt="">
				</section>
				<section>
					<h3>Схема гарантированной доставки</h3>
					<img src="img/гарантированная_доставка.png" alt="">
				</section>
				<section>
					<h3>Схема шины сообщений</h3>
					<img src="img/шина_сообщений.png" alt="">
				</section>
			</section>
			<section>
				<!-- https://msdn.microsoft.com/ru-ru/library/ee872418.aspx -->
				<h3>Пример схемы функционирования ПО</h3>
				<img src="img/servicebus_scheme.jpg" alt="">
			</section>
			<section>
				<h1>Очередь сообщений</h1>
			</section>
			<section>
				<section>
					<h2>Причины использования MQ</h2>
					<ul>
						<li>Слабое связывание — создают неявные интерфейсы обмена данными, которые позволяют процессам быть независимыми друг от
							друга
						</li>
						<li>Избыточность — позволяют избежать случаев неэкономного использования ресурсов процесса (например памяти) в результате
							хранения необработанной информации</li>
						<li>Масштабируемость — позволяют распределить процессы обработки информации. Увеличивается скорость, с которой сообщения
							добавляются в очередь и обрабатываются</li>
						<li>Эластичность и возможность выдерживать пиковые нагрузки — могут выполнять роль своего рода буфера для накопления данных
							в случае пиковой нагрузки, и не допуская отказа системы</li>
						<li>Отказоустойчивость — позволяют отделить процессы друг от друга, так что если процесс, который обрабатывает сообщения
							из очереди падает, то сообщения могут быть добавлены в очередь на обработку позднее, когда система восстановится</li>
					</ul>
				</section>
				<section>
					<h2>Причины использования MQ</h2>
					<ul>
						<li>Гарантированная доставка — гарантирует, что сообщение будет доставлено и обработано в любом случае</li>
						<li>Гарантированный порядок доставки — большая часть систем очередей сообщений способны обеспечить гарантии того, что данные
							будут обрабатываться в определённом порядке (чаще всего в том порядке в котором они поступили)</li>
						<li>Буферизация — позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный
							слой
						</li>
						<li>Понимание потоков данных — позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая
							из очередей забивается, какая простаивает и определить что необходимо делать — добавлять новых обработчиков сообщений
							или оптимизировать текущую архитектуру</li>
						<li>Асинхронная связь — предоставляют возможность асинхронной обработки данных, которая позволяет поместить сообщение в
							очередь без обработки, позволяя системе обработать сообщение позднее, когда появится возможность
						</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Область применения</h2>
				<ul>
					<li>Обработка данных</li>
					<li>Буферизация потоков данных</li>
					<li>Управление процессами</li>
					<li>Интеграция и взаимодействие систем</li>
				</ul>
			</section>
			<section>
				<h2>Примеры очередей</h2>
				<ul>
					<li>RabbitMQ</li>
					<li>MSMQ</li>
					<li>Amazon SQS</li>
					<li>IronMQ</li>
					<li>StormMQ</li>
					<li>Azure Queues</li>
				</ul>
			</section>
			<!-- -->
			<section>
				<h1>Azure Service Bus</h1>
			</section>
			<section>
				<h2>Служебная шина Azure</h2>
				<blockquote>
					Высоконадежная облачная система для обмена сообщениями между приложениями и службами, которая эффективно работает, даже если
					некоторые элементы инфраструктуры недоступны в сети
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Основное назначение</h2>
				</section>
				<section>
					<h3>Создание масштабируемых облачных решений</h3>
					<blockquote>
						Асинхронный обмен сообщениями не только обеспечивает устойчивую работу приложений, но и дает возможность надежно масштабировать
						используемое решение. Интеграция облачных ресурсов, таких как база данных SQL, служба хранилища и веб-приложения службы
						приложений, со службой обмена сообщениями служебной шины гарантирует надежную работу в условиях любых нагрузок и позволяет
						избежать простоев в случае сбоя
					</blockquote>
				</section>
				<section>
					<h3>Внедрение сложных процессов обмена сообщениями</h3>
					<blockquote>
						Служебная шина позволяет создавать надежные топологии обмена сообщениями со сложными параметрами маршрутизации, одновременно
						повышая общую доступность решения. С ее помощью можно доставлять сообщения одновременно нескольким подписчикам, а также
						рассылать сообщения в системы, расположенные на нижних уровнях архитектуры системы
					</blockquote>
				</section>
				<section>
					<h3>Повышение безопасности между гибридными облаками</h3>
					<blockquote>
						Функция гибридных подключений в ретрансляторе служебной шины позволяет безопасно работать с имеющимися ресурсами, где бы
						они ни находились, не используя сложные VPN-конфигурации, настройки брандмауэра или параметры сети. Эта функция обеспечивает
						расширенную проверку подлинности и подключение через облако, а также позволяет просматривать и отслеживать активность
					</blockquote>
				</section>
				<section>
					<h3>Использование одного подключения несколькими приложениями</h3>
					<blockquote>
						Благодаря гибридным подключениям и ретранслятору служебной шины не нужно никуда переносить свои локальные данные, чтобы настроить
						к ним доступ из облака или любого другого расположения
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/servicebus_architecture.png" alt="">
			</section>
			<section>
				<h2>Механизмы взаимодействия</h2>
				<ul>
					<li><span class="highlight-blue">Очереди</span> (однонаправленное взаимодействие) - действует как посредник (брокер), который
						хранит отправленные сообщения, пока они не будут получены. Каждое сообщение получает один получатель</li>
					<li><span class="highlight-blue">Разделы</span> (однонаправленное взаимодействие с использованием подписок) - подобно очереди,
						действует как брокер, но каждая подписка может при необходимости применить фильтр, чтобы получать только те сообщения,
						которые соответствуют определенным условиям. В одном разделе может быть несколько подписок</li>
					<li><span class="highlight-blue">Ретрансляторы</span> (двунаправленное взаимодействие) - не хранит передаваемые сообщения,
						так как не является брокером</li>
				</ul>
			</section>
			<section>
				<h2>Ключевые моменты</h2>
				<blockquote>
					При создании очереди, раздела или ретранслятора задается имя. В комбинации с именем пространства имен это имя создает уникальный
					идентификатор объекта. Приложения могут передать это имя службе Service Bus, а затем использовать соответствующую очередь,
					раздел или ретранслятор для взаимодействия с другими приложениями
				</blockquote>
				<blockquote>
					Каждое сообщение состоит из двух частей: набора свойств (пар ключ/значение) и двоичного тела сообщения
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Очереди</h2>
				</section>
				<section>
					<h3>Схема обмена данными через очередь</h3>
					<img src="img/servicebus_queues.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Два способа считывания сообщения: ReceiveAndDelete (извлекает сообщение из очереди и сразу удаляет его) и PeekLock
							(извлекает сообщение из очереди, блокирует сообщение, делая его невидимым для других получателей, а затем ожидает
							определенного события)
						</li>
						<li>
							Получатели принимают и обрабатывают сообщения в том порядке, в котором они были добавлены в очередь
						</li>
						<li>Может отправлять и получать сообщения с разной скоростью (выравнивании нагрузки). Это сокращает расходы на инфраструктуру,
							необходимую для обработки нагрузки приложения</li>
						<li>
							Уменьшает зависимость между компонентами. Обновление потребителя не будут оказывать влияния на производителя
						</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Разделы</h2>
				</section>
				<section>
					<h3>Схема обмена данными через разделы</h3>
					<img src="img/servicebus_topicsandsubscriptions.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Позволяют каждому принимающему приложению создавать собственную подписку, определив фильтр. Подписчик будет видеть
							только те сообщения, которые соответствуют фильтру
						</li>
						<li>Два способа считывания сообщения: ReceiveAndDelete и PeekLock)
						</li>
						<li>Каждое опубликованное сообщение становится доступным в рамках каждой подписки, зарегистрированной в разделе. Сообщения
							отправляются в раздел и доставляются в одну или несколько связанных подписок в зависимости от правил фильтрации</li>
						<li>Нельзя непосредственно получить сообщение из раздела (только из подписок). Подписка раздела напоминает виртуальную
							очередь, которая получает копии сообщений, отправленных в раздел</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Ретрансляторы</h2>
				</section>
				<section>
					<h3>Схема обмена данными через ретранслятор</h3>
					<img src="img/servicebus_relay.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Обходит ограничения реобразование сетевых адресов (NAT) и блокировки Брандмауэром внешних портов через NAT</li>
						<li>Для двунаправленного взаимодействия через ретранслятор каждое приложение устанавливает исходящее TCP-соединение с Service
							Bus и держит его открытым</li>
						<li>Удержание соединение позволяет брандмауэру разрешать входящий трафик для каждого приложения без открытия новых портов.
							Этот подход также решает проблему NAT, так как каждое приложение имеет постоянную конечную точку в облаке на протяжении
							всего обмена данными</li>
						<li>Service Bus предоставляет привязки WCF, которые упрощают взаимодействие приложений через ретрансляторы</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Схемы работы Azure Service Bus Queues</h2>
				</section>
				<section>
					<h3>Пример 1</h3>
					<img src="img/servicebus_azure_combination_1.png" alt="">
				</section>
				<section>
					<h3>Пример 2</h3>
					<img src="img/servicebus_azure_combination_2.png" alt="">
				</section>
			</section>
			<section>
				<h1>Архитектура служебной шины Azure</h1>
			</section>
			<section>
				<section>
					<!--https://github.com/Microsoft/azure-docs.ru-ru/blob/master/articles/service-bus/service-bus-architecture.md -->
					<h2>Единицы масштабирования</h2>
					<blockquote>
						Содержимое служебной шины упорядочено по единицам масштабирования.
					</blockquote>
					<blockquote>
						Единица масштабирования — это единица развертывания, которая содержит все компоненты, необходимые для запуска службы. Для
						каждой области развертывается одна или несколько единиц масштабирования служебной шины
					</blockquote>
				</section>
				<section>
					<h3>Структура единиц масштабирования</h3>
					<ul>
						<li>Набор узлов шлюза - проверяют подлинность входящих запросов и обрабатывают запросы на ретрансляцию. У каждого узла
							шлюза есть общедоступный IP-адрес</li>
						<li>Набор узлов брокера сообщений - обрабатывают запросы к сущностям обмена сообщениями</li>
						<li>Единое хранилище шлюза - содержит данные по каждой сущности, определенной в соответствующей единице масштабирования.
							Хранилище шлюза реализуется на основе базы данных SQL Azure</li>
						<li>Хранилища сообщений - содержат сообщения из всех очередей, разделов и подписок, определенных в соответствующей единице
							масштабирования. Здесь же хранятся все данные подписки. Если не включены секционированные сущности обмена сообщениями,
							очередь или раздел сопоставляется с одним хранилищем</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Контейнеры</h2>
					<blockquote>
						Контейнер — логическая конструкция, которая использует одно единственное хранилище сообщений для хранения всех соответствующих
						данных в этом контейнере. Каждый контейнер назначается узлу брокера сообщений
					</blockquote>
				</section>
				<section>
					<h3>Особенности контейнеров</h3>
					<ul>
						<li>Определенный контейнер назначается каждой сущности обмена сообщениями</li>
						<li>Каждый контейнер назначается узлу брокера сообщений</li>
						<li>Каждый узел брокера сообщений загружает несколько контейнеров. Контейнеры назначаются узлу брокера сообщений таким
							образом, чтобы все узлы брокера сообщений были загружены в равной мере</li>
						<li>Если шаблон нагрузки меняется (один из контейнеров загружается слишком сильно) или узел брокера сообщений становится
							временно недоступным, контейнеры перераспределяются между узлами брокера сообщений</li>
					</ul>
				</section>
				<section>
					<h3>Пространства имен</h3>
					<blockquote>
						Пространство имен — это общий контейнер для всех компонентов обмена сообщениями. В одном пространстве имен могут содержаться
						несколько очередей и разделов. Часто пространства имен выполняют роль контейнеров приложений
					</blockquote>
				</section>
			</section>
			<section>
				<section>
					<h2>Обработка входящих запросов обмена сообщениями</h2>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<ol>
						<li>Клиент отправляет запрос на служебную шину, подсистема балансировки нагрузки передает его в один из узлов шлюза</li>
						<li>Узел шлюза авторизует запрос</li>
						<li>Если запрос относится к сущности обмена сообщениями (очереди, разделу или подписке), узел шлюза выполняет поиск этой
							сущности в хранилище шлюза и определяет, в каком хранилище сообщений она находится</li>
						<li>Определяется какой узел брокера сообщений обслуживает контейнер в данный момент, и отправляет запрос на этот узел
						</li>
						<li>Узел брокера обрабатывает запрос и обновляет состояние сущности в хранилище контейнера</li>
						<li>Узел отправляет ответ обратно на узел шлюза, который пересылает соответствующий ответ клиенту, отправившему исходный
							запрос
						</li>
					</ol>
				</section>
				<section>
					<h3>Графическое представление</h3>
					<img src="img/Обработка_входящих_запросов_обмена_сообщениями.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Обработка входящих запросов на ретрансляцию</h2>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<ol>
						<li>Клиент отправляет запрос на служебную шину, подсистема балансировки нагрузки передает его в один из узлов шлюза
						</li>
						<li>Если запрос связан с прослушиванием, узел шлюза создает новую ретрансляцию</li>
						<li>Если запрос связан с подключением к определенной ретрансляции, узел шлюза переадресовывает его на узел шлюза, которому
							принадлежит ретрансляция</li>
						<li>Узел шлюза, которому принадлежит ретрансляция, отправляет запрос о подключении клиенту прослушивания, чтобы прослушиватель
							создал временный канал к узлу шлюза, получившему запрос на подключение</li>
						<li>При установки подключения ретрансляции, клиенты могут обмениваться сообщениями через узел шлюза, используемый для связи</li>
					</ol>
				</section>
				<section>
					<h3>Графическое представление</h3>
					<img src="img/Обработка_входящих_запросов_на_ретрансляцию.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Аутентификация и авторизация</h2>
					<blockquote>
						Приложения могут проходить проверку подлинности в служебной шине Azure, используя либо проверку подлинности подписанного
						URL-адреса (SAS), либо службу контроля доступа Azure Active Directory (ACS).
					</blockquote>
				</section>
				<section>
					<h3>Проверка подлинности с помощью подписанного URL-адреса (SAS)</h3>
					<ul>
						<li>Позволяет предоставлять пользователю доступ к ресурсам служебной шины с определенными правами</li>
						<li>Предусматривает настройку соответствующих прав для криптографического ключа в ресурсе служебной шин</li>
						<li>Поддерживается в ретрансляторах служебной шины</li>
						<li>Для получения доступа к сущности, клиенту требуется маркер SAS, который создается с помощью правила SharedAccessAuthorizationRule
						</li>
						<li>Маркер создается с помощью хэш-функции HMAC-SHA256 строки ресурса, состоящей из URI ресурса, к которому запрашивается
							доступ, и срока действия с криптографическим ключом, связанным с правилом авторизации</li>
					</ul>
				</section>
				<section>
					<h3>Объект SharedAccessAuthorizationRule</h3>
					<ul>
						<li>KeyName — определяет правило</li>
						<li>PrimaryKey — криптографический ключ, используемый для подписи и проверки маркеров SAS</li>
						<li>SecondaryKey — криптографический ключ, используемый для подписи и проверки маркеров SAS</li>
						<li>Rights — набор прав на прослушивание, отправку или управление</li>
					</ul>
				</section>
				<section>
					<h3>Проверка подлинности ACS</h3>
					<blockquote>
						Аутентификация с помощью ACS осуществляется с помощью связанного пространства имен ACS
					</blockquote>
					<ul>
						<li>Необходимо настроить соответствующие отношения доверия</li>
						<li>Для получения доступа к сущности, клиент запрашивает маркер SWT из ACS с соответствующими утверждениями, предоставляя
							свои учетные данные. Затем маркер SWT необходимо отправить в служебную шину как часть запроса. Это позволит авторизовать
							клиента для получения доступа к сущности</li>
						<li>Проверка подлинности импользует объект SharedSecretTokenProvider</li>
						<li>Все интерфейсы API, которые принимают строку подключения в качестве параметра, поддерживают строки подключения ACS</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Итого</h2>
					<ul>
						<li>Позволяет получать сообщения без постоянного «поллинга»</li>
						<li>Гарантирует сохранение порядка обработки сообщений</li>
						<li>Автоматически детектирует дубликаты сообщений</li>
						<li>Обрабатывать сообщения параллельно (сообщения ассоциируются с потоком по SessionId)</li>
						<li>Поддерживает транзакционность при отсылке или приёме группы сообщений</li>
						<li>Время жизни сообщения достаточно долгое (более 7 дней)</li>
						<li>Обрабатывать сообщения более 64КБ</li>
					</ul>
				</section>
				<section>
					<h3>Итого</h3>
					<ul>
						<li>Обеспечение безопасности на основе ролей и прав доступа</li>
						<li>Гарантия доставки</li>
						<li>Интерграция с .NET сервисами (WCF)</li>
						<li>Обмену сообщениями через посредника служебной шины на основе REST</li>
						<li>SDK для .NET, Java, Node.js, Ruby, Python, PHP</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример использования</h2>
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/SB_1.png" alt="">
				</section>
				<section>
					<h3>Создание пространства имен службы</h3>
					<img src="img/SB_2.png" alt="">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/SB_3.png" alt="">
				</section>
				<section>
					<h3>Результат создания namespace</h3>
					<img src="img/SB_4.png" alt="">
				</section>
				<section>
					<h3>Создание очереди</h3>
					<img src="img/SB_5.png" alt="">
				</section>
				<section>
					<h3>Результат создания очереди</h3>
					<img src="img/SB_6.png" alt="">
				</section>
				<section>
					<h3>Получение учетных данных управления</h3>
					<img src="img/SB_7.png" alt="">
				</section>
				<section>
					<h3>Строка подключения</h3>
					<img src="img/SB_8.png" alt="">
				</section>
				<section>
					<h3>Nuget-пакет</h3>
					<img src="img/SB_9.png" alt="">
				</section>
				<section>
					<h3>Отправка сообщения</h3>
					<pre>
						<code class="hljs">
static void Main(string[] args)
{
    //CONNECTION STRING–PRIMARY KEY
    var connectionString = @"Endpoint=
            sb://makshlservicebus.servicebus.windows.net/;
            SharedAccessKeyName=RootManageSharedAccessKey;
            SharedAccessKey=Jha3oP0D5jZku5Fs2nS/nhVW9bd6W9+00SqKW5T1Upw=";
    var queueName = "queue1";

    var client = QueueClient.CreateFromConnectionString(
          connectionString, 
          queueName
    );
    var message = new BrokeredMessage("This is a test message!");

    client.Send(message);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Статистика</h3>
					<img src="img/SB_10.png" alt="">
				</section>
				<section>
					<h3>Получение сообщения</h3>
					<pre>
						<code class="hljs">
static void Main(string[] args)
{
    //CONNECTION STRING–PRIMARY KEY
    var connectionString = @"Endpoint=
            sb://makshlservicebus.servicebus.windows.net/;
            SharedAccessKeyName=RootManageSharedAccessKey;
            SharedAccessKey=Jha3oP0D5jZku5Fs2nS/nhVW9bd6W9+00SqKW5T1Upw=";
    var queueName = "queue1";

    var client = QueueClient.CreateFromConnectionString(
          connectionString, 
          queueName
    );

    client.OnMessage(message =&gt;
    {
        Console.WriteLine($"Message body: {message.GetBody&lt;String&gt;()}");
        Console.WriteLine($"Message id: {message.MessageId}");
    });
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Полученные сообщения</h3>
					<img src="img/SB_11.png" alt="">
				</section>
				<section>
					<h3>Статистика</h3>
					<img src="img/SB_12.png" alt="">
				</section>
			</section>
			<!-- Содержимое лекции -->
			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/thanks.jpg" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>