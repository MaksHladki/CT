<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Название лекции</title>
	<meta name="description" content="">
	<meta name="keywords" content="">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h1>Платформа облачных вычислений Microsoft Azure</h1>
					<h3>Облачные технологии</h3>
					<p>
						<small>Гладкий Максим Валерьевич / <a href="https://github.com/MaksHladki">github:MaksHladki</a></small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<h1>Архитектура Windows Azure</h1>
			</section>
			<section>
				<h2>Microsoft Azure</h2>
				<blockquote>
					Открытая и гибкая облачная платформа, позволяющая быстро создавать, развертывать и управлять приложениями в глобальной сети
					центров обработки данных под управлением Майкрософт. Приложения можно разрабатывать с помощью любого языка, инструмента
					или платформы. Кроме того, приложения в общедоступном облаке можно интегрировать с имеющейся ИТ-средой
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Эволюция Microsoft Azure</h2>
				</section>
				<section>
					<h3>Первый этап</h3>
					<ul>
						<li>2006 - создана «команда мечты» для разработки облачной ОС RedDog</li>
						<li>2006 - команда Indigo (Windows Communication Foundation) приступает к работе над экспериментальным реле коммуникации
						</li>
						<li>2006 - команда SQL приступает к разработке интернет-версии своей службы</li>
						<li>2007 - три команды начинают сотрудничать друг с другом</li>
						<li>2008 - объединение команд в проект Azure: службы .NET, онлайн-службы, службы SQL. Предствлена Azure CTP</li>
					</ul>
				</section>
				<section>
					<h3>Второй этап</h3>
					<ul>
						<li>2009 - выходит версия CTP 3, подержка доверенного и платформенного кода, геолокация, fast CGI, PHP и Java SDK. Azure
							становится открытой платформой, выпускается первый официальный SDK 1.0</li>
						<li>2010 - платформа доступка в 21 стране, реализована поддержка БД более 50 ГБ, полноценная поддержка IIS и службы удаленного
							рабочего стола</li>
						<li>2011 - инструмент SQL Azure Reporting, Scheduler SDK для поддержки ресурсоемких параллельных приложений</li>
						<li>2012 - добавлена архитектура IaaS, выпущен Python SDK. ЦОДы работают в 8 регионах мира</li>
						<li>2013 - добавлена служба Active Directory</li>
					</ul>
				</section>
				<section>
					<h3>Третий этап</h3>
					<ul>
						<li>2014 - добавлены технологии и интерфейсы машинного обучения</li>
						<li>2014 - Windows Azure переименована в Microsoft Azure</li>
						<li>2015 - оптимизирована и расширена возможность работы с Linux-дистрибутивами</li>
						<li>2015 - добавлена поддержка контейнеров</li>
						<li>2016 - добавлена технология блокчейн, облачный майнинг</li>
					</ul>
				</section>
			</section>

			<section>
				<h2>Основные особенности</h2>
				<ul>
					<li>Открытая - поддерживаются многие ЯП и инструменты</li>
					<li>Гибкая - разнообразие облачных служб (от утилит развертывания до SQL-хранилищ)</li>
					<li>Под управлением Майкрософт - ЦОДы в США, Европе и Азии</li>
					<li>Совместимая - многие компоненты легко интегрирутся с Windows Server</li>
					<li>Собственная сеть CDN</li>
				</ul>
			</section>
			<section>
				<h2>Основные возможности</h2>
				<ul>
					<li>Инфраструктура</li>
					<li>Мобильные приложения</li>
					<li>Интернет</li>
					<li>Медиаконтент</li>
					<li>Интеграция</li>
					<li>Идентификация и управление доступом</li>
					<li>Большие данные</li>
					<li>Разработка и тестирование</li>
					<li>Хранение, архивация и восстановление</li>
					<li>Управление данными</li>
				</ul>
			</section>
			<section>
				<h2>Три ОС в одной концепции</h2>
				<ul>
					<li>Windows Server - платформа корпоративного уровня, фундаметр облачных вычислений</li>
					<li>System Center - интегрированная платформа для централизованного управления частными, размещенными и общедоступными облаками</li>
					<li>Windows Azure — открытая, гибкая облачная платформа для разработки, развертывания и управления приложениями и задачами,
						размещенными в глобальной сети центров обработки данных Майкрософ</li>
				</ul>
			</section>
			<section>
				<h2>Особенности портала Microsoft Azure</h2>
				<ul>
					<li>В универсальном магазине Marketplace представлены тысячи продуктов от корпорации Майкрософт и других поставщиков</li>
					<li>Единая масштабируемая система позволяет легко находить нужные ресурсы и выполнять различные операции по управлению</li>
					<li>Согласованные страницы управления (колонки) дают возможность управлять самыми разнообразными службами Azure, используя
						унифицированную систему отображения параметров, действий, данных для выставления счетов, сведений о работоспособности
						и использовании и т. д.</li>
					<li>Возможности персонализации позволяют создать собственный начальный экран, на котором после входа в систему будет отображаться
						только та информация, которая нужна пользователю</li>
				</ul>
			</section>
			<section>
				<h2>Free account</h2>
				<img src="img/free-account.png" alt="" height="550">
			</section>
			<section>
				<h1>Архитектура Windows Azure</h1>
			</section>
			<section>
				<h2>Типы приложений</h2>
				<p>С точки зрения пользователей</p>
				<ul>
					<li>Внутренние (on-premises app) - выполняются на компьютере пользователя</li>
					<li>Облачные - выполняются в среде Windows Azure в ЦОД</li>
				</ul>
			</section>
			<section>
				<h2>Службы Windows Azure</h2>
				<ul>
					<li>
						<spna class="highlight-blue">Вычислительные службы</spna> - предоставляют компьютерные ресурсы, на которых работают облачные приложения</li>
					<li>
						<spna class="highlight-blue">Сетевые службы</spna> - предоставляют облачные приложения и центрам обработки данных пользователям различными способами</li>
					<li>
						<spna class="highlight-blue">Службы обработки данных</spna> - способы хранения, управления, защиты и анализа бизнес-данные,составление отчетов по
						ним
					</li>
					<li>
						<spna class="highlight-blue">Службы приложений</spna> - улучшают производительность, защиту и уровень интеграции облачных приложений, а также делают
						более простым процесс их освоения</li>
				</ul>
			</section>

			<section>
				<h2>Вычислительные службы</h2>
				<table>
					<tbody>
						<tr>
							<td>Виртуальные машины</td>
							<td>универсальная среда для создания, развертывания и управления виртуальными машинами</td>
						</tr>
						<tr>
							<td>Веб-сайты</td>
							<td>специализированная среда для создания и управления веб-сайтами, а также переноса существующих</td>
						</tr>
						<tr>
							<td>Облачные службы</td>
							<td>создание и развертывание масшатабируемое ПО любой сложности на любом ЯП</td>
						</tr>
						<tr>
							<td>Мобильные службы</td>
							<td>технологии обработки и хранения данных для мобильных систем</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<h2>Сетевые службы</h2>
				<table>
					<tbody>
						<tr>
							<td>Виртуальная сеть</td>
							<td>позволяет использовать облако в качестве расширения локального ЦОДа</td>
						</tr>
						<tr>
							<td>Диспетчер трафика</td>
							<td>масшатбирование трафика по определнным критериям: максимальная производительность, циклическое обслуживание и уровень
								отказоустойчивости
							</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<h2>Службы обработки данных</h2>
				<table>
					<tbody>
						<tr>
							<td>Управление данными</td>
							<td>хранение и управление данными в ВМ + MSQL, БД Azure SQL, NoSQL решениях через REST API, blob-хранилищах</td>
						</tr>
						<tr>
							<td>Бизнес-аналитика</td>
							<td>предоставляет службы SQL Server Reporting and Analysis, SharePoint Serve, Azure SQL Reporting, Azure Marketplace и
								HDInsight
							</td>
						</tr>
						<tr>
							<td>HDInsight</td>
							<td>специальная надстройка, позволяющая запускать Apache Hadoop в облаке Azure</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<h2>Службы обработки данных</h2>
				<table>
					<tbody>
						<tr>
							<td>Кэш</td>
							<td>распределенные решение для кэширования, ускоряющее работу облачных приложений и снижающее нагрузку на БД
							</td>
						</tr>
						<tr>
							<td>Резервное копирование</td>
							<td>средства автономной защититы данных на сервере, позволяют создавать как автоматические, так и ручные копии</td>
						</tr>
						<tr>
							<td>Диспетчер восстановления</td>
							<td>защита критически важных для бизнеса данных, приложений и служб в платформе виртуализации Hyper-V. Координация репликаций
								и восстановление частных облаков
							</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<section>
					<h2>Службы приложений (часть 1)</h2>
					<table>
						<tbody>
							<tr>
								<td>Мультимедийные службы</td>
								<td>формируют процессы для создания, управления и распространения медиаконтента</td>
							</tr>
							<tr>
								<td>Обмен сообщениями</td>
								<td>шина обслуживания и очередь обеспечивают связь приложений в частном и/или общедоступном облаке</td>
							</tr>
							<tr>
								<td>Узлы уведомлений</td>
								<td>хорошо масштабируемая кросс-платформенная инфраструктура push-уведомлений для приложений, работающих на мобильных
									устройствах
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h2>Службы приложений (часть 2)</h2>
					<table>
						<tbody>
							<tr>
								<td>Службы BizTalk</td>
								<td>функции B2B (Business-to-Business) и EAI (Enterprise Application Integration) для облачных и гибридных решений по
									интеграции
								</td>
							</tr>
							<tr>
								<td>Active Directory</td>
								<td>отвечает за управление идентификацией и контроль доступа для облачных приложений</td>
							</tr>
							<tr>
								<td>Многофакторная аутентификация</td>
								<td>дополнительный уровень аутентификации наряду с учетными данными пользователей, повышая защищенность доступа к локальным
									и облачным приложениям
								</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<h2>Общая схема</h2>
				<img src="img/service-scheme.png" alt="" height="550">
			</section>
			<section>
				<h2 class="header-hide">Копнем поглубже</h2>
				<img src="img/копнуть.jpeg" alt="" height="600">
			</section>
			<section>
				<h1>Подробнее о вычислительных службах</h1>
			</section>
			<section>
				<h1>Веб-сайты</h1>
			</section>
			<section>
				<section>
					<h2>Определение</h2>
					<blockquote>
						Веб-сайты Windows Azure — это масштабируемая, безопасная и гибкая плат- форма, на основе которой можно создавать веб-приложения
						для бизнеса, рас- ширять охват бренда и привлекать новых клиентов
					</blockquote>
					<blockquote>
						В зависимости от выбранной ценовой категории вычислительные ресурсы могут находиться на общих или выделенных виртуальных
						машинах. Код приложения выполняется на управляемой виртуальной машине, которая изолирована от других клиентов
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>портал самообслуживания с галереей наиболее популярных веб-решений</li>
						<li>интсрумент WebMatrix</li>
						<li>интсрумент публикации приложений</li>
						<li>Azure SDK для Visual Studio</li>
						<li>утилиты для создания, конфигурирования и управления БД</li>
						<li>интеграция с системами контроля версий: TFS, GitHub, Bitbucket и т.д.</li>
						<li>инструмент мониторинга нагрузки и состояния ресурсов веб-приложения</li>
						<li>утилиты диагностики и тесторования</li>
						<li>конфигурация SSL-стерификатоф</li>
						<li>конфигурация версии платформы (.NET, PHP, Java и т.д.)</li>
					</ul>
				</section>
				<section>
					<h3>Примущество использования в облаке</h3>
					<ul>
						<li>Поддержка нескольких языков и платформ (ASP.NET, Node.js, Java, Python, PowerShell)</li>
						<li>Оптимизация DevOps - непрерывная интеграция и развертывание (Team Services, BitBucket, тестирование A/B)</li>
						<li>Автомасштабирование</li>
						<li>Подключение к платформам SaaS и локальным данным. Более 50 соединителей для корпоративных систем (SAP, Oracle), служб
							SaaS (Salesforce, Office 365) и популярных интернет-служб (Facebook, Twitter)</li>
						<li>Шаблоны приложений - быстрое развертывание ПО с открытым исходным кодом (Joomla, Drupal) с помощью мастера</li>
						<li>Интеграция с Visual Studio и другими IDE</li>
						<li>Дополнительные функции (CORS) и интеграция с мобильными приложениями (push-уведомления)</li>
					</ul>
				</section>
				<section>
					<h3>Режимы работы веб-сайтов</h3>
					<ul>
						<li>Бесплатный - мультиарендная архитектура, каждому сайту выделена квота на ресурсы процессора, памяти и сети. Количество
							сайтов зависит от тарифного плана, SLA отсутствует</li>
						<li>Стандартный - можно выбрать сайты, которые будут работать на специально выделенной виртуальной машине (могут размещаться
							до 500 веб-сайтов)
						</li>
						<li>Распределенный - гарантируется SLA более низкого уровня по сравнению со стандартным режимом</li>
					</ul>
				</section>
				<section>
					<h3>Доступность серверов</h3>
					<ul>
						<li>Малый сервер (1 ядро, 1,75 ГБ оперативной памяти)</li>
						<li>Средний сервер (2 ядра, 3,5 ГБ оперативной памяти)</li>
						<li>Большой сервер (4 ядра, 7 ГБ оперативной памяти)</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Атомасштабирование</h2>
				<img src="img/auto_scale.jpg" alt="" height="550">
			</section>
			<section>
				<section>
					<h2>Agile разработка</h2>
					<ul>
						<li>Автоматическая сборка после каждой фиксации</li>
						<li>Самопроверка сборок</li>
						<li>Выполнение тестов в клоне рабочей среды</li>
						<li>Удобный просмотр результата последней сборки</li>
						<li>Ежедневная фиксация в главной ветви</li>
						<li>Автоматическое развертывание</li>
					</ul>
				</section>
				<section>
					<h3>Источники данных для непрырывного развертывания</h3>
					<ul>
						<li>VS Team Services</li>
						<li>OneDrive</li>
						<li>Локальный репозиторий Git</li>
						<li>Github</li>
						<li>Bitbacket</li>
						<li>Внешний репозиторий Git</li>
						<li>SVN</li>
						<li>Dropbox</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример развертывание веб-приложения</h2>
				</section>
				<section>
					<h3>Переход из dashbord'a</h3>
					<img src="img/службы_приложений.png" alt="">
				</section>
				<section>
					<h3>Панель управления веб-сайтами</h3>
					<img src="img/службы_приложений_1.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_2.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_3.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_4.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_5.png" alt="">
				</section>
				<section>
					<h3>Выбор приложения</h3>
					<img src="img/службы_приложений_6.png" alt="">
				</section>
				<section>
					<h3>Создание приложения</h3>
					<img src="img/службы_приложений_7.png" alt="">
				</section>
				<section>
					<h3>Параметры приложения</h3>
					<img src="img/службы_приложений_8.png" alt="">
				</section>
				<section>
					<h3>Процесс развертывания</h3>
					<img src="img/службы_приложений_9.png" alt="">
				</section>
				<section>
					<h3>Обзор приложения</h3>
					<img src="img/службы_приложений_10.png" alt="">
				</section>
				<section>
					<h3>Быстрый старт</h3>
					<img src="img/службы_приложений_18.png" alt="">
				</section>
				<section>
					<h3>Интеграция</h3>
					<img src="img/службы_приложений_11.png" alt="">
				</section>
				<section>
					<h3>Выбор репозитория</h3>
					<img src="img/службы_приложений_12.png" alt="">
				</section>
				<section>
					<h3>Выбор ветки</h3>
					<img src="img/службы_приложений_13.png" alt="">
				</section>
				<section>
					<h3>Результат интеграции</h3>
					<img src="img/службы_приложений_14.png" alt="">
				</section>
				<section>
					<h3>Результат интеграции</h3>
					<img src="img/службы_приложений_16.png" alt="">
				</section>
				<section>
					<h3>Мониторинг посещений</h3>
					<img src="img/службы_приложений_17.png" alt="">
				</section>
				<section>
					<h3>Резервирование</h3>
					<img src="img/службы_приложений_19.png" alt="">
				</section>
				<section>
					<h3>Консоль</h3>
					<img src="img/службы_приложений_20.png" alt="">
				</section>
			</section>
			<section>
				<h2>Балансировка нагрузки</h2>
				<p>https://docs.microsoft.com/ru-ru/azure/application-gateway/application-gateway-introduction</p>
			</section>
			<section>
				<h1>Виртуальные машины</h1>
			</section>
			<section>
				<section>
					<h2>Определение</h2>
					<blockquote>
						Виртуальные машины Windows Azure — это масштабируемая IaaS-платформа по запросу, позволяющая быстро подготавливать и развертывать
						в облаке серверные задачи
					</blockquote>
				</section>
				<section>
					<h3>Примеры использования</h3>
					<ul>
						<li>Разработка и тестирование. ВМ обеспечивают быстрый и простой способ создания компьютера с определенными конфигурациями,
							необходимыми для написания кода и тестирования приложения</li>
						<li>Приложения в облаке. Используя ВМ в качестве контейнера для приложения позваоляет гибко управлять ресурсами ВМ и прилодения,
							платить за дополнительные ВМ, если они нужны, и отключать их, если они не нужны</li>
						<li>Расширенный центр обработки данных. ВМ в виртуальной сети Azure можно легко подключить к корпоративной сети
						</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Механизмы настройки, контроля и отслеживания</li>
						<li>Балансировщик нагрузки</li>
						<li>Интсрумент подключения к другим облачным службам Azure, на которых работают веб-роли и рабочие роли</li>
						<li>Механизм копирования виртуальных жестких дисков (Virtual Hard Disk, VHD) из локальной среды в Azure и на их основе
							создать новые виртуальные машины</li>
						<li>Механизм выгрузки VHD из Azure и возможность запуска локально</li>
						<li>Новые ВМ можно создавать из стандартных образов, доступ-ных в галерее Azure (актуальные версии Windows Server, различные
							сборки Linux, Microsoft SharePoint, Microsoft SQL Server, Microsoft BizTalk Server и т.д.)</li>
						<li>Можно использовать для развертывания собственные сборки, которые были созданы локально</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Удаленное управление ВМ Windows по протоколу RDP</li>
						<li>Управление средствами Windows PowerShell</li>
						<li>ВМ Linux поддерживают удаленное управление по SSH</li>
						<li>Механизм создания и подключения к дисков для хранения информации приложений</li>
						<li>Автомасштабирования ресурсов (дополнительное количество ядер процессора, объем ОП)</li>
						<li>Автоматическое сохрахранение и самостоятельное восстанавление после аппаратных сбоев</li>
						<li>Автоматическое сохранение информации на подключенных дисках, они резервированы BLOB-объектами хранилища Windows Azure.
							Экземпляры веб-ролей и рабочих ролей самовосстанавливаются, но не сохраняются</li>
						<li>Использование ВМ тарифицируется по часам</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Способы создания ВМ</h2>
				<ul>
					<li>Портал Azure - создание ВМ через UI портала</li>
					<li>Шаблоны - создание ВМ с использованием шаблона диспетчера ресурсов</li>
					<li>Azure PowerShell - создание ВМ с помощью PowerShell</li>
					<li>Клиентские пакеты SDK - Развертывание ресурсов Azure с помощью языка C#</li>
					<li>Интерфейсы API REST - создание или обновление ВМ через HTTP</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Типы ВМ </h2>
				</section>
				<section>
					<h3>Серия А</h3>
					<blockquote>
						ВМ начального уровня. Идеально подходят для разработки и тестирования систем, потребляющих небольшое количество трафика,
						БД и интеграцию приложений с внешними репозиториями
					</blockquote>
					<img src="img/a_seria.png" alt="">
				</section>
				<section>
					<h3>Серия D</h3>
					<blockquote>
						ВМ общего назначения. Обладают производительным процессором, большим объемом оперативной памяти, опциональко устанавливаемым
						SSD. Используются в приложениях совместно с реляционными БД, кэшированием и аналитики
					</blockquote>
					<img src="img/d_seria_1.png" alt="">
				</section>
				<section>
					<h3>Серия D (продолжение)</h3>
					<img src="img/d_seria_2.png" alt="">
					<img src="img/d_seria_v2.png" alt="">
				</section>
				<section>
					<h3>Серия F</h3>
					<blockquote>
						ВМ для сложных пользовательских приложений. На одно ядро выделяется более 2 GB RAN и 16 GB SSD. Используются процессоры серии
						Xenon E5 или Broadwell c частотой до 3.1 GHz и технологией Turbo Boost. Идеально подходит для сложной аналитики, веб
						и игровых сервисов
					</blockquote>
				</section>
				<section>
					<h3>Серия G</h3>
					<blockquote>
						ВМ для сложных пользовательских приложений. Отличается от класса F большим объемом оперативной памяти, количеством ядер процессора
						(до 32 CPU). Для кеширования ОП используются SSD. Приложения способны взаимодействовать с большими SQL и NoSQL хранилищами,
						интегрироваться с SAP и другими решениями
					</blockquote>
					<img src="img/g_seria.png" alt="">
				</section>
				<section>
					<h3>Серия H</h3>
					<blockquote>
						Высокопроизводительные ВМ. Используются 8- или 16-ядерные процессоры Xenon последнего поколения, память стандарта DDR4. Для
						хранения данных и кеширования используются SSD. Для органищации RDMA используется сеть Infiniband. Используеются для
						сложных вычислений в режиме realtime, пакетной обработки, анализа, моделирования
					</blockquote>
					<img src="img/h_seria.png" alt="" height="300">
				</section>
				<section>
					<h3>Серия N</h3>
					<blockquote>
						ВМ с широкой поддержкой GPU. Используется платформа NVIDIA Tesla и технологии NVIDIA Grid. Отлично подходят для рендерина
						графики и видео, удаленной виртуализации, высокопроизводительных вычислений и майнинга, аналитики
					</blockquote>
				</section>
			</section>
			<section>
				<section>
					<h2>Расширения и компоненты ВМ</h2>
				</section>
				<section>
					<h2>Расширения ВМ Azure</h2>
					<blockquote>
						Небольшие приложения, выполняющие настройку и автоматизацию после развертывания на виртуальных машинах Azure
					</blockquote>
					<ul>
						<li>Изменение функций безопасности и идентификации, в том числе сброс значений учетных записей и использование защиты от
							вредоносных программ
						</li>
						<li>Запуск, остановка и настройка функций мониторинга и диагностики</li>
						<li>Сброс или установка функций подключения (RDP, SSH)</li>
						<li>Диагностика, мониторинг и управление ВМ</li>
						<li>Расширения можно запускать с помощью интерфейса командной строки, PowerShell, шаблонов Resource Manager и UI портала
						</li>
					</ul>
				</section>
				<section>
					<h3>Агент виртуальной машины Azure</h3>
					<blockquote>
						Защищенный и нетребовательный к ресурсам процесс, который устанавливает, настраивает и удаляет расширения ВМ на экземплярах
						виртуальных машин Azure из коллекции образов и на пользовательских экземплярах виртуальных машин при наличии установленного
						агента ВМ
					</blockquote>
					<ul>
						<li>Два вида агента: для Windows и Linux</li>
						<li>Устанавливается автоматически при создании виртуальной машины из коллекции образов</li>
						<li>Возможность конфигурирования для собственных образов ВМ</li>
					</ul>
				</section>
				<section>
					<h3>Примеры расширений</h3>
					<table>
						<tr>
							<td>Расширение Custom Script в ОС Windows</td>
							<td>Выполняет скрипты на виртуальной машине Azure</td>
						</tr>
						<tr>
							<td>Расширение DSC в ОС Windows</td>
							<td>Расширение PowerShell DSC (настройка требуемого состояния) для Docker</td>
						</tr>
						<tr>
							<td>Расширение системы диагностики</td>
							<td>Управляет системой диагностики Azure</td>
						</tr>
					</table>
				</section>
			</section>
			<section>
				<h2>Таблица связанных ресурсов</h2>
				<small>
				<table>
					<thead>
						<tr>
							<th>Ресурс</th>
							<th>Обязательно</th>
							<th>Описание</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Группа ресурсов</td>
							<td>+</td>
							<td>ВМ должна входить в группу ресурсов</td>
						</tr>
						<tr>
							<td>Учетная запись хранения</td>
							<td>+</td>
							<td>ВМ требуется учетная запись хранения для хранения виртуальных жестких дисков</td>
						</tr>
						<tr>
							<td>Виртуальная сеть</td>
							<td>+</td>
							<td>ВМ должна быть подключена к виртуальной сети</td>
						</tr>
						<tr>
							<td>Общедоступный IP-адрес</td>
							<td>-</td>
							<td>Для удаленного доступа к ВМ можно назначить общедоступный IP-адрес</td>
						</tr>
						<tr>
							<td>Сетевой интерфейс</td>
							<td>+</td>
							<td>Для обмена данными в сети нужен сетевой интерфейс</td>
						</tr>
						<tr>
							<td>Диски данных</td>
							<td>-</td>
							<td>ВМ может содержать диски данных для расширения объема ресурсов хранения</td>
						</tr>
					</tbody>
				</table>
				</small>
			</section>
			<section>
				<section>
					<h2>Контейнеры</h2>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Различные способы создания узлов в соответствии с конкретной ситуацией</li>
						<li>Создание контейнеров с помощью таких оркестраторов, как Marathon или Swarm</li>
						<li>Resource Manager и шаблоны ресурсов для упрощения развертывание и обновление распределенных приложений</li>
						<li>Интеграция с большим массивом инструментов управления конфигурациями</li>
						<li>Автоматическое создание образов с использованием dockerfile и простых команд</li>
						<li>Используются системы контроля версий в качестве источников приложений контейнера</li>
						<li>Могут использовать изолированные компоненты приложений вместо компьютеров</li>
					</ul>
				</section>
				<section>
					<h3>Разница между ВМ и контейнерами</h3>
					<ul>
						<li>Контейнеры не требуют и не используют гипервизор для изоляции</li>
						<li>Контейнеры использует изоляцию процессов и файловой системы в ядре Linux для получения контейнером доступа только к
							определенным компонентам ядра и собственной изолированной файловой системе
						</li>
						<li>Контейнер является экземпляром уникальной ОС (с точки зрения приложения)</li>
						<li>Приложения в контейнере не могут видеть процессы или другие ресурсы за пределами своего контейнера</li>
						<li>Время запуска контейнера и дополнительные затраты на дисковое пространство для хранения гораздо ниже</li>
						<li>Контейнеры Windows поддерживают формат образов Docker и API Docker, но ими можно также управлять с помощью PowerShell</li>
					</ul>
				</section>
				<section>
					<h3>Сравнение основных функций ВМ и контейнеров</h3>
					<table>
						<thead>
							<tr>
								<th>Функция</th>
								<th>Виртуальные машины</th>
								<th>Контейнеры</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Безопасность</td>
								<td>В большей степени</td>
								<td>В меньшей степени</td>
							</tr>
							<tr>
								<td>Память на диске</td>
								<td>Полная версия ОС и приложения</td>
								<td>Только требования приложений</td>
							</tr>
							<tr>
								<td>Время для запуска</td>
								<td>Загрузка ОС и приложений</td>
								<td>Только запуск приложений, ядро уже работает</td>
							</tr>
							<tr>
								<td>Переносимость</td>
								<td>Много вариантов</td>
								<td>Переносимость в формате образа (хуже)</td>
							</tr>
							<tr>
								<td>Автоматизация образов</td>
								<td>Зависит от ОС и приложений</td>
								<td>Docker и т.д.</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Основные компоненты</h2>
					<uL>
						<li>Fabric - интерфей - обеспечивает средства управления облачной платформой</li>
						<li>Compute - вычисления, обрабатывает пользовательские данные</li>
						<li>Storage - память, сервис хранения пользовательских данных</li>
						<li>Config - конфигурация</li>
						<li></li>
					</uL>
					<blockquote>
						Все компоненты являются сервисами .NET
					</blockquote>
				</section>
				<section>
					<h3>Сервис Compute</h3>
					<ul>
						<li>Решает задачи совместного выполнения огромного числа пользовательских приложений</li>
						<li>Может выполнять каждый экземпляр приложения на отдельной виртуальной машине </li>
						<li>Основная проблема - масштабирование</li>
						<li></li>
						<li></li>
						<li></li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Облачные службы</h2>
				</section>
				<section>
					<h3>Определение от Microsoft</h3>
					<blockquote>
						С помощью облачных служб Windows Azure можно быстро создавать, развер- тывать многоуровневые приложения в облаке и управлять
						ими. Используя облачные службы, вы можете сконцентрироваться на разработке, тестировании, развертывании и управлении
						приложением, а не тратить время на обслуживание нижележащей инфраструктуры
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>назначение нескольких ролей приложению при распределенной обработке либо гибком масштабировании его ресурсов</li>
						<li>приложения облачных служб можно создать практически на любой популярной платформе разработки (.NET, Node.js, PHP, Java,
							Python и Ruby)</li>
						<li>возможность интегрировать мобильные службы Windows Azure и мультимедийные службы в приложения</li>
						<li>удобные механизмы отслеживания работоспособности и доступности приложений в облачных службах</li>
						<li>механизм оповещения в реальном времени о сбоях в работе служб или снижении их производительности</li>
						<li>автомасштабирования - приложение автоматически получает или отдает ресурсы по мере необходимости</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Сетевые службы Windows Azure</h2>
				</section>
				<section>
				</section>
			</section>
			<section>
				<h1>Microsoft Message Queue</h1>
			</section>
			<section>
				<h1>Azure Service Bus</h1>
			</section>


			<!-- Application Insights -->
			<section>
				<h1>Application Insights</h1>
			</section>
			<section>
				<h2>Определение от Microsoft</h2>
				<blockquote>
					Application Insights позволяет осуществлять мониторинг доступности, производительности и использования вашего веб-приложения.
					Благодаря получаемым данным о производительности и эффективности работы приложения на практике вы можете принимать осознанные
					решения о направлении разработки в каждом жизненном цикле.
				</blockquote>
			</section>
			<section>
				<h2>Типы данных</h2>
				<ul>
					<li>Частота HTTP-запросов, время ответа, частота успешных выполнений</li>
					<li>Частота вызовов зависимостей (HTTP и SQL), время ответа, частота успешных выполнений</li>
					<li>Трассировки исключений из сервера и клиента</li>
					<li>Трассировки журналов диагностики</li>
					<li>Количество просмотров страниц, количество пользователей и сеансов, время загрузки браузера, исключения</li>
					<li>Счетчики производительности сервера</li>
					<li>Пользовательская телеметрия клиента и сервера</li>
					<li>Cегментация с учетом расположения клиента, версии браузера, версии ОС, экземпляра сервера, пользовательских измерений
						и многого другого</li>
					<li>Тесты доступности</li>
				</ul>
			</section>
			<section>
				<h4>Средства диагностики и анализа</h4>
				<ul>
					<li>Интеллектуальные и настраиваемые вручную оповещения о частоте сбоев, доступности и других показателях</li>
					<li>Диаграммы сводных показателей за определенный период времени</li>
					<li>Поиск экземпляров запросов, исключений, пользовательских событий, трассировок журналов, количества просмотров страниц,
						зависимостей и вызовов AJAX по журналам диагностики</li>
					<li>Аналитика — эффективный язык запросов для телеметрии</li>
					<li>Панели мониторинга — на них формируются диаграммы, необходимые для отслеживания компонентов приложения</li>
				</ul>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/insight_схема.png" alt="">
			</section>
			<section>
				<section>
					<h2>Аналитические средства для разработчиков</h2>
				</section>
				<section>
					<h3>Языки</h3>
					<ul>
						<li>.NET</li>
						<li>Java</li>
						<li>JavaScript</li>
						<li>Objective-C</li>
						<li>PHP</li>
						<li>Python</li>
						<li>Ruby</li>
						<li>Другие</li>
					</ul>
				</section>
				<section>
					<h3>Платформы и среды</h3>
					<ul>
						<li>Angular</li>
						<li>ASP.NET</li>
						<li>Android </li>
						<li>Docker</li>
						<li>iOS</li>
						<li>J2EE</li>
						<li>Приложение Mac OS X </li>
						<li>Node.JS</li>
						<li>UWP</li>
						<li>Другие</li>
					</ul>
				</section>
				<section>
					<h3>Платформы ведения журналов</h3>
					<ul>
						<li>Log4Net, NLog</li>
						<li>Java, Log4J или Logback</li>
						<li>Semantic Logging (SLAB)</li>
						<li>Облачное нагрузочное тестирование</li>
						<li>Подключаемый модуль LogStash</li>
					</ul>
				</section>
				<section>
					<h3>Системы управления содержимым</h3>
					<ul>
						<li>Concrete</li>
						<li>Drupal</li>
						<li>Joomla</li>
						<li>Orchard</li>
						<li>SharePoint</li>
						<li>WordPress</li>
					</ul>
				</section>
				<section>
					<h3>Экспорт и анализ данных</h3>
					<ul>
						<li>Alooma</li>
						<li>Power</li>
						<li>BI</li>
					</ul>
				</section>
				<section>
					<h3>Создание собственного пакета SDK</h3>
					<blockquote>
						Если для языка или платформы не существует пакета SDK, можно легко создать его
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Оповещения</h2>
				<ul>
					<li>Автоматическое получение оповещения превентивной диагностики, которые сообщают о необычных изменениях в частоте сбоев
						и других метриках</li>
					<li>Тесты доступности для постоянного тестирования веб-сайта из расположений по всему миру и немедленного получения сообщений
						электронной почты в случае сбоя проверки</li>
					<li>Настройте оповещения о метриках, чтобы получать оповещение о выходе метрик, таких как время отклика или доля исключений,
						за допустимые границы</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Фильтрация и предварительная обработка</h2>
					<ul>
						<li>Выборка сокращает объем данных телеметрии, не искажая статистические данные. Благодаря выборке связанные точки данных
							хранятся вместе, что облегчает навигацию между ними во время диагностики проблемы. На портале общее количество умножается,
							чтобы компенсировать выборку</li>
						<li>Фильтрация позволяет выбирать или изменять данные телеметрии в пакете SDK перед отправкой на сервер. Например, можно
							исключить запросы от роботов. При помощи фильтрации сократить трафик проще, чем при помощи выборки</li>
						<li>Инициализаторы телеметрии добавляют свойства к любым данным телеметрии, включая данные из стандартных модулей</li>
						<li>API пакета SDK используется для отправки пользовательских событий и показателей</li>
					</ul>
				</section>
				<section>
					<h3>Интерфейс ITelemetryProcessor</h3>
					<pre>
					<code class="hljs">
public interface ITelemetryProcessor
{
    void Process(ITelemetry item);
}
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim>
public class SuccessfulDependencyFilter : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }
    public SuccessfulDependencyFilter(ITelemetryProcessor next)
    {
        this.Next = next;
    }
    public void Process(ITelemetry item)
    {
        if (!OKtoSend(item)) { return; }
        ModifyItem(item);

        this.Next.Process(item);
    }
    private bool OKtoSend(ITelemetry item)
    {
        var dependency = item as DependencyTelemetry;
        if (dependency == null) return true;

        return dependency.Success != true;
    }
    private void ModifyItem(ITelemetry item)
    {
        item.Context.Properties.Add("app-time", DateTime.Now.ToLongTimeString());
    }
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Настройка App Insights</h2>
				</section>
				<section>
					<h3>Добавление новой службы</h3>
					<img src="img/IN_1.png" alt="">
				</section>
				<section>
					<h3>Настройка параметров</h3>
					<img src="img/IN_2.png" alt="">
				</section>
				<section>
					<h3>Результат настройки</h3>
					<img src="img/IN_3.png" alt="">
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/IN_4.png" alt="">
				</section>
			</section>
			<section>
				<h2>Интерфейс ITelemetry</h2>
				<pre>
						<code class="hljs">
public interface ITelemetry
{
    //  Контекст связанный с текущей телеметрией
    TelemetryContext Context { get; }

    // Отслеживания абсолютного порядка телеметрий. Состоит из двух частей: 
    // постоянный идентификатор для текущего сеанса 
    // и идентификатор для каждого события добавляется в очередь (инкрементален)
    string Sequence { get; set; }

    //  Время записи данных телеметрии
    DateTimeOffset Timestamp { get; set; }

    //  Проверяет наличие потенциально опасных (или не валидных) данных 
    void Sanitize();
}
						</code>
					</pre>
			</section>
			<section>
				<h2>
					Класс TelemetryContext
				</h2>
				<pre>
					<code class="hljs">
public sealed class TelemetryContext
{
    public TelemetryContext();
    public CloudContext Cloud { get; }
    public ComponentContext Component { get; }
    public DeviceContext Device { get; }
    public string InstrumentationKey { get; set; }
    public LocationContext Location { get; }
    public OperationContext Operation { get; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public SessionContext Session { get; }
    public UserContext User { get; }
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Класс TelemetryConfiguration</h2>
				<pre>
					<code class="hljs">
public sealed class TelemetryConfiguration : IDisposable
{
    public TelemetryConfiguration();
    public static TelemetryConfiguration Active { get; }
    public bool DisableTelemetry { get; set; }
    public string InstrumentationKey { get; set; }
    public ITelemetryChannel TelemetryChannel { get; set; }
    public IList&lt;ITelemetryInitializer&gt; TelemetryInitializers { get; }
    public TelemetryProcessorChainBuilder TelemetryProcessorChainBuilder { get; }
    public ReadOnlyCollection&lt;ITelemetryProcessor&gt; TelemetryProcessors { get; }
    public static TelemetryConfiguration CreateDefault();
    public static TelemetryConfiguration CreateFromConfiguration(string config);
    public void Dispose();
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Класс TelemetryClient</h2>
				<pre>
					<code class="hljs" data-trim>
public sealed class TelemetryClient
{
    public TelemetryClient();
    public TelemetryClient(TelemetryConfiguration configuration);
    public TelemetryContext Context { get; }
    public string InstrumentationKey { get; set; }
    public void Flush();
    public void Initialize(ITelemetry telemetry);
    public bool IsEnabled();
    public void Track(ITelemetry telemetry);
    public void TrackAvailability(AvailabilityTelemetry telemetry);
    public void TrackAvailability(string name, DateTimeOffset timeStamp, TimeSpan duration, string runLocation, bool success, string message = null);
    public void TrackEvent(EventTelemetry telemetry);
    public void TrackEvent(string eventName, IDictionary&lt;string, string&gt; properties = null, IDictionary&lt;string, double&gt; metrics = null);
    public void TrackException(ExceptionTelemetry telemetry);
    public void TrackException(Exception exception, IDictionary&lt;string, string&gt; properties = null, IDictionary&lt;string, double&gt; metrics = null);
    public void TrackMetric(MetricTelemetry telemetry);
    public void TrackMetric(string name, double value, IDictionary&lt;string, string&gt; properties = null);
    public void TrackPageView(string name);
    public void TrackPageView(PageViewTelemetry telemetry);
    public void TrackRequest(RequestTelemetry request);
    public void TrackRequest(string name, DateTimeOffset startTime, TimeSpan duration, string responseCode, bool success);
    public void TrackTrace(TraceTelemetry telemetry);
    public void TrackTrace(string message);
    public void TrackTrace(string message, IDictionary&lt;string, string&gt; properties);
    public void TrackTrace(string message, SeverityLevel severityLevel);
    public void TrackTrace(string message, SeverityLevel severityLevel, IDictionary&lt;string, string&gt; properties);
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Основные методы класса TelemetryClient</h2>
				</section>
				<section>
					<h3>Метод TrackTrace</h3>
					<blockquote>
						Используется для диагностики проблемных мест (анализ и диагностический поиск) приложения. Может использловаться как "обертка"
						для системы логирования
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message, IDictionary&lt;string, string&gt; properties);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message, SeverityLevel severityLevel);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(
    string message, 
    SeverityLevel severityLevel, 
    IDictionary&lt;string, string&gt; properties
);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(TraceTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>SeverityLevel</h3>
					<pre>
						<code class="hljs">
public enum SeverityLevel
{
    Verbose = 0,
    Information = 1,
    Warning = 2,
    Error = 3,
    Critical = 4
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс TraceTelemetry</h3>
					<blockquote>
						Используется для логирования данных. Оперирует сообщением, временем активации и дополнительными параметрами
					</blockquote>
					<pre>
						<code class="hljs">
public sealed class TraceTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public TraceTelemetry();
    public TraceTelemetry(string message);
    public TraceTelemetry(string message, SeverityLevel severityLevel);
    public TelemetryContext Context { get; }
    public string Message { get; set; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    public SeverityLevel? SeverityLevel { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackPageView</h3>
					<blockquote>
						логирует название страницы (web, mobile, desktop)-приложения, с которой пользователь работает в данный момент
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackPageView(string name);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackPageView(PageViewTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс PageViewTelemetry</h3>
					<blockquote>
						отслеживание посещаймости страниц пользователями
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public sealed class PageViewTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public PageViewTelemetry();
    public PageViewTelemetry(string pageName);
    public TelemetryContext Context { get; }
    //  Длительность посещения страницы
    public TimeSpan Duration { get; set; }
    //  Пользовательские метрики
    public IDictionary&lt;string, double&gt; Metrics { get; }
	// Имя страницы
    public string Name { get; set; }
    // Словарь для дополнительных параметров
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    // Время, когда событие произошло
    public DateTimeOffset Timestamp { get; set; }
    // URL-страницы
    public Uri Url { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackEvent</h3>
					<blockquote>
						Позволяет логировать вызовы событий в приложении для определения частотности выбора пользователем определенной функции, цели
						и т.д.
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackEvent(EventTelemetry telemetry);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackEvent(
    string eventName, 
    IDictionary&lt;string, string&gt; properties = null, 
    IDictionary&lt;string, double&gt; metrics = null
);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackRequest</h3>
					<blockquote>
						Применяется для логирования или имитации выполнения HTTP-запросов в приложении
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackRequest(RequestTelemetry request);
						</code>
					</pre>
					<pre>
						<code class="hljs">
// name: имя запроса или путь
// startTime: время инициализации запроса
// duration: продолжительность выполнения
// responseCode: status code
// success: True, если обработан успешно
public void TrackRequest(
    string name, 
    DateTimeOffset startTime, 
    TimeSpan duration, 
    string responseCode, 
    bool success
);				
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс RequestTelemetry</h3>
					<blockquote>
						Инкапсулирует информацию о HTTP-запросах в приложении
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public sealed class RequestTelemetry : 
    OperationTelemetry, ITelemetry, ISupportProperties, ISupportSampling
{
    public RequestTelemetry();
    public RequestTelemetry(string name, DateTimeOffset startTime, 
	   TimeSpan duration, string responseCode, bool success);
    public override TelemetryContext Context { get; }
    public override TimeSpan Duration { get; set; }
    public string HttpMethod { get; set; }
    // Идентификатор запроса
    public override string Id { get; set; }
    public IDictionary&lt;string, double&gt; Metrics { get; }
    //  Имя человека, выполнявшего запрос
    public override string Name { get; set; }
    public override IDictionary&lt;string, string&gt; Properties { get; }
    public string ResponseCode { get; set; }
    public override string Sequence { get; set; }
    // Идентифицирует субъект, обычно записывается хеш
    public string Source { get; set; }
    public override bool? Success { get; set; }
    public override DateTimeOffset Timestamp { get; set; }
    public Uri Url { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackMetric</h3>
					<blockquote>
						Используется для отправки метрик, которые не привязаны к конкретным событиям. Метрики отображаются в виде статистических
						графиков, но в отличие от событий, можно выполнить диагностический поиск по отдельным значениям
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackMetric(
    string name, // имя метрики
    double value, // значение метрики
    IDictionary&lt;string, string&gt; properties = null
    // дополнительные свойства для классификации и фильтрации
);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackMetric(MetricTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс MetricTelemetry</h3>
					<blockquote>
						Инкапсулирует логику отслеживания метрик
					</blockquote>
					<pre>
						<code class="hlsj" data-trim>
public sealed class MetricTelemetry : 
    ITelemetry, ISupportProperties
{
    public MetricTelemetry();
    public MetricTelemetry(string metricName, double metricValue);
    public TelemetryContext Context { get; }
    //  количество элементов
    public int? Count { get; set; }
    //  максимальное значение для метрики
    public double? Max { get; set; }
    // минимальное значение для метрики
    public double? Min { get; set; }
    public string Name { get; set; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    //  Стандартное отклонение для значения метрики
    public double? StandardDeviation { get; set; }
    public DateTimeOffset Timestamp { get; set; }
	// Значение метрики
    public double Value { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackException</h3>
					<blockquote>
						Логирует отловленные исключения. Используется для подсчета показателя частоты возникновения проблем. Включает в отчеты результат
						стека вызова функций
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackException(
    Exception exception, 
    IDictionary&lt;string, string&gt; properties = null, 
    IDictionary&lt;string, double&gt; metrics = null
);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackException(ExceptionTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс ExceptionTelemetry</h3>
					<blockquote>
						Инкапсулирует логику логирования искулючительных ситуаций
					</blockquote>
					<pre>
						<code class="hljs">
public sealed class ExceptionTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public ExceptionTelemetry();
    public ExceptionTelemetry(Exception exception);
    public TelemetryContext Context { get; }
    public Exception Exception { get; set; }
	// Информация о месте обработки и отлова исключения
    public ExceptionHandledAt HandledAt { get; set; }
    public string Message { get; set; }
    public IDictionary&lt;string, double&gt; Metrics { get; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    public SeverityLevel? SeverityLevel { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Простой пример</h2>
				</section>
				<section>
					<h3>Nuget-пакет</h3>
					<img src="img/IN_nuget.png" alt="">
				</section>
				<section>
					<h3>Какой-то класс (псевдокод)</h3>
					<pre>
							<code class="hljs" data-trim>
public class ApplicationInsight
{
    private static readonly Lazy&lt;ApplicationInsight&gt; _instance;

    private readonly TelemetryClient _tc;

    private ApplicationInsight()

    public static ApplicationInsight Instance {get;}

    private TelemetryClient InitializeTelemetry(){/**/}

    public void TrackPageView(string name){/**/}

    public void TrackException(Exception ex){/**/}

    public void TrackMetric(string metricName, int value){/**/}

    public void TrackTrace(string eventName, int number){/**/}

    public void Flush(){/**/}
}
							</code>
					</pre>
				</section>
				<section>
					<h3>Singleton</h3>
					<pre>
						<code class="hljs" data-trim>
public class ApplicationInsight
{
    private static readonly Lazy&lt;ApplicationInsight&gt; _instance = 
		new Lazy&lt;ApplicationInsight&gt;(() =&gt; new ApplicationInsight());
    private readonly TelemetryClient _tc;

    private ApplicationInsight()
    {
        _tc = InitializeTelemetry();
    }

    public static ApplicationInsight Instance
    {
        get { return _instance.Value; }
    }
    //.......................	
}					
						</code>
					</pre>
				</section>
				<section>
					<h3>Инициализация параметров</h3>
					<pre>
						<code class="hljs">
private TelemetryClient InitializeTelemetry()
{
    var tc = new TelemetryClient
    {
        InstrumentationKey =
            @"clientNotification-ddadd7d9-4bd5-411a-ab5c-c1fe3322e005;
             a518aea0-2971-4fd4-9c38-595b8ffee7ab;
             a518aea0-2971-4fd4-9c38-595b8ffee7ab"
    };

    tc.Context.User.Id = Environment.UserName;
    tc.Context.Session.Id = Guid.NewGuid().ToString();
    tc.Context.Device.OperatingSystem = Environment.OSVersion.ToString();

    return tc;
}
						</code>						
					</pre>
				</section>
				<section>
					<h3>Пример использования</h3>
					<pre>
						<code class="hljs" data-trim>
static void Main(string[] args)
{
    ApplicationInsight.Instance.TrackPageView("Home");
    ApplicationInsight.Instance.TrackPageView("Account");

    ApplicationInsight.Instance.TrackEvent("Login");
    ApplicationInsight.Instance.TrackException(
		new AuthenticationException("User not found"));

    ApplicationInsight.Instance.TrackEvent("Redirect",
        new Dictionary&lt;string, string&gt;
        {
            { "From", "Account" },
            { "To", "Shop" },
            { "DailyKey" , "DSJU-WERDT-9803"}
        });
	
    ApplicationInsight.Instance.TrackPageView("Shop");
    ApplicationInsight.Instance.TrackTrace("Overtime", 100);
    ApplicationInsight.Instance.TrackMetric("Total count", 32);

    ApplicationInsight.Instance.Flush();
}							
						</code>
					</pre>
				</section>
				<section>
					<h3>Результаты в Azure</h3>
					<img src="img/IN_5.png" alt="">
				</section>
			</section>
			<section>
				<h3>Аналитика</h3>
				<blockquote>
					Аналитика — это мощный инструмент поиска Application Insights. На этих страницах описан язык запросов аналитики приложений.
				</blockquote>
			</section>
			<section>
				<h3>Особенности языка</h3>
				<ul>
					<li>Фильтрация необработанных данных телеметрии приложения по любым полям, включая пользовательские свойства и метрики.</li>
					<li>Соединение нескольких таблиц — соотношение запросов с просмотрами страниц, вызовами зависимостей, исключениями и трассировками
						журнала.
					</li>
					<li>Сложные статистические агрегаты.</li>
					<li>Такие же мощные, как в SQL, но гораздо проще для составления сложных запросов: вместо вложенных инструкций данные передаются
						из одной простой операции в другую.</li>
					<li>Мгновенные яркие визуализации.</li>
					<li>Типичный запрос содержит исходную таблицу и ряд операторов, разделенных |.</li>
				</ul>
			</section>
			<section>
				<section>
					<h3>Поддерживаемые конструкции</h3>
					<ul>
						<li>Let: присвоение имени таблице</li>
						<li>Запросы и операторы: count, evaluate, extend, join, limit, mvexpand, parse, project, project-away, range, reduce, render
							directive, restrict clause, sort, summarize, take, top, top-nested, union, where, where-in</li>
						<li>Статистические функции: any, argmax, argmin, avg, buildschema, count, countif, dcount, dcountif, makelist, makeset,
							max, min, percentile, percentiles, percentilesw, percentilew, stdev, sum, variance</li>
						<li>Скаляры: логические литералы, логические операторы, приведения, скалярные сравнения, gettype, hash, iff, isnotnull,
							isnull, notnull, toscalar</li>
						<li>Числа: арифметические операторы, числовые литералы, abs, bin, exp, floor, gamma, log, rand, sqrt, todouble, toint,
							tolong
						</li>
					</ul>
				</section>
				<section>
					<h3>Поддерживаемые конструкции</h3>
					<ul>
						<li>Дата и время: выражения даты и времени, литералы даты и времени, ago, datepart, dayofmonth, dayofweek, dayofyear, endofday,
							endofmonth, endofweek, endofyear, getmonth, getyear, now, startofday, startofmonth, startofweek, startofyear, todatetime,
							totimespan, weekofyear</li>
						<li>Строка: GUID, маскируемые строковые литералы, cтроковые литералы, cравнение строк, countof, extract, isempty, isnot,
							empty, empty, notempty, parseurl, replace, split, strcat, strlen, substring, tolower, toupper</li>
						<li>Массивы, объекты и динамические типы: литералы массива и объекта, функции динамического объекта, динамические объекты,
							выражения пути JSON, arraylength, extractjson, parsejson, range, todynamic, treepath</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Основные операторы запроса</h3>
				<ul>
					<li>take - отображение n строк</li>
					<li>top - выборка n строк</li>
					<li>sort - сортировка для всей таблицы</li>
					<li>project - выбор, переименование и вычисление столбцов</li>
					<li>extend - вычисление столбцов</li>
					<li>summarize - агрегирование групп строк</li>
					<li>where - фильтрация по условию</li>
					<li>join - доступ к нескольким таблицам, включая запросы и исключения</li>
					<li>let - присвоение результата переменной</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Примеры запросов</h2>
				</section>
				<section>
					<h3>Пример 1</h3>
					<pre>
						<code class="hljs">
requests | top 10 by timestamp desc 

requests | sort by timestamp desc | take 10
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 2</h3>
					<pre>
						<code class="hljs">					
requests | top 10 by timestamp desc
         | project timestamp, name, resultCode
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 3</h3>
					<pre>
						<code class="hljs">
requests 
      | top 10 by timestamp desc 
      | project  
            name, 
            response = resultCode,
            timestamp, 
            ['time of day'] = floor(timestamp % 1d, 1s)
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 4</h3>
					<pre>
						<code class="hljs">
exceptions 
      | where device_Id == "browser" 
      | summarize count() 
	    by device_BrowserVersion, outerExceptionMessage 
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 5</h3>
					<pre>
						<code class="hljs">				
dependencies
    | where timestamp > ago(1d) and  client_Type == "Browser"
    | join (browserTimings | where timestamp > ago(1d))
      on operation_Id
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 6</h3>
					<pre>
					<code class="hljs">
requests 
    | where timestamp > ago(7d) and client_City == "Hyderabad"
    | summarize clients = dcount(client_IP) 
      by tod_UTC=bin(timestamp % 1d, 1h), resultCode
    | extend local_hour = (tod_UTC + 5h + 30min) % 24h + datetime("2001-01-01") 
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример 7</h3>
					<img src="img/insight_analytics.png" alt="">
				</section>
			</section>
			<section>
				<h2>Схема работы пользователя</h2>
				<img src="img/scheme-1.png" alt="">
			</section>
			<section>
				<img src="img/azure-main.png" alt="">
			</section>
			<section>
				<h1>Service Bus</h1>
			</section>
			<section>
				<h2>Сервисная шина предприятия</h2>
				<blockquote>
					Сервисная шина предприятия (enterprise service bus) — связующее программное обеспечение, обеспечивающее централизованный
					и унифицированный событийно-ориентированный обмен сообщениями между различными информационными системами на принципах
					сервис-ориентированной архитектуры
				</blockquote>
			</section>
			<section>
				<h2>Назначение</h2>
				<ul>
					<li>Концентрация обмена сообщениями между различными системами через единую точку</li>
					<li>Обеспечивается транзакционный контроль</li>
					<li>Единым механизм преобразование данных </li>
					<li>Единый механиз обеспечения сохранности сообщений</li>
				</ul>
			</section>
			<section>
				<h2>Основные характеристики</h2>
				<ul>
					<li>Поддержка синхронного и асинхронного способа вызова служб</li>
					<li>Использование защищенного транспорта, с гарантированной доставкой сообщений, поддерживающего транзакции</li>
					<li>Статическая и алгоритмическая маршрутизация сообщений</li>
					<li>Доступ к данным из сторонних информационных систем с помощью специально разработанных адаптеров</li>
					<li>Обработка и преобразование сообщений</li>
					<li>Оркестровка служб (описывает как сервисы должны взаимодействовать между собой, используя для этого обмен сообщениями,
						включая бизнес-логику и последовательность действий)</li>
					<li>Разнообразные механизмы контроля и управления (аудиты, протоколирование)</li>
				</ul>
			</section>
			<section>
				<h2>Способы работы</h2>
				<ul>
					<li>Синхронный - потребитель использует один поток для вызова службы; поток передает запрос, блокируется на время выполнения
						службы и ждет ответ. Если у потребителя возникает аварийная ситуация во время блокирования при работе службы, нельзя
						повторно подключиться к этой службе после перезапуска, поэтому ответ теряется</li>
					<li>Асинхронный - потребитель использует два потока для вызова службы; один - для передачи запроса, второй – для приема
						ответ. Если у потребителя возникает аварийная ситуация во время ожидания ответа на запрос, после перезапуска потребитель
						может продолжать ожидать ответ, ответ не теряется</li>
				</ul>
			</section>
			<section>
				<h3>Примеры программных продуктов</h3>
				<ul>
					<li>Active Directory</li>
					<li>UDDI</li>
					<li>BizTalk Server</li>
					<li>MSMQ</li>
					<li>WCF</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Пример схем использований</h2>
				</section>
				<section>
					<h3>Схема канала точка-точка</h3>
					<img src="img/точка_точка.png" alt="">
				</section>
				<section>
					<h3>Схема канала публикация-подписка</h3>
					<img src="img/публикация_подписка.png" alt="">
				</section>
				<section>
					<h3>Схема канала недоставленных сообщений</h3>
					<img src="img/недоставленное_сообщение.png" alt="">
				</section>
				<section>
					<h3>Схема гарантированной доставки</h3>
					<img src="img/гарантированная_доставка.png" alt="">
				</section>
				<section>
					<h3>Схема шины сообщений</h3>
					<img src="img/шина_сообщений.png" alt="">
				</section>
			</section>
			<section>
				<!-- https://msdn.microsoft.com/ru-ru/library/ee872418.aspx -->
				<h3>Пример схемы функционирования ПО</h3>
				<img src="img/servicebus_scheme.jpg" alt="">
			</section>
			<section>
				<h1>Очередь сообщений</h1>
			</section>
			<section>
				<section>
					<h2>Причины использования</h2>
					<ul>
						<li>Слабое связывание — создают неявные интерфейсы обмена данными (приложения независимыми друг от друга)</li>
						<li>Избыточность — позволяют избежать случаев неэкономного использования ресурсов процесса в результате хранения необработанной
							информации
						</li>
						<li>Масштабируемость — позволяют распределить процессы обработки информации. Увеличивается скорость, с которой сообщения
							добавляются в очередь и обрабатываются</li>
						<li>Эластичность — выполняют роль буфера для накопления данных в случае пиковой нагрузки, и не допуская отказа системы</li>
						<li>Отказоустойчивость — позволяют отделить процессы друг от друга. Если процесс, обрабатывающий сообщение, падает, то
							сообщения могут быть добавлены в очередь позднее, когда система восстановится</li>
					</ul>
				</section>
				<section>
					<h3>Причины использования</h3>
					<ul>
						<li>Гарантированная доставка — сообщение будет доставлено и обработано в любом случае</li>
						<li>Гарантированный порядок доставки — гарантии того, что данные будут обрабатываться в определённом порядке (чаще всего
							в том порядке в котором они поступили)</li>
						<li>Буферизация — позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный
							слой
						</li>
						<li>Понимание потоков данных — позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая
							из очередей забивается, какая простаивает и т.д.</li>
						<li>Асинхронная связь — возможность асинхронной обработки данных, которая позволяет поместить сообщение в очередь без обработки,
							позволяя системе обработать сообщение позднее, когда появится возможность
						</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Область применения</h2>
				<ul>
					<li>Обработка данных</li>
					<li>Буферизация потоков данных</li>
					<li>Управление процессами</li>
					<li>Интеграция и взаимодействие систем</li>
				</ul>
			</section>
			<section>
				<h2>Примеры очередей</h2>
				<ul>
					<li>RabbitMQ</li>
					<li>MSMQ</li>
					<li>Amazon SQS</li>
					<li>IronMQ</li>
					<li>StormMQ</li>
					<li>Azure Queues</li>
				</ul>
			</section>
			<!-- -->
			<section>
				<h1>Microsoft Message Queue</h1>
			</section>
			<section>
				<h2>Определение от Microsoft</h2>
				<blockquote>
					Технология предоставляет приложениям, выполняющимся в разное время, возможность обмениваться информацией, не принимая во
					внимание гетерогенность сетей и операционных систем, которые могут быть временно недоступны. MSMQ обеспечивает гарантированную
					доставку сообщений, эффективную маршрутизацию, безопасность и передачу сообщений на основе приоритетов. Служба может
					использоваться в программных решениях, основанных на асинхронном и синхронном способе доставки сообщений
				</blockquote>
			</section>
			<section>
				<h2>История развития</h2>
				<ul>
					<li>Version 1.0 (May 1997). Supports Windows 95, Windows NT 4.0 SP3, Windows 98 and Windows Me.</li>
					<li>Version 2.0, included with Windows 2000. New features include:[4] Support for registering public message queues in Active
						Directory, 128-bit encryption and digital certificate support, full COM support for message properties (achieving functional
						parity with the Win32 API function calls, full DNS path name support, improved performance in multi-threaded applications.</li>
					<li>Version 3.0, included with Windows XP (Professional, not Home Edition) and Windows Server 2003. New features include:[5]
						Internet Messaging (referencing queues via HTTP, SOAP-formatted messages, MSMQ support for Internet Information Services),
						queue aliases, multicasting of messages, and additional support for programmatic maintenance and administration of
						queues and MSMQ itself.</li>
					<li>Version 4.0, part of Windows Vista and Windows Server 2008. New features include:[6] Subqueues,[7] improved support
						for "poison messages" (messages which continually fail to be processed correctly by the receiver), and support for
						transactional receives of messages from a remote queue.</li>
					<li>Version 5.0, part of Windows 7 and Windows Server 2008 R2. New features include:[8] support for Secure Hash Algorithm
						2.0 (SHA2) and all advanced hash algorithms that are supported in Windows 2008 R2; by default, weaker hash algorithms
						are disabled.</li>
					<li>Version 6.0, part of Windows 8 and Windows Server 2012.</li>
					<li>Version 10, part of Windows 8.1 and Windows Server 2012 R2.</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Функциональные возможности</h2>
					<ul>
						<li>Сообщения могут пересылаться в автономной среде. То есть приложению-отправителю и приложению-получателю вовсе не обязательно
							выполняться в одно и то же время.</li>
						<li>В экспресс-режиме сообщения могут пересылаться очень быстро. В экспресс-режиме сообщения просто сохраняются в памяти.</li>
						<li>Для механизма восстановления сообщения могут отправляться с гарантированной доставкой. Такие сообщения сохраняются
							в файлах и доставляются даже в случае перезагрузки сервера.</li>
						<li>Очереди сообщений могут защищаться с применением списков контроля доступа и указания в них, каким пользователям разрешено
							отправлять или получать сообщения из очереди. Кроме того, сообщения могут шифроваться для исключения вероятности их
							прочтения с помощью сетевых анализаторов пакетов, а также снабжаться приоритетами, чтобы те из них, которые имеют
							более высокий приоритет, обрабатывались быстрее.</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>В Message Queuing 3.0 поддерживается возможность отправки многоадресных (multicast) сообщений.</li>
						<li>В Message Queuing 4.0 поддерживается возможность распознавания вредоносных сообщений. Для таких сообщений может быть
							определена специальная очередь.</li>
						<li>В Message Queuing 5.0 поддерживаются более безопасные алгоритмы аутентификации, и может обрабатываться большее количество
							очередей. (В Message Queuing 4.0 при обработке нескольких тысяч очередей начинали возникать проблемы с производительностью.)</li>
						<li>Привязана к ядру операциооеной системы </li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Порты по умолчанию</h2>
				<ul>
					<li>TCP: 1801</li>
					<li>RPC: 135, 2101, 2103, 2105</li>
					<li>UDP: 3527, 1801</li>
				</ul>
			</section>
			<section>
				<h2>Продукты Message Queuing</h2>
				<ul>
					<li>Microsoft Message Queue (MSMQ) Server Core - Основные компоненты сервера очереди сообщений (MSMQ), которые необходимы
						для получения базовой функциональности Message Queuing.</li>
					<li>Active Directory Domain Services Integration - Интеграция MSMQ доменных служб Active Directory. Это средство позволяет
						записывать имена очередей сообщений в Active Directory. С помощью этой опции можно находить очереди в Active Directory
						и защищать их на основе пользователей и групп пользователей Windows.</li>
					<li>MSMQ HTTP Support - Поддержка протокола HTTP MSMQ. Поддержка MSMQ HTTP позволяет отправлять и принимать сообщения, используя
						протокол HTTP.</li>
					<li>Triggers - помощью триггеров создаются экземпляры приложений при поступлении нового сообщения.</li>
					<li>Multicast Support - Поддержка многоадресной рассылки. Позволяет отправлять сообщения группам серверов.</li>
					<li>MSMQ DCOM Proxy - С помощью DCOM-прокси система может подключаться к удаленному серверу, используя API-интерфейс DCOM.</li>
				</ul>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/MSMQ_8.gif" alt="">
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/MSMQ_7.gif" alt="">
			</section>
			<section>
				<section>
					<h2>Настройка MSMQ</h2>
				</section>
				<section>
					<h2>Включение или отключение компонентов</h2>
					<img src="img/MSMQ_1.png" alt="">
				</section>
				<section>
					<h3>Службы</h3>
					<img src="img/MSMQ_2.png" alt="">
				</section>
				<section>
					<h3>Панель упраления</h3>
					<img src="img/MSMQ_3.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Типы очередей</h2>
					<ul>
						<li>Общедоступная очередь (public) - публикуется в Active Directory. Можно обращаться, не зная имени компьютера, на котором
							она расположена</li>
						<li>Частные очереди (private) - не публикуются в Active Directory. Доступны, только когда известны их полные путевые имена</li>
						<li>Журнальные очереди (journal) - служат для хранения копий сообщений после того, как они были получены или отправлены</li>
						<li>Очереди мертвых писем (dead-letter) - хранят сообщения, если они не появляются на целевой системе по истечении определенного
							периода времени</li>
						<li>Административные очереди - содержат подтверждения об успешно отправленных сообщениях</li>
						<li>Очередь ответов - применяется, когда требуется особый вариант подстверждения о факте отправки со стороны получателя.
							Принимающее приложение может посылать ответные сообщения обратно исходному отправителю</li>
						<li>Очередь отчетов - используется для тестовых сообщений (тестирование и отслеживание маршрутов)</li>
						<li>Системные очереди - являются частными и используются самой системой MQ для административных сообщений, хранения уведомлений
							и обеспечения правильного порядка доставки транзакционных сообщений</li>
					</ul>
				</section>
				<section>
					<h3>Создание очереди</h3>
					<img src="img/MSMQ_5.png" alt="">
				</section>
			</section>
			<section>
				<h2>Структура сообщения</h2>
				<ul>
					<li>Метка — заголовок сообщения</li>
					<li>Тело - пересылаемые данные</li>
					<li>Дополнительная информация - отправитель, конфигурация таймаута, идентификатор транзакции, приоритет</li>
				</ul>
			</section>
			<section>
				<h2>Типы сообщений</h2>
				<ul>
					<li>Нормальное сообщение - отправляется любым приложением</li>
					<li>Подтверждающее сообщение - уведомляет о состоянии нормального сообщения. Подтверждающие сообщения отправляются в административные
						очереди, чтобы уведомить об успехе или сбое при отправке нормальных сообщений</li>
					<li>Ответные сообщения - отправляются принимающим приложением, когда исходный отправитель требует некоторого специального
						ответа
					</li>
					<li>Отчетные сообщения - генерируются системой Message Queuing. К этой категории относятся тестовые сообщения и сообщения
						отслеживания маршрутизации</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Совойства сообщения</h2>
					<ul>
						<li>Label — имя очереди, которое используется для ее поиска</li>
						<li>Type ID - используется для отображения множественных очередей на единственную категорию типа (по умолчанию {00000000-0000-0000-0000-000000000000})</li>
						<li>Authenticated - позволяет записывать и читать сообщения в очереди только аутентифицированным пользователям</li>
						<li>Privacy Level - позволяет шифровать содержимое сообщения. Значения: None, Optional или Body</li>
						<li>Journal - обеспечивается сохранение в журнале копий принятых сообщений</li>
						<li>Multicast - оппределяет групповой IP-адрес для очереди</li>
					</ul>
				</section>
				<section>
					<h3>Пример интерфейса</h3>
					<img src="img/MSMQ_4.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Класс MessageQueue</h2>
				</section>
				<section>
					<h3>Основные методы</h3>
					<table>
						<tr>
							<td>Create</td>
							<td>создает очередь по определенному пути</td>
						</tr>
						<tr>
							<td>GetPrivateQueuesByMachine</td>
							<td>нахождение приватных очередей по путевому либо форматному имени</td>
						</tr>
						<tr>
							<td>Exists</td>
							<td>проверка существования очереди</td>
						</tr>
						<tr>
							<td>Delete</td>
							<td>удаление очереди</td>
						</tr>
						<tr>
							<td>Send</td>
							<td>отправка сообщение в очередь</td>
						</tr>
						<tr>
							<td>Receive</td>
							<td>извлекает певое сообщение из очереди</td>
						</tr>
						<tr>
							<td>GetAllMessages</td>
							<td>получает все сообщения из очереди</td>
						</tr>
						<tr>
							<td>Peek</td>
							<td>получает сообщение из очереди, но не извлекает его</td>
						</tr>
						<tr>
							<td>PeekById</td>
							<td>получение сообщения из очереди по Id, но не извлекает его</td>
						</tr>
						<tr>
							<td>Purge</td>
							<td>удаляет все сообщения из очереди</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Метод Create</h3>
					<pre>
						<code class="hljs">
public static MessageQueue Create(string path);
public static MessageQueue Create(string path, bool transactional);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = MessageQueue.Create(".\\private$\\MyNewPrivateQueue");
						</code>
					</pre>
				</section>
				<section>
					<h3>Имена каналов</h3>
					<table>
						<tr>
							<td>Public</td>
							<td>{Имя машины}\{Имя очереди}</td>
						</tr>
						<tr>
							<td>Private</td>
							<td>{Имя машины}\Private$\{Имя очереди}</td>
						</tr>
						<tr>
							<td>Journal</td>
							<td>{Имя машины}\{Имя очереди}\Journal$</td>
						</tr>
						<tr>
							<td>Machine journal</td>
							<td>{Имя машины}\Journal$</td>
						</tr>
						<tr>
							<td>Machine dead-letter</td>
							<td>{Имя машины}\Deadletter$</td>
						</tr>
						<tr>
							<td>Machine transactional dead-letter</td>
							<td>{Имя машины}\XactDeadletter$</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Метод GetPrivateQueuesByMachine</h3>
					<pre>
						<code class="hljs">
public static MessageQueue[] GetPrivateQueuesByMachine(string machineName);
						</code>
					</pre>
					<pre>
						<code class="hljs">
foreach (var queue in MessageQueue.GetPrivateQueuesByMachine(Environment.MachineName))
                Console.WriteLine("Очередь: {0}\n", queue.Path);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Exists</h3>
					<pre>
						<code class="hljs">
public static bool Exists(string path);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queueName = @".\private$\MyPrivateQueue";

if (MessageQueue.Exists(queueName))
{
    var queue = new MessageQueue(queueName);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Delete</h3>
					<pre>
						<code class="hljs">
public static void Delete(string path);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queueName = @".\private$\MyPrivateQueue";

if (MessageQueue.Exists(queueName))
{
    MessageQueue.Delete(queueName);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Send</h3>
					<pre>
						<code class="hljs">
public void Send(object obj);
public void Send(object obj, MessageQueueTransaction transaction);
public void Send(object obj, MessageQueueTransactionType transactionType);
public void Send(object obj, string label);
public void Send(object obj, string label, MessageQueueTransactionType transactionType);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
queue.Send("Sample Message", "Label");
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс</h3>
					<pre>
						<code class="hljs">
    public class MessageQueueTransaction : IDisposable
    {
        public MessageQueueTransaction();
        ~MessageQueueTransaction();
        public MessageQueueTransactionStatus Status { get; }
        public void Abort();
        public void Begin();
        public void Commit();
        public void Dispose();
        protected virtual void Dispose(bool disposing);
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Receive</h3>
					<pre>
						<code class="hljs">
public Message Receive();
public Message Receive(MessageQueueTransactionType transactionType);
public Message Receive(MessageQueueTransaction transaction);
public Message Receive(TimeSpan timeout);
public Message Receive(TimeSpan timeout, Cursor cursor);
public Message Receive(TimeSpan timeout, MessageQueueTransactionType transactionType);
public Message Receive(TimeSpan timeout, MessageQueueTransaction transaction);
public Message Receive(TimeSpan timeout, Cursor cursor, MessageQueueTransactionType transactionType);
public Message Receive(TimeSpan timeout, Cursor cursor, MessageQueueTransaction transaction);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
var message = queue.Receive();				
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод GetAllMessages</h3>
					<pre>
						<code class="hljs">
public Message[] GetAllMessages();
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
var messages = queue.GetAllMessages();
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Peek</h3>
					<pre>
						<code class="hljs">
        public Message Peek();
        public Message Peek(TimeSpan timeout);
        public Message Peek(TimeSpan timeout, Cursor cursor, PeekAction action);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод PeekById</h3>
					<pre>
						<code class="hljs">
public Message PeekById(string id);
public Message PeekById(string id, TimeSpan timeout);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
var message = queue.PeekById("035e0464-4ed2-434d-95ce-f7ab1b2c8ff6\12");
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Purge</h3>
					<pre>
						<code class="hljs">
public void Purge();
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Класс Message</h2>
				</section>
				<section>
					<h3>Основыне совйства</h3>
					<table>
						<tr>
							<td>ArrivedTime (DateTime)</td>
							<td>время прибытия в очередь назначения</td>
						</tr>
						<tr>
							<td>Authenticated (bool)</td>
							<td>проверяет, аутентифицировано ли сообщение (только геттер)</td>
						</tr>
						<tr>
							<td>Body (object)</td>
							<td>тело сообщения</td>
						</tr>
						<tr>
							<td>BodyStream (stream)</td>
							<td>установка/получения тела сообщения через поток</td>
						</tr>
						<tr>
							<td>Formatter (IMessageFormatter)</td>
							<td>форматтер для сериализации/десериализации сообщения</td>
						</tr>
						<tr>
							<td>HashAlgorithm (HashAlgorithm)</td>
							<td>алгоритм для аутентификации</td>
						</tr>
						<tr>
							<td>Id (string)</td>
							<td>идентификатор сообщения в очереди (только геттер)</td>
						</tr>
						<tr>
							<td>Label (string)</td>
							<td>заголовок сообщения</td>
						</tr>
						<tr>
							<td>MessageType (MessageType)</td>
							<td>тип сообщения (Acknowledgment, Normal, Report)</td>
						</tr>
						<tr>
							<td>Priority (MessagePriority)</td>
							<td>приоритет сообщения</td>
						</tr>
						<tr>
							<td>SentTime (DateTime)</td>
							<td>время отправки</td>
						</tr>
						<tr>
							<td>TransactionId (string)</td>
							<td>идентификатор транзакции</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Приоритет сообщения</h3>
					<pre>
						<code class="hljs">
    public enum MessagePriority
    {
        Lowest = 0,
        VeryLow = 1,
        Low = 2,
        Normal = 3,
        AboveNormal = 4,
        High = 5,
        VeryHigh = 6,
        Highest = 7
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 1</h3>
					<pre>
						<code class="hljs">

				// Create a new bitmap.
				// The file must be in the \bin\debug or \bin\retail folder, or
				// you must give a full path to its location.
				Image myImage = Bitmap.FromFile("SentImage.bmp");

				// Connect to a queue on the local computer.
				MessageQueue myQueue = new MessageQueue(".\\myQueue");

				Message myMessage = new Message(myImage, new BinaryMessageFormatter());

				// Send the image to the queue.
				myQueue.Send(myMessage);
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 2</h3>
					<pre>
						<code class="hljs">
MessageQueue myQueue = new MessageQueue(".\\myQueue");

				// Set the formatter to indicate body contains an Order.
				myQueue.Formatter = new BinaryMessageFormatter();

				// Receive and format the message. 
				System.Messaging.Message myMessage = myQueue.Receive(); 
				Bitmap myImage = (Bitmap)myMessage.Body;

				// This will be saved in the \bin\debug or \bin\retail folder.
				myImage.Save("ReceivedImage.bmp",System.Drawing.Imaging.ImageFormat.Bmp);
						</code>
					</pre>
				</section>
				<section>
					<h2>Форматировщик сообщений</h2>
				</section>
				<section>
					<h3>Типы формартировщиков</h3>
					<ul>
						<li>XmlMessageFormatter - форматировщик по умолчанию. Сериализует объекты, используя XML</li>
						<li>BinaryMessageFormatter - Собщения сериализуются в двоичный формат. Эти сообщения короче, чем сформатированные с применением
							XML
						</li>
						<li>ActiveXMessageFormatter - Двоичный форматировщик, так что сообщения могут быть прочитаны и записаны объектами COM.
							Используя этот форматировщик, можно записывать сообщения в очередь с помощью классов .NET и читать их оттуда объектами
							COM
						</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
queue.Formatter = new XmlMessageFormatter(
      new String[] { "System.String" });
Message message = queue.Receive();
Console.WriteLine(message.Body);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
      queue.Formatter = new BinaryMessageFormatter();

foreach (Message message in queue)
      Console.WriteLine(message.Body);
						</code>
					</pre>
				</section>
				<section>
					<h3>Вид сообщения в системе</h3>
					<img src="img/MSMQ_6.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Использование транзакций</h2>
				</section>
				<section>
					<h3>Класс MessageQueueTransaction</h3>
					<pre>
						<code class="hljs">
    public class MessageQueueTransaction : IDisposable
    {
        public MessageQueueTransaction();
        ~MessageQueueTransaction();
        public MessageQueueTransactionStatus Status { get; }
        public void Abort();

        public void Begin();

        public void Commit();
        public void Dispose();

        protected virtual void Dispose(bool disposing);
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
MessageQueue queue = new MessageQueue(@".\private$\MyPrivateQueue");
Message msg = new Message("Example Message Body");
MessageQueueTransaction transaction = new MessageQueueTransaction();

try
{
    transaction.Begin();
    queue.Send(msg, "Example Message Label", transaction);
    transaction.Commit();
}
catch(System.Exception e)
{
    transaction.Abort();
    throw e;
}
finally
{
    transaction.Dispose();
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Azure Service Bus</h1>
			</section>
			<section>
				<h2>Служебная шина Azure</h2>
				<blockquote>
					Высоконадежная облачная система для обмена сообщениями между приложениями и службами, которая эффективно работает, даже если
					некоторые элементы инфраструктуры недоступны в сети
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Основное назначение</h2>
				</section>
				<section>
					<h3>Создание масштабируемых облачных решений</h3>
					<blockquote>
						Асинхронный обмен сообщениями не только обеспечивает устойчивую работу приложений, но и дает возможность надежно масштабировать
						используемое решение. Интеграция облачных ресурсов, таких как база данных SQL, служба хранилища и веб-приложения службы
						приложений, со службой обмена сообщениями служебной шины гарантирует надежную работу в условиях любых нагрузок и позволяет
						избежать простоев в случае сбоя
					</blockquote>
				</section>
				<section>
					<h3>Внедрение сложных процессов обмена сообщениями</h3>
					<blockquote>
						Служебная шина позволяет создавать надежные топологии обмена сообщениями со сложными параметрами маршрутизации, одновременно
						повышая общую доступность решения. С ее помощью можно доставлять сообщения одновременно нескольким подписчикам, а также
						рассылать сообщения в системы, расположенные на нижних уровнях архитектуры системы
					</blockquote>
				</section>
				<section>
					<h3>Повышение безопасности между гибридными облаками</h3>
					<blockquote>
						Функция гибридных подключений в ретрансляторе служебной шины позволяет безопасно работать с имеющимися ресурсами, где бы
						они ни находились, не используя сложные VPN-конфигурации, настройки брандмауэра или параметры сети. Эта функция обеспечивает
						расширенную проверку подлинности и подключение через облако, а также позволяет просматривать и отслеживать активность
					</blockquote>
				</section>
				<section>
					<h3>Использование одного подключения несколькими приложениями</h3>
					<blockquote>
						Благодаря гибридным подключениям и ретранслятору служебной шины не нужно никуда переносить свои локальные данные, чтобы настроить
						к ним доступ из облака или любого другого расположения
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/servicebus_architecture.png" alt="">
			</section>
			<section>
				<h2>Механизмы взаимодействия</h2>
				<ul>
					<li><span class="highlight-blue">Очереди</span> (однонаправленное взаимодействие) - действует как посредник (брокер), который
						хранит отправленные сообщения, пока они не будут получены. Каждое сообщение получает один получатель</li>
					<li><span class="highlight-blue">Разделы</span> (однонаправленное взаимодействие с использованием подписок) - подобно очереди,
						действует как брокер, но каждая подписка может при необходимости применить фильтр, чтобы получать только те сообщения,
						которые соответствуют определенным условиям. В одном разделе может быть несколько подписок</li>
					<li><span class="highlight-blue">Ретрансляторы</span> (двунаправленное взаимодействие) - не хранит передаваемые сообщения,
						так как не является брокером</li>
				</ul>
			</section>
			<section>
				<h2>Ключевые моменты</h2>
				<blockquote>
					При создании очереди, раздела или ретранслятора задается имя. В комбинации с именем пространства имен это имя создает уникальный
					идентификатор объекта. Приложения могут передать это имя службе Service Bus, а затем использовать соответствующую очередь,
					раздел или ретранслятор для взаимодействия с другими приложениями
				</blockquote>
				<blockquote>
					Каждое сообщение состоит из двух частей: набора свойств (пар ключ/значение) и двоичного тела сообщения
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Очереди</h2>
				</section>
				<section>
					<h3>Схема обмена данными через очередь</h3>
					<img src="img/servicebus_queues.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Два способа считывания сообщения: ReceiveAndDelete (извлекает сообщение из очереди и сразу удаляет его) и PeekLock
							(извлекает сообщение из очереди, блокирует сообщение, делая его невидимым для других получателей, а затем ожидает
							определенного события)
						</li>
						<li>
							Получатели принимают и обрабатывают сообщения в том порядке, в котором они были добавлены в очередь
						</li>
						<li>Может отправлять и получать сообщения с разной скоростью (выравнивании нагрузки). Это сокращает расходы на инфраструктуру,
							необходимую для обработки нагрузки приложения</li>
						<li>
							Уменьшает зависимость между компонентами. Обновление потребителя не будут оказывать влияния на производителя
						</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Разделы</h2>
				</section>
				<section>
					<h3>Схема обмена данными через разделы</h3>
					<img src="img/servicebus_topicsandsubscriptions.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Позволяют каждому принимающему приложению создавать собственную подписку, определив фильтр. Подписчик будет видеть
							только те сообщения, которые соответствуют фильтру
						</li>
						<li>Два способа считывания сообщения: ReceiveAndDelete и PeekLock)
						</li>
						<li>Каждое опубликованное сообщение становится доступным в рамках каждой подписки, зарегистрированной в разделе. Сообщения
							отправляются в раздел и доставляются в одну или несколько связанных подписок в зависимости от правил фильтрации</li>
						<li>Нельзя непосредственно получить сообщение из раздела (только из подписок). Подписка раздела напоминает виртуальную
							очередь, которая получает копии сообщений, отправленных в раздел</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Ретрансляторы</h2>
				</section>
				<section>
					<h3>Схема обмена данными через ретранслятор</h3>
					<img src="img/servicebus_relay.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Обходит ограничения реобразование сетевых адресов (NAT) и блокировки Брандмауэром внешних портов через NAT</li>
						<li>Для двунаправленного взаимодействия через ретранслятор каждое приложение устанавливает исходящее TCP-соединение с Service
							Bus и держит его открытым</li>
						<li>Удержание соединение позволяет брандмауэру разрешать входящий трафик для каждого приложения без открытия новых портов.
							Этот подход также решает проблему NAT, так как каждое приложение имеет постоянную конечную точку в облаке на протяжении
							всего обмена данными</li>
						<li>Service Bus предоставляет привязки WCF, которые упрощают взаимодействие приложений через ретрансляторы</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Схемы работы Azure Service Bus Queues</h2>
				</section>
				<section>
					<h3>Пример 1</h3>
					<img src="img/servicebus_azure_combination_1.png" alt="">
				</section>
				<section>
					<h3>Пример 2</h3>
					<img src="img/servicebus_azure_combination_2.png" alt="">
				</section>
			</section>
			<section>
				<h1>Архитектура служебной шины Azure</h1>
			</section>
			<section>
				<section>
					<!--https://github.com/Microsoft/azure-docs.ru-ru/blob/master/articles/service-bus/service-bus-architecture.md -->
					<h2>Единицы масштабирования</h2>
					<blockquote>
						Содержимое служебной шины упорядочено по единицам масштабирования.
					</blockquote>
					<blockquote>
						Единица масштабирования — это единица развертывания, которая содержит все компоненты, необходимые для запуска службы. Для
						каждой области развертывается одна или несколько единиц масштабирования служебной шины
					</blockquote>
				</section>
				<section>
					<h3>Структура единиц масштабирования</h3>
					<ul>
						<li>Набор узлов шлюза - проверяют подлинность входящих запросов и обрабатывают запросы на ретрансляцию. У каждого узла
							шлюза есть общедоступный IP-адрес</li>
						<li>Набор узлов брокера сообщений - обрабатывают запросы к сущностям обмена сообщениями</li>
						<li>Единое хранилище шлюза - содержит данные по каждой сущности, определенной в соответствующей единице масштабирования.
							Хранилище шлюза реализуется на основе базы данных SQL Azure</li>
						<li>Хранилища сообщений - содержат сообщения из всех очередей, разделов и подписок, определенных в соответствующей единице
							масштабирования. Здесь же хранятся все данные подписки. Если не включены секционированные сущности обмена сообщениями,
							очередь или раздел сопоставляется с одним хранилищем</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Контейнеры</h2>
					<blockquote>
						Контейнер — логическая конструкция, которая использует одно единственное хранилище сообщений для хранения всех соответствующих
						данных в этом контейнере. Каждый контейнер назначается узлу брокера сообщений
					</blockquote>
				</section>
				<section>
					<h3>Особенности контейнеров</h3>
					<ul>
						<li>Определенный контейнер назначается каждой сущности обмена сообщениями</li>
						<li>Каждый контейнер назначается узлу брокера сообщений</li>
						<li>Каждый узел брокера сообщений загружает несколько контейнеров. Контейнеры назначаются узлу брокера сообщений таким
							образом, чтобы все узлы брокера сообщений были загружены в равной мере</li>
						<li>Если шаблон нагрузки меняется (один из контейнеров загружается слишком сильно) или узел брокера сообщений становится
							временно недоступным, контейнеры перераспределяются между узлами брокера сообщений</li>
					</ul>
				</section>
				<section>
					<h3>Пространства имен</h3>
					<blockquote>
						Пространство имен — это общий контейнер для всех компонентов обмена сообщениями. В одном пространстве имен могут содержаться
						несколько очередей и разделов. Часто пространства имен выполняют роль контейнеров приложений
					</blockquote>
				</section>
			</section>
			<section>
				<section>
					<h2>Обработка входящих запросов обмена сообщениями</h2>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<ol>
						<li>Клиент отправляет запрос на служебную шину, подсистема балансировки нагрузки передает его в один из узлов шлюза</li>
						<li>Узел шлюза авторизует запрос</li>
						<li>Если запрос относится к сущности обмена сообщениями (очереди, разделу или подписке), узел шлюза выполняет поиск этой
							сущности в хранилище шлюза и определяет, в каком хранилище сообщений она находится</li>
						<li>Определяется какой узел брокера сообщений обслуживает контейнер в данный момент, и отправляет запрос на этот узел
						</li>
						<li>Узел брокера обрабатывает запрос и обновляет состояние сущности в хранилище контейнера</li>
						<li>Узел отправляет ответ обратно на узел шлюза, который пересылает соответствующий ответ клиенту, отправившему исходный
							запрос
						</li>
					</ol>
				</section>
				<section>
					<h3>Графическое представление</h3>
					<img src="img/Обработка_входящих_запросов_обмена_сообщениями.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Обработка входящих запросов на ретрансляцию</h2>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<ol>
						<li>Клиент отправляет запрос на служебную шину, подсистема балансировки нагрузки передает его в один из узлов шлюза
						</li>
						<li>Если запрос связан с прослушиванием, узел шлюза создает новую ретрансляцию</li>
						<li>Если запрос связан с подключением к определенной ретрансляции, узел шлюза переадресовывает его на узел шлюза, которому
							принадлежит ретрансляция</li>
						<li>Узел шлюза, которому принадлежит ретрансляция, отправляет запрос о подключении клиенту прослушивания, чтобы прослушиватель
							создал временный канал к узлу шлюза, получившему запрос на подключение</li>
						<li>При установки подключения ретрансляции, клиенты могут обмениваться сообщениями через узел шлюза, используемый для связи</li>
					</ol>
				</section>
				<section>
					<h3>Графическое представление</h3>
					<img src="img/Обработка_входящих_запросов_на_ретрансляцию.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Аутентификация и авторизация</h2>
					<blockquote>
						Приложения могут проходить проверку подлинности в служебной шине Azure, используя либо проверку подлинности подписанного
						URL-адреса (SAS), либо службу контроля доступа Azure Active Directory (ACS).
					</blockquote>
				</section>
				<section>
					<h3>Проверка подлинности с помощью подписанного URL-адреса (SAS)</h3>
					<ul>
						<li>Позволяет предоставлять пользователю доступ к ресурсам служебной шины с определенными правами</li>
						<li>Предусматривает настройку соответствующих прав для криптографического ключа в ресурсе служебной шин</li>
						<li>Поддерживается в ретрансляторах служебной шины</li>
						<li>Для получения доступа к сущности, клиенту требуется маркер SAS, который создается с помощью правила SharedAccessAuthorizationRule
						</li>
						<li>Маркер создается с помощью хэш-функции HMAC-SHA256 строки ресурса, состоящей из URI ресурса, к которому запрашивается
							доступ, и срока действия с криптографическим ключом, связанным с правилом авторизации</li>
					</ul>
				</section>
				<section>
					<h3>Объект SharedAccessAuthorizationRule</h3>
					<ul>
						<li>KeyName — определяет правило</li>
						<li>PrimaryKey — криптографический ключ, используемый для подписи и проверки маркеров SAS</li>
						<li>SecondaryKey — криптографический ключ, используемый для подписи и проверки маркеров SAS</li>
						<li>Rights — набор прав на прослушивание, отправку или управление</li>
					</ul>
				</section>
				<section>
					<h3>Проверка подлинности ACS</h3>
					<blockquote>
						Аутентификация с помощью ACS осуществляется с помощью связанного пространства имен ACS
					</blockquote>
					<ul>
						<li>Необходимо настроить соответствующие отношения доверия</li>
						<li>Для получения доступа к сущности, клиент запрашивает маркер SWT из ACS с соответствующими утверждениями, предоставляя
							свои учетные данные. Затем маркер SWT необходимо отправить в служебную шину как часть запроса. Это позволит авторизовать
							клиента для получения доступа к сущности</li>
						<li>Проверка подлинности импользует объект SharedSecretTokenProvider</li>
						<li>Все интерфейсы API, которые принимают строку подключения в качестве параметра, поддерживают строки подключения ACS</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Итого</h2>
					<ul>
						<li>Позволяет получать сообщения без постоянного «поллинга»</li>
						<li>Гарантирует сохранение порядка обработки сообщений</li>
						<li>Автоматически детектирует дубликаты сообщений</li>
						<li>Обрабатывать сообщения параллельно (сообщения ассоциируются с потоком по SessionId)</li>
						<li>Поддерживает транзакционность при отсылке или приёме группы сообщений</li>
						<li>Время жизни сообщения достаточно долгое (более 7 дней)</li>
						<li>Обрабатывать сообщения более 64КБ</li>
					</ul>
				</section>
				<section>
					<h3>Итого</h3>
					<ul>
						<li>Обеспечение безопасности на основе ролей и прав доступа</li>
						<li>Гарантия доставки</li>
						<li>Интерграция с .NET сервисами (WCF)</li>
						<li>Обмену сообщениями через посредника служебной шины на основе REST</li>
						<li>SDK для .NET, Java, Node.js, Ruby, Python, PHP</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример использования</h2>
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/SB_1.png" alt="">
				</section>
				<section>
					<h3>Создание пространства имен службы</h3>
					<img src="img/SB_2.png" alt="">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/SB_3.png" alt="">
				</section>
				<section>
					<h3>Результат создания namespace</h3>
					<img src="img/SB_4.png" alt="">
				</section>
				<section>
					<h3>Создание очереди</h3>
					<img src="img/SB_5.png" alt="">
				</section>
				<section>
					<h3>Результат создания очереди</h3>
					<img src="img/SB_6.png" alt="">
				</section>
				<section>
					<h3>Получение учетных данных управления</h3>
					<img src="img/SB_7.png" alt="">
				</section>
				<section>
					<h3>Строка подключения</h3>
					<img src="img/SB_8.png" alt="">
				</section>
				<section>
					<h3>Nuget-пакет</h3>
					<img src="img/SB_9.png" alt="">
				</section>
				<section>
					<h3>Отправка сообщения</h3>
					<pre>
						<code class="hljs">
static void Main(string[] args)
{
    //CONNECTION STRING–PRIMARY KEY
    var connectionString = @"Endpoint=
            sb://makshlservicebus.servicebus.windows.net/;
            SharedAccessKeyName=RootManageSharedAccessKey;
            SharedAccessKey=Jha3oP0D5jZku5Fs2nS/nhVW9bd6W9+00SqKW5T1Upw=";
    var queueName = "queue1";

    var client = QueueClient.CreateFromConnectionString(
          connectionString, 
          queueName
    );
    var message = new BrokeredMessage("This is a test message!");

    client.Send(message);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Статистика</h3>
					<img src="img/SB_10.png" alt="">
				</section>
				<section>
					<h3>Получение сообщения</h3>
					<pre>
						<code class="hljs">
static void Main(string[] args)
{
    //CONNECTION STRING–PRIMARY KEY
    var connectionString = @"Endpoint=
            sb://makshlservicebus.servicebus.windows.net/;
            SharedAccessKeyName=RootManageSharedAccessKey;
            SharedAccessKey=Jha3oP0D5jZku5Fs2nS/nhVW9bd6W9+00SqKW5T1Upw=";
    var queueName = "queue1";

    var client = QueueClient.CreateFromConnectionString(
          connectionString, 
          queueName
    );

    client.OnMessage(message =&gt;
    {
        Console.WriteLine($"Message body: {message.GetBody&lt;String&gt;()}");
        Console.WriteLine($"Message id: {message.MessageId}");
    });
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Полученные сообщения</h3>
					<img src="img/SB_11.png" alt="">
				</section>
				<section>
					<h3>Статистика</h3>
					<img src="img/SB_12.png" alt="">
				</section>
			</section>
			<section>
				<h1>облачными службами Azure</h1>
			</section>
			<section>
				<blockquote>
					Облачные службы являются примером концепции платформа как услуга (PaaS). Так же как и служба приложений, эта технология предназначена
					для поддержки масштабируемых, надежных и недорогих в эксплуатации приложений. Как и служба приложений, облачные службы
					размещаются на виртуальных машинах, однако вы обладаете большим контролем над виртуальными машинами. Вы можете установить
					собственное программное обеспечение в виртуальных машинах, в которых выполняются облачные службы, а также удаленно управлять
					ими.
				</blockquote>
			</section>
			<section>
				<h2>Общая схема облачной службы</h2>
				<img src="img/облачная_служба.png" alt="">
			</section>
			<section>
				<h2>Два варианта запуска</h2>
				<ul>
					<li>Веб-роль Сервер Windows запускается с автоматическим развертыванием вашего приложения в IIS.</li>
					<li>Рабочая роль Сервер Windows запускается без служб IIS.</li>
				</ul>
			</section>
			<section>
				<h3>Отличие</h3>
				<blockquote>
					Несмотря на то, что приложения выполняются в виртуальных машинах, важно понимать, что облачные службы предоставляются не
					как IaaS, а PaaS. Вот как это можно себе представить: в IaaS, например, при использовании виртуальных машин Azure, вы
					сначала создаете и настраиваете среду, в которой будет выполняться приложение, а затем развертываете в ней само приложение.
					При таком подходе на вас ложится множество обязанностей, например, по развертыванию новых исправленных версий операционной
					системы в каждой виртуальной машине. В PaaS же среда уже существует. Вам нужно всего лишь развернуть свое приложение.
					Управление платформой, на базе которой оно выполняется, включая развертывание новых версий операционной системы, осуществляется
					за вас.
				</blockquote>
				<blockquote>
					При использовании облачных служб вы не создаете виртуальные машины. Вместо этого предоставляется файл конфигурации, сообщающий
					Azure, сколько ресурсов вам требуется, например три экземпляра веб-роли и два экземпляра рабочей роли. Платформа создаст
					их самостоятельно. Вам все равно нужно выбрать размер для резервных виртуальных машин, но не требуется явно создавать
					их самостоятельно. Если ваше приложение сталкивается с высокой нагрузкой, вы можете запросить дополнительные виртуальные
					машины, после чего Azure создаст необходимые экземпляры. В случае спада нагрузки вы можете завершить работу этих экземпляров
					и перестать оплачивать их.
				</blockquote>
				<blockquote>
					Кроме того, облачные службы обеспечивают мониторинг. Как и модель виртуальных машин Azure, эта модель обнаруживает неисправный
					физический сервер и перезапускает выполняемые на нем виртуальные машины на новом компьютере. Однако модель облачных
					служб также обнаруживает не только аппаратные сбои, но и неисправные виртуальные машины и приложения. В отличие от виртуальных
					машин, она использует агент внутри каждой веб-роли и рабочей роли, что позволяет в случае сбоя запустить новые виртуальные
					машины и экземпляры приложений.
				</blockquote>
				<blockquote>
					Характер PaaS у модели облачных служб имеет и другие аспекты. Один из наиболее важных заключается в том, что построенное
					на базе этой технологии приложение должно обеспечивать правильную работу в случае сбоя какого-либо из экземпляров веб-роли
					или рабочей роли. Для этого приложение облачных служб не должно сохранять состояние в файловой системе своих собственных
					виртуальных машин. В отличие от виртуальных машин, созданных с помощью модели виртуальных машин Azure, записи в виртуальную
					машину облачных служб не сохраняются постоянно — здесь не существует ничего похожего на диск данных виртуальных машин.
					Вместо этого приложение облачных служб должно явным образом записывать все данные о состоянии в Базу данных SQL, BLOB-объекты,
					таблицы или любое другое внешнее хранилище. Построение приложений с учетом данного аспекта упрощает их масштабирование
					и делает их более отказоустойчивыми, что относится к важным задачам модели облачных служб.
				</blockquote>
			</section>
			<section>
				<section>
					<h2>служба автоматизации</h2>
					<blockquote>
						Служба автоматизации Azure — это служба Azure для упрощения управления облаком путем автоматизации процессов. С помощью службы
						автоматизации Azure можно автоматизировать длительные, выполняемые вручную, ненадежные и часто повторяющиеся задачи
						для повышения надежности, эффективности и ускорения вывода продукта на рынок.
					</blockquote>
				</section>
				<section>
					<ul>
						<li>используя командлеты PowerShell</li>
						<li>готовые скрипты в разделе Инструменты Azure PowerShell</li>
						<li>Вы также можете связать эти командлеты в службе автоматизации Azure с командлетами для других служб Azure чтобы автоматизировать
							сложные задачи в службах Azure и системах сторонних производителей.</li>
						<li></li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Принцип выделения ресурсов</h2>
				<ul>
					<li>Серверы в центрах обработки данных Azure разделены на кластеры</li>
					<li>Запрос о выделении новой облачной службы отправляется в несколько кластеров</li>
					<li>Когда первый экземпляр развертывается в облачной службе (в тестовой или рабочей области), эта облачная служба прикрепляется
						к кластеру</li>
					<li>Все последующие развертывания облачной службы выполняются в том же кластере. В этой статье мы будем называть этот процесс
						прикреплением к кластеру. На приведенной ниже схеме 1 показано, как обычно происходит выделение при попытке выполнения
						в нескольких кластерах. На схеме 2 показано выделение ресурсов, прикрепленное к кластеру 2, так как в нем размещена
						существующая облачная служба CS_1.</li>
					<li></li>
					<li></li>
				</ul>
			</section>
			<section>
				<h1>Схема выделения ошибок выделения ресерсов</h1>
				<img src="img/выделение_ресурсов.png" alt="">
			</section>
			<section>
				<h2>Причины возникновения ресурсов</h2>
				<ul>
					<li>Если запрос на выделение прикреплен к одному кластеру, возрастает вероятность того, что не удастся найти свободные ресурсы,
						так как пул доступных ресурсов ограничен размером кластера.</li>
					<li>Кроме того, если запрос на выделение прикреплен к одному кластеру, а тип запрошенного ресурса не поддерживается, запрос
						завершится ошибкой, даже если в кластере есть свободные ресурсы</li>
					<li>На схеме 3 ниже показан случай, когда ошибка выделения прикрепленных ресурсов произошла из-за отсутствия свободных ресурсов
						в единственном подходящем кластере. На схеме 4 показан случай, когда ошибка выделения прикрепленных ресурсов произошла
						потому, что единственный подходящий кластер не поддерживает запрошенный размер виртуальной машины, несмотря на наличие
						свободных ресурсов в кластере.</li>
					<li></li>
				</ul>
				<img src="img/выделение_ресурсов.png" alt="">
			</section>
			<section>
				<h2>распространенные сценарии выделения ресурсов</h2>
				<ul>
					<li>Развертывание в промежуточном слоте. Если в одном из слотов облачной службы имеется развертывание, вся облачная служба
						прикрепляется к определенному кластеру. Это означает, что если развертывание уже существует в рабочей области, то новое
						промежуточное развертывание может быть выделено только в том же кластере, что и рабочая область. Если кластер близок
						к заполнению, запрос может завершиться ошибкой.</li>
					<li>Масштабирование. Для добавления новых экземпляров в существующую облачную службу требуется выделение ресурсов в том
						же кластере. Для мелких запросов масштабирования ресурсы обычно выделяются, но это происходит не всегда. Если кластер
						близок к заполнению, запрос может завершиться ошибкой.</li>
					<li>Территориальная группа. Если облачная служба не прикреплена ни к какой территориальной группе, структура может распределить
						новое развертывание в пустую облачную службу в любом кластере соответствующего региона. По возможности развертывания
						в одну и ту же территориальную группу будут выполняться в одном и том же кластере. Если кластер близок к заполнению,
						запрос может завершиться ошибкой.</li>
					<li>Территориальная группа vNet. Раньше виртуальные сети привязывались не к регионам, а к территориальным группам, а облачные
						службы в этих виртуальных сетях — к кластеру территориальной группы. По возможности развертывания в виртуальную сеть
						такого типа будут выполняться в связанном кластере. Если кластер близок к заполнению, запрос может завершиться ошибкой.</li>
					<li></li>
				</ul>
			</section>
			<section>
				<h3>Диагностические данные облачных приложений</h3>
				<table>
					<thead>
						<tr>
							<th>Источник данных</th>
							<th>Формат хранения</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Журналы Azure</td>
							<td>Таблица</td>
						</tr>
						<tr>
							<td>Журналы IIS</td>
							<td>BLOB-объект</td>
						</tr>
						<tr>
							<td>Журналы инфраструктуры системы диагностики Azure</td>
							<td>Таблица</td>
						</tr>
						<tr>
							<td>Журналы трассировки невыполненных запросов</td>
							<td> BLOB-объект</td>
						</tr>
						<tr>
							<td>Журналы событий Windows</td>
							<td> Таблица</td>
						</tr>
						<tr>
							<td>Счетчики производительности</td>
							<td>Таблица</td>
						</tr>
						<tr>
							<td>Аварийные дампы</td>
							<td> BLOB-объект</td>
						</tr>
						<tr>
							<td>Пользовательские журналы ошибок</td>
							<td>BLOB-объект</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<h2>Средства для просмотра диагностических данных</h2>
				<ul>
					<li>Обозреватель сервера в Visual Studio. Если установлены инструменты Azure для Microsoft Visual Studio, можно использовать
						узел хранилища Azure в обозревателе сервера для просмотра больших двоичных объектов, доступных только для чтения, и
						табличных данных из учетных записей хранения Azure. Вы можете отображать данные из своей локальной учетной записи эмулятора
						хранения, а также из учетных записей хранения, созданных для Azure. Дополнительную информацию см. в статье Обзор ресурсов
						хранилища с помощью обозревателя сервера и управление ими.</li>
					<li>Обозреватель службы хранилища Microsoft Azure — это автономное приложение, которое упрощает работу с данными из службы
						хранилища Azure на платформе Windows, OSX и Linux.</li>
					<li>Azure Management Studio содержит диспетчер диагностики Azure, который позволяет просматривать и скачивать данные диагностики,
						которые собирают выполняемые в Azure приложения, а также управлять этими данными.</li>
					<li></li>
				</ul>
			</section>
			<!-- Далее про application insights-->
			<!-- Содержимое лекции -->
			<section>
				https://github.com/Microsoft/azure-docs.ru-ru/tree/master/articles/container-service https://github.com/Microsoft/azure-docs.ru-ru/tree/master/articles/service-fabric
				https://github.com/Microsoft/azure-docs.ru-ru/tree/master/articles/sql-database https://github.com/Microsoft/azure-docs.ru-ru/tree/master/articles/storage
				https://github.com/Microsoft/azure-docs.ru-ru/tree/master/articles/traffic-manager https://github.com/Microsoft/azure-docs.ru-ru/tree/master/articles/virtual-network
			</section>
			<section>
				<h1>Балансировка нагрузки</h1>
			</section>
			<section>
				<section>
					<h2>Определение</h2>
					<blockquote>
						Балансировщик нагрузки Azure обеспечивает высокую доступность и производительность сети для приложений. Это балансировщик
						нагрузки уровня 4 (Layer-4) распределяет нагрузку между всеми доступными виртуальными машинами путем вычисления хеш
						функции от трафика, поступившего на данную конечную точку. Эта хеш функция вычисляется таким образом, что все пакеты,
						поступившие в рамках одного соединения (TCP или UDP) направляются на один и тот же сервер
					</blockquote>
				</section>
				<section>
					<h2>Типы балансировки</h2>
					<ul>
						<li>Балансировкой нагрузки для Интернета - балансировка нагрузки входящего интернет-трафика виртуальных машин (балансировкой
							нагрузки для Интернета)</li>
						<li>Внутренняя балансировка нагрузки - балансировка нагрузки трафика между виртуальными машинами в виртуальной сети, между
							виртуальными машинами в облачных службах или между локальными компьютерами и виртуальными машинами в распределенной
							виртуальной сети</li>
						<li>Перенаправление внешнего трафика к определенному экземпляру виртуальной машины</li>
					</ul>
				</section>
				<section>
					<h3>Функции LB</h3>
					<ul>
						<li>Распространение на основе хэша - по умолчанию для сопоставления трафика с доступными серверами используется хэш с пятью
							кортежами (исходный IP-адрес, порт источника, IP-адрес назначения, порт назначения и тип протокола). Пакеты в одном
							сеансе TCP или UDP будут направляться на один экземпляр в конечной точке с балансировкой нагрузки
						</li>
						<li>Перенаправление портов - позволяет контролировать процесс управления входящей связью. Включает в себя трафик с узлов
							Интернета, виртуальных машин в других облачных службах или из виртуальных сетей</li>
						<li>Автоматическая перенастройка - мгновенно перенастраивает сам себя при горизонтальном и вертикальном масштабировании
							экземпляров (при увеличении количества экземпляров для веб-роли и рабочей роли в облачной службе или при добавлении
							дополнительных виртуальных машин в тот же набор балансировки нагрузки)
						</li>
						<li>Мониторинг служб - может проверять работоспособность различных экземпляров сервера. Если проверка не отвечает, балансировщик
							нагрузки Azure прекращает отправлять новое подключение неработоспособным экземплярам</li>
						<li>Исходящее преобразование сетевых адресов (SNAT) - весь исходящий трафик из вашей службы в Интернет подвергается исходному
							преобразованию сетевых адресов (SNAT), при этом используется тот же виртуальный IP-адрес, что и для входящего трафика</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Модели развертывания Azure</h2>
				</section>
				<section>
					<h3>Классическая модель</h3>
					<img src="img/классическая_модель_развертывания.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Облачной службе назначаются общедоступный IP-адрес и полное доменное имя.
						</li>
						<li>Подсистема балансировки нагрузки преобразует порты и балансирует нагрузку сетевого трафика, используя общедоступный
							IP-адрес для облачной службы
						</li>
						<li>Трафик с балансировкой нагрузки определяется конечными точками</li>
						<li>Конечные точки преобразования портов связывают (связь "один к одному") общедоступный порт общедоступного IP-адреса
							и локальный порт, назначенный службе на определенной виртуальной машине</li>
						<li>Конечные точки балансировки связывают (связь "один ко многим") общедоступный IP-адрес и локальные порты, назначенные
							службам на виртуальных машинах в облачной службе</li>
					</ul>
				</section>
				<section>
					<h3>Модель развертывания диспетчера ресурсов</h3>
					<img src="img/Модель_развертывания_диспетчера_ресурсов.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Нет необходимости создавать облачную службу. Можно явно создать подсистему балансировки нагрузки для маршрутизации
							трафика между несколькими виртуальными машинами</li>
						<li>Общедоступный IP-адрес является отдельным ресурсом с меткой домена (DNS-именем). Общедоступный IP-адрес связывается
							с ресурсом подсистемы балансировки нагрузки. Правила балансировщика нагрузки и правила для входящих подключений NAT
							используют общедоступный IP-адрес в качестве конечной точки Интернета для ресурсов, получающих сетевой трафик с балансировкой
							нагрузки.
						</li>
						<li>Частный или общедоступный IP-адрес назначается ресурсу сетевого интерфейса, подключаемому к виртуальной машине. После
							добавления сетевого интерфейса в пул внутренних IP-адресов балансировщика нагрузки балансировщик нагрузки начинает
							отправлять сетевой трафик с балансировкой нагрузки на основе созданных правил балансировки нагрузки.</li>
						<li>Можно управлять с помощью интерфейсов API, шаблонов и инструментов на основе Resource Manager</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Режим распределения нагрузки</h2>
				</section>
				<section>
					<h3>На основе сходства исходного IP</h3>
					<blockquote>
						Мы ввели новый режим распределения, который называется «соответствие исходному IP-адресу» (также известное как соответствие
						сеансу или соответствие клиентскому IP-адресу). С помощью этого режима для подсистемы балансировки нагрузки Azure можно
						настроить использование 2 кортежей (исходный IP-адрес, IP-адрес назначения) или 3 кортежей (исходный IP-адрес, IP-адрес
						назначения, протокол) для сопоставления трафика с доступными серверами. При использовании соответствия исходному IP-адресу
						подключения, инициированные с одного клиентского компьютера, направляются к одной конечной точке DIP.
					</blockquote>
					<blockquote>
						Режим соответствия исходному IP-адресу позволяет устранить несовместимость подсистемы балансировки нагрузки Azure и шлюза
						удаленных рабочих столов. Теперь можно создать ферму шлюза удаленных рабочих столов в одной облачной службе. Другой
						сценарий использования — передача мультимедиа, при которой фактическая передача данных осуществляется по протоколу
						UDP, а управление — по протоколу TCP.
					</blockquote>
				</section>
				<section>
					<h2>ddd</h2>
					<img src="img/load-balancer-session-affinity.png" alt="">
				</section>
				<section>
					<h3>Схема работы</h3>
					<ul>
						<li>Клиент инициирует сеанс TCP для общедоступного IP-адреса с балансировкой нагрузки</li>
						<li>Запрос отправляется по конкретному DIP, сам канал остается активным, чтобы контролировать состояние подключения</li>
						<li>С того же клиентского ПК для той же общедоступной конечной точки с балансировкой нагрузки инициируется новый сеанс
							UDP
						</li>
						<li>Подключение будет направлено на ту же конечную точку DIP, что и предыдущее TCP-подключение</li>
					</ul>
					<blockquote>
						Таким образом можно передавать мультимедиа с более высокой пропускной способностью, поддерживая при этом канал управления
						по TCP
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>При изменении набора балансировки нагрузки (при добавлении или удалении виртуальной машины) распределение запросов
							клиента вычисляется заново</li>
						<li>Нельзя надеяться на то, что новые подключения из существующих клиентских сеансов будут направлены на один сервер</li>
						<li>Кроме того, использование режима распределения соответствия исходному IP-адресу может привести к неравномерному распределению
							трафика
						</li>
						<li> Клиенты, работающие на прокси-серверах, могут рассматриваться как одно уникальное клиентское приложение</li>
					</ul>
				</section>
				<section>
					<h3>На основе сходства хэша</h3>
				</section>
				<section>
					<h3>Схема</h3>
					<img src="img/load-balancer-distribution.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<blockquote>
						В основе алгоритма распределения лежит использование хэша 5 кортежей (исходный IP-адрес, порт источника, IP-адрес назначения,
						порт назначения, тип протокола) для сопоставления трафика с доступными серверами. Он позволяет закреплять IP-адреса
						только в рамках сеанса транспорта. Пакеты в одном сеансе TCP или UDP будут направляться на один экземпляр IP-адреса
						центра обработки данных (DIP) в конечной точке с балансировкой нагрузки. Когда клиент закрывает и снова открывает подключение
						или начинает новый сеанс с того же исходного IP-адреса, порт источника изменяется и перенаправляет трафик к другой
						конечной точке DIP
					</blockquote>
				</section>
			</section>
			<section>
				<section>
					<h3>Примеры использования</h3>
				</section>
				<section>
					<h2></h2>
					<img src="img/lb_ip.png" alt="">
				</section>
				<section>
					<h3>Многоуровневое приложение для Интернета</h3>
					<img src="img/многоуровневое_приложение.png" alt="">
				</section>
				<section>
					<h3>
						Серверы переднего плана в другой службе
					</h3>
					<img src="img/сервер_переднего_плана_в_другой_службе.png" alt="">
					<!-- Другой возможный сценарий для многоуровневого приложения: внутренняя подсистема балансировки нагрузки развертывается в облачной службе, отличной от той, которая использует службу для внутренней подсистемы балансировки нагрузки.
                     Облачные службы, использующие одну и ту же виртуальную сеть, будут иметь доступ к конечной точке внутренней подсистемы балансировки нагрузки. На следующем изображении показано, что веб-серверы переднего плана размещены в облачной службе, отличной от той, в которой размещен сервер базы данных. Кроме того, они используют конечную точку внутреннего балансировщика нагрузки в пределах одной и той же виртуальной сети. -->
				</section>
				<section>
					<h3>Бизнес-приложения в интрасети</h3>
					<img src="img/приложение_в_интрасети.png" alt="">
					<!-- Трафик от клиентов в локальной сети распределяется по набору серверов бизнес-приложений с помощью VPN-подключения к сети Azure.
                    Клиентский компьютер получит доступ к IP-адресу из службы VPN Azure, используя VPN подключение типа "точка — сеть". Это позволит использовать бизнес-приложение, размещенное за конечной точкой внутренней подсистемы балансировки нагрузки.-->
				</section>
			</section>
			<section>
				<h3>Создание собственного LB</h3>
				<ol>
					<li>Конфигурация интерфейсных IP-адресов: содержит общедоступные IP-адреса для входящего сетевого трафика</li>
					<li>Пул внутренних адресов: содержит сетевые интерфейсы (сетевые карты), которые позволяют виртуальным машинам получать
						трафик от балансировщика нагрузки</li>
					<li>Правила балансировки нагрузки: содержат правила сопоставления общего порта в балансировщике нагрузки с портом в пуле
						внутренних адресов</li>
					<li>Правила NAT для входящего трафика: содержат правила сопоставления общего порта в балансировщике нагрузки с портом на
						конкретной виртуальной машине в пуле внутренних адресов</li>
					<li>Пробы: содержат пробы работоспособности, которые используются для проверки доступности экземпляров виртуальных машин
						в пуле внутренних адресов</li>
				</ol>
			</section>
			<section>
				<section>
					<h2>Проблема ожидания простоя TCP-соеденений</h2>
					<blockquote>
						По умолчанию значение параметра времени ожидания простоя для балансировщика нагрузки Azure равно 4 минутам. Если период бездействия
						превышает значение времени ожидания, нет никакой гарантии, что сеанс TCP или HTTP между клиентом и облачной службой
						возобновится
					</blockquote>
				</section>
				<section>
					<h3>Как с этим бороться?</h3>
					<ol>
						<li>Постоянная проверка активности TCP. Когда проверка активности включена, пакеты отправляются в периоды простоя подключений.
							Благодаря пакетам проверки активности значение времени ожидания простоя не достигается и подключение сохраняется в
							течение длительного времени</li>
						<li>Необходимо настроить проверку активности TCP с интервалом, который должен быть меньше, чем время ожидания простоя</li>
						<li>Можно увеличить значение времени ожидания простоя</li>
						<li>Не подходят для сценариев, обусловленных коротким временем работы аккумулятора. Не рекомендуется для мобильных приложений
							и служб</li>
					</ol>
				</section>
				<section>
					<h3>Схема работы</h3>
					<img src="img/время_ожидания_простоя.png" alt="">
				</section>
			</section>
			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/nichosi.png" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>