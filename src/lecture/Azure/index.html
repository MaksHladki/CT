<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Платформа облачных вычислений Microsoft Azure</title>
	<meta name="description" content="Платформа облачных вычислений Microsoft Azure">
	<meta name="keywords" content="Azure, MSMQ, Service Bus, Load Balancer, Virtual network">
	<meta name="author" content="Maks Hladki">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h1>Платформа облачных вычислений Microsoft Azure</h1>
					<h3>Облачные технологии</h3>
					<p>
						<small>Гладкий Максим Валерьевич / <a href="https://github.com/MaksHladki">github:MaksHladki</a></small>
					</p>
				</section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
			<section>
				<h2>Microsoft Azure</h2>
				<blockquote>
					Открытая и гибкая облачная платформа, позволяющая быстро создавать, развертывать и управлять приложениями в глобальной сети
					центров обработки данных под управлением Майкрософт. Приложения можно разрабатывать с помощью любого языка, инструмента
					или платформы. Кроме того, приложения в общедоступном облаке можно интегрировать с имеющейся ИТ-средой
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Эволюция Microsoft Azure</h2>
				</section>
				<section>
					<h3>Первый этап</h3>
					<ul>
						<li>2006 - создана «команда мечты» для разработки облачной ОС RedDog</li>
						<li>2006 - команда Indigo (Windows Communication Foundation) приступает к работе над экспериментальным реле коммуникации
						</li>
						<li>2006 - команда SQL приступает к разработке интернет-версии своей службы</li>
						<li>2007 - три команды начинают сотрудничать друг с другом</li>
						<li>2008 - объединение команд в проект Azure: службы .NET, онлайн-службы, службы SQL. Представлена Azure CTP</li>
					</ul>
				</section>
				<section>
					<h3>Второй этап</h3>
					<ul>
						<li>2009 - выходит версия CTP 3, поддержка доверенного и платформенного кода, геолокация, fast CGI, PHP и Java SDK. Azure
							становится открытой платформой, выпускается первый официальный SDK 1.0</li>
						<li>2010 - платформа доступка в 21 стране, реализована поддержка БД более 50 ГБ, полноценная поддержка IIS и службы удаленного
							рабочего стола</li>
						<li>2011 - инструмент SQL Azure Reporting, Scheduler SDK для поддержки ресурсоемких параллельных приложений</li>
						<li>2012 - добавлена архитектура IaaS, выпущен Python SDK. ЦОДы работают в 8 регионах мира</li>
						<li>2013 - добавлена служба Active Directory</li>
					</ul>
				</section>
				<section>
					<h3>Третий этап</h3>
					<ul>
						<li>2014 - добавлены технологии и интерфейсы машинного обучения</li>
						<li>2014 - Windows Azure переименована в Microsoft Azure</li>
						<li>2015 - оптимизирована и расширена возможность работы с Linux-дистрибутивами</li>
						<li>2015 - добавлена поддержка контейнеров</li>
						<li>2016 - добавлена технология блокчейн, облачный майнинг</li>
					</ul>
				</section>
			</section>

			<section>
				<h2>Основные особенности</h2>
				<ul>
					<li>Открытая - поддерживаются многие ЯП и инструменты</li>
					<li>Гибкая - разнообразие облачных служб (от утилит развертывания до SQL-хранилищ)</li>
					<li>Под управлением Майкрософт - ЦОДы в США, Европе и Азии</li>
					<li>Совместимая - многие компоненты легко интегрируются с Windows Server</li>
					<li>Собственная сеть CDN</li>
				</ul>
			</section>
			<section>
				<h2>Основные возможности</h2>
				<ul>
					<li>Инфраструктура</li>
					<li>Мобильные приложения</li>
					<li>Интернет</li>
					<li>Медиаконтент</li>
					<li>Интеграция</li>
					<li>Идентификация и управление доступом</li>
					<li>Большие данные</li>
					<li>Разработка и тестирование</li>
					<li>Хранение, архивация и восстановление</li>
					<li>Управление данными</li>
				</ul>
			</section>
			<section>
				<h2>Три ОС в одной концепции</h2>
				<ul>
					<li>Windows Server - платформа корпоративного уровня, фундамент облачных вычислений</li>
					<li>System Center - интегрированная платформа для централизованного управления частными, размещенными и общедоступными облаками</li>
					<li>Windows Azure — открытая, гибкая облачная платформа для разработки, развертывания и управления приложениями и задачами,
						размещенными в глобальной сети центров обработки данных Майкрософт</li>
				</ul>
			</section>
			<section>
				<h2>Особенности портала Microsoft Azure</h2>
				<ul>
					<li>В универсальном магазине Marketplace представлены тысячи продуктов от корпорации Майкрософт и других поставщиков</li>
					<li>Единая масштабируемая система позволяет легко находить нужные ресурсы и выполнять различные операции по управлению</li>
					<li>Согласованные страницы управления (колонки) дают возможность управлять самыми разнообразными службами Azure, используя
						унифицированную систему отображения параметров, действий, данных для выставления счетов, сведений о работоспособности
						и использовании и т. д.</li>
					<li>Возможности персонализации позволяют создать собственный начальный экран, на котором после входа в систему будет отображаться
						только та информация, которая нужна пользователю</li>
				</ul>
			</section>
			<section>
				<h2>Free account</h2>
				<img src="img/free-account.png" alt="" height="550">
			</section>
			<section>
				<h1>Архитектура Windows Azure</h1>
			</section>
			<section>
				<h2>Типы приложений</h2>
				<p>С точки зрения пользователей</p>
				<ul>
					<li>Внутренние (on-premises app) - выполняются на компьютере пользователя</li>
					<li>Облачные - выполняются в среде Microsoft Azure в ЦОД</li>
				</ul>
			</section>

			<section>
				<h2>Службы Windows Azure</h2>
				<ul>
					<li>
						<spna class="highlight-blue">Вычислительные службы</spna> - предоставляют компьютерные ресурсы, на которых работают облачные приложения</li>
					<li>
						<spna class="highlight-blue">Сетевые службы</spna> - предоставляют облачные приложения и центры обработки данных пользователям различными способами</li>
					<li>
						<spna class="highlight-blue">Службы обработки данных</spna> - способы хранения, управления, защиты и анализа бизнес-данных, составление отчетов
						по ним
					</li>
					<li>
						<spna class="highlight-blue">Службы приложений</spna> - улучшают производительность, защиту и уровень интеграции облачных приложений, а также делают
						более простым процесс их освоения</li>
				</ul>
			</section>

			<section>
				<h2>Вычислительные службы</h2>
				<table>
					<tbody>
						<tr>
							<td>Виртуальные машины</td>
							<td>универсальная среда для создания, развертывания и управления виртуальными машинами</td>
						</tr>
						<tr>
							<td>Веб-сайты</td>
							<td>специализированная среда для создания и управления веб-сайтами, а также переноса существующих</td>
						</tr>
						<tr>
							<td>Облачные службы</td>
							<td>создание и развертывание масштабируемого ПО любой сложности на любом ЯП</td>
						</tr>
						<tr>
							<td>Мобильные службы</td>
							<td>технологии обработки и хранения данных для мобильных систем</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<h2>Сетевые службы</h2>
				<table>
					<tbody>
						<tr>
							<td>Виртуальная сеть</td>
							<td>позволяет использовать облако в качестве расширения локального ЦОДа</td>
						</tr>
						<tr>
							<td>Диспетчер трафика</td>
							<td>масштабирование трафика по определенным критериям: максимальная производительность, циклическое обслуживание и уровень
								отказоустойчивости
							</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<section>
					<h2>Службы обработки данных</h2>
					<table>
						<tbody>
							<tr>
								<td>Управление данными</td>
								<td>хранение и управление данными в ВМ + MSQL, БД Azure SQL, NoSQL решениях через REST API, blob-хранилищах</td>
							</tr>
							<tr>
								<td>Бизнес-аналитика</td>
								<td>предоставляет службы SQL Server Reporting and Analysis, SharePoint Serve, Azure SQL Reporting, Azure Marketplace
									и HDInsight
								</td>
							</tr>
							<tr>
								<td>HDInsight</td>
								<td>специальная надстройка, позволяющая запускать Apache Hadoop в облаке Azure</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Службы обработки данных</h3>
					<table>
						<tbody>
							<tr>
								<td>Кэш</td>
								<td>распределенное решение для кэширования, ускоряющее работу облачных приложений и снижающее нагрузку на БД
								</td>
							</tr>
							<tr>
								<td>Резервное копирование</td>
								<td>средства автономной защиты данных на сервере, позволяют создавать как автоматические, так и ручные копии</td>
							</tr>
							<tr>
								<td>Диспетчер восстановления</td>
								<td>защита критически важных для бизнеса данных, приложений и служб в платформе виртуализации Hyper-V. Координация репликаций
									и восстановление частных облаков
								</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Службы приложений</h2>
					<table>
						<tbody>
							<tr>
								<td>Мультимедийные службы</td>
								<td>формируют процессы для создания, управления и распространения медиаконтента</td>
							</tr>
							<tr>
								<td>Обмен сообщениями</td>
								<td>шина обслуживания и очередь обеспечивают связь приложений в частном и/или общедоступном облаке</td>
							</tr>
							<tr>
								<td>Узлы уведомлений</td>
								<td>хорошо масштабируемая кросс-платформенная инфраструктура push-уведомлений для приложений, работающих на мобильных
									устройствах
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Службы приложений</h3>
					<table>
						<tbody>
							<tr>
								<td>Службы BizTalk</td>
								<td>функции B2B (Business-to-Business) и EAI (Enterprise Application Integration) для облачных и гибридных решений по
									интеграции
								</td>
							</tr>
							<tr>
								<td>Active Directory</td>
								<td>отвечает за управление идентификацией и контроль доступа для облачных приложений</td>
							</tr>
							<tr>
								<td>Многофакторная аутентификация</td>
								<td>дополнительный уровень аутентификации наряду с учетными данными пользователей, повышающий защищенность доступа к
									локальным и облачным приложениям
								</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<h2>Общая схема</h2>
				<img src="img/service-scheme.png" alt="" height="550">
			</section>
			<section>
				<h2 class="header-hide">Копнем поглубже</h2>
				<img src="img/копнуть.jpeg" alt="" height="600">
			</section>
			<!--<section>
				<h1>Подробнее о вычислительных службах</h1>
			</section>-->
			<section>
				<h1>Веб-сайты</h1>
			</section>
			<section>
				<h2>Определение</h2>
				<blockquote>
					Веб-сайты Azure — это масштабируемая, безопасная и гибкая платформа, на основе которой можно создавать веб-приложения для
					бизнеса, расширять охват бренда и привлекать новых клиентов
				</blockquote>
				<blockquote>
					В зависимости от выбранной ценовой категории вычислительные ресурсы могут находиться на общих или выделенных виртуальных
					машинах. Код приложения выполняется на управляемой виртуальной машине, которая изолирована от других клиентов
				</blockquote>
			</section>
			<section>
				<h2>Особенности</h2>
				<ul>
					<li>Портал самообслуживания с галереей наиболее популярных веб-решений</li>
					<li>Инструмент WebMatrix</li>
					<li>Инструмент публикации приложений</li>
					<li>Azure SDK для Visual Studio</li>
					<li>Утилиты для создания, конфигурирования и управления БД</li>
					<li>Интеграция с системами контроля версий: TFS, GitHub, Bitbucket и т.д.</li>
					<li>Инструмент мониторинга нагрузки и состояния ресурсов веб-приложения</li>
					<li>Утилиты диагностики и тестирования</li>
					<li>Конфигурация SSL-сертификатов</li>
					<li>Конфигурация версии платформы (.NET, PHP, Java и т.д.)</li>
				</ul>
			</section>
			<section>
				<h2>Примущества использования облака</h2>
				<ul>
					<li>Поддержка нескольких языков и платформ (ASP.NET, Node.js, Java, Python, PowerShell)</li>
					<li>Оптимизация DevOps - непрерывная интеграция и развертывание (Team Services, BitBucket, тестирование A/B)</li>
					<li>Автомасштабирование</li>
					<li>Подключение к платформам SaaS и локальным данным. Более 50 соединителей для корпоративных систем (SAP, Oracle), служб
						SaaS (Salesforce, Office 365) и популярных интернет-служб (Facebook, Twitter)</li>
					<li>Шаблоны приложений - быстрое развертывание ПО с открытым исходным кодом (Joomla, Drupal) с помощью мастера</li>
					<li>Интеграция с Visual Studio и другими IDE</li>
					<li>Дополнительные функции (CORS) и интеграция с мобильными приложениями (push-уведомления)</li>
				</ul>
			</section>
			<section>
				<h2>Режимы работы веб-сайтов</h2>
				<ul>
					<li>Бесплатный - мультиарендная архитектура, каждому сайту выделена квота на ресурсы процессора, памяти и сети. Количество
						сайтов зависит от тарифного плана, SLA отсутствует</li>
					<li>Стандартный - можно выбрать сайты, которые будут работать на специально выделенной виртуальной машине (могут размещаться
						до 500 веб-сайтов)
					</li>
					<li>Распределенный - гарантируется SLA более низкого уровня по сравнению со стандартным режимом</li>
				</ul>
			</section>
			<section>
				<h3>Доступность серверов</h3>
				<ul>
					<li>Малый сервер (1 ядро, 1,75 ГБ оперативной памяти)</li>
					<li>Средний сервер (2 ядра, 3,5 ГБ оперативной памяти)</li>
					<li>Большой сервер (4 ядра, 7 ГБ оперативной памяти)</li>
				</ul>
			</section>

			<section>
				<h2>Автомасштабирование</h2>
				<img src="img/auto_scale.jpg" alt="" height="550">
			</section>
			<section>
				<section>
					<h2>Agile разработка</h2>
					<ul>
						<li>Автоматическая сборка после каждой фиксации</li>
						<li>Самопроверка сборок</li>
						<li>Выполнение тестов в клоне рабочей среды</li>
						<li>Удобный просмотр результата последней сборки</li>
						<li>Ежедневная фиксация в главной ветви</li>
						<li>Автоматическое развертывание</li>
					</ul>
				</section>
				<section>
					<h3>Источники данных для непрырывного развертывания</h3>
					<ul>
						<li>VS Team Services</li>
						<li>OneDrive</li>
						<li>Локальный репозиторий Git</li>
						<li>Github</li>
						<li>Bitbucket</li>
						<li>Внешний репозиторий Git</li>
						<li>SVN</li>
						<li>Dropbox</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример развертывания веб-приложения</h2>
				</section>
				<section>
					<h3>Переход из dashbord'a</h3>
					<img src="img/службы_приложений.png" alt="">
				</section>
				<section>
					<h3>Панель управления веб-сайтами</h3>
					<img src="img/службы_приложений_1.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_2.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_3.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_4.png" alt="">
				</section>
				<section>
					<h3>Коллекция приложений</h3>
					<img src="img/службы_приложений_5.png" alt="">
				</section>
				<section>
					<h3>Выбор приложения</h3>
					<img src="img/службы_приложений_6.png" alt="">
				</section>
				<section>
					<h3>Создание приложения</h3>
					<img src="img/службы_приложений_7.png" alt="">
				</section>
				<section>
					<h3>Параметры приложения</h3>
					<img src="img/службы_приложений_8.png" alt="">
				</section>
				<section>
					<h3>Процесс развертывания</h3>
					<img src="img/службы_приложений_9.png" alt="">
				</section>
				<section>
					<h3>Обзор приложения</h3>
					<img src="img/службы_приложений_10.png" alt="">
				</section>
				<section>
					<h3>Быстрый старт</h3>
					<img src="img/службы_приложений_18.png" alt="">
				</section>
				<section>
					<h3>Интеграция</h3>
					<img src="img/службы_приложений_11.png" alt="">
				</section>
				<section>
					<h3>Выбор репозитория</h3>
					<img src="img/службы_приложений_12.png" alt="">
				</section>
				<section>
					<h3>Выбор ветки</h3>
					<img src="img/службы_приложений_13.png" alt="">
				</section>
				<section>
					<h3>Результат интеграции</h3>
					<img src="img/службы_приложений_14.png" alt="">
				</section>
				<section>
					<h3>Результат интеграции</h3>
					<img src="img/службы_приложений_16.png" alt="">
				</section>
				<section>
					<h3>Мониторинг посещений</h3>
					<img src="img/службы_приложений_17.png" alt="">
				</section>
				<section>
					<h3>Резервирование</h3>
					<img src="img/службы_приложений_19.png" alt="">
				</section>
				<section>
					<h3>Консоль</h3>
					<img src="img/службы_приложений_20.png" alt="">
				</section>
			</section>
			<section>
				<h1>Виртуальные машины</h1>
			</section>
			<section>
				<section>
					<h2>Определение</h2>
					<blockquote>
						Виртуальные машины Windows Azure — это масштабируемая IaaS-платформа по запросу, позволяющая быстро подготавливать и развертывать
						в облаке серверные задачи
					</blockquote>
				</section>
				<section>
					<h3>Примеры использования</h3>
					<ul>
						<li>Разработка и тестирование. ВМ обеспечивают быстрый и простой способ создания компьютера с определенными конфигурациями,
							необходимыми для написания кода и тестирования приложения</li>
						<li>Приложения в облаке. Используя ВМ в качестве контейнера для приложения позволяет гибко управлять ресурсами ВМ и приложения,
							платить за дополнительные ВМ, если они нужны, и отключать их, если они не нужны</li>
						<li>Расширенный центр обработки данных. ВМ в виртуальной сети Azure можно легко подключить к корпоративной сети
						</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Механизмы настройки, контроля и отслеживания</li>
						<li>Балансировщик нагрузки</li>
						<li>Инструмент подключения к другим облачным службам Azure, на которых работают веб-роли и рабочие роли</li>
						<li>Механизм копирования виртуальных жестких дисков (Virtual Hard Disk, VHD) из локальной среды в Azure и на их основе
							создать новые виртуальные машины</li>
						<li>Механизм выгрузки VHD из Azure и возможность запуска локально</li>
						<li>Новые ВМ можно создавать из стандартных образов, доступ-ных в галерее Azure (актуальные версии Windows Server, различные
							сборки Linux, Microsoft SharePoint, Microsoft SQL Server, Microsoft BizTalk Server и т.д.)</li>
						<li>Можно использовать для развертывания собственные сборки, которые были созданы локально</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Удаленное управление ВМ Windows по протоколу RDP</li>
						<li>Управление средствами Windows PowerShell</li>
						<li>ВМ Linux поддерживают удаленное управление по SSH</li>
						<li>Механизм создания и подключения к дисков для хранения информации приложений</li>
						<li>Автомасштабирования ресурсов (дополнительное количество ядер процессора, объем ОП)</li>
						<li>Автоматическое сохранение и самостоятельное восстановление после аппаратных сбоев</li>
						<li>Автоматическое сохранение информации на подключенных дисках, они резервированы BLOB-объектами хранилища Windows Azure.
							Экземпляры веб-ролей и рабочих ролей самовосстанавливаются, но не сохраняются</li>
						<li>Использование ВМ тарифицируется по часам</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Способы создания ВМ</h2>
				<ul>
					<li>Портал Azure - создание ВМ через UI портала</li>
					<li>Шаблоны - создание ВМ с использованием шаблона диспетчера ресурсов</li>
					<li>Azure PowerShell - создание ВМ с помощью PowerShell</li>
					<li>Клиентские пакеты SDK - Развертывание ресурсов Azure с помощью языка C#</li>
					<li>Интерфейсы API REST - создание или обновление ВМ через HTTP</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Типы ВМ</h2>
				</section>
				<section>
					<h3>Серия А</h3>
					<blockquote>
						ВМ начального уровня. Идеально подходят для разработки и тестирования систем, потребляющих небольшое количество трафика,
						БД и интеграцию приложений с внешними репозиториями
					</blockquote>
					<img src="img/a_seria.png" alt="">
				</section>
				<section>
					<h3>Серия D</h3>
					<blockquote>
						ВМ общего назначения. Обладают производительным процессором, большим объемом оперативной памяти, опционально устанавливаемым
						SSD. Используются в приложениях совместно с реляционными БД, кэшированием и аналитики
					</blockquote>
					<img src="img/d_seria_1.png" alt="">
				</section>
				<section>
					<h3>Серия D (продолжение)</h3>
					<img src="img/d_seria_2.png" alt="">
					<img src="img/d_seria_v2.png" alt="">
				</section>
				<section>
					<h3>Серия F</h3>
					<blockquote>
						ВМ для сложных пользовательских приложений. На одно ядро выделяется более 2 GB RAM и 16 GB SSD. Используются процессоры серии
						Xenon E5 или Broadwell c частотой до 3.1 GHz и технологией Turbo Boost. Идеально подходит для сложной аналитики, веб
						и игровых сервисов
					</blockquote>
				</section>
				<section>
					<h3>Серия G</h3>
					<blockquote>
						ВМ для сложных пользовательских приложений. Отличается от класса F большим объемом оперативной памяти, количеством ядер процессора
						(до 32 CPU). Для кеширования ОП используются SSD. Приложения способны взаимодействовать с большими SQL и NoSQL хранилищами,
						интегрироваться с SAP и другими решениями
					</blockquote>
					<img src="img/g_seria.png" alt="">
				</section>
				<section>
					<h3>Серия H</h3>
					<blockquote>
						Высокопроизводительные ВМ. Используются 8- или 16-ядерные процессоры Xenon последнего поколения, память стандарта DDR4. Для
						хранения данных и кеширования используются SSD. Для организации RDMA используется сеть Infiniband. Используются для
						сложных вычислений в режиме realtime, пакетной обработки, анализа, моделирования
					</blockquote>
					<img src="img/h_seria.png" alt="" height="300">
				</section>
				<section>
					<h3>Серия N</h3>
					<blockquote>
						ВМ с широкой поддержкой GPU. Используется платформа NVIDIA Tesla и технологии NVIDIA Grid. Отлично подходят для рендерина
						графики и видео, удаленной виртуализации, высокопроизводительных вычислений и майнинга, аналитики
					</blockquote>
					<img src="img/n_seria.png" alt="" height="350">
				</section>
			</section>
			<section>
				<section>
					<h2>Расширения и компоненты ВМ</h2>
				</section>
				<section>
					<h3>Расширения ВМ</h3>
					<blockquote>
						Небольшие приложения, выполняющие настройку и автоматизацию после развертывания на виртуальных машинах Azure
					</blockquote>
					<ul>
						<li>Изменение функций безопасности и идентификации, в том числе сброс значений учетных записей и использование защиты от
							вредоносных программ
						</li>
						<li>Запуск, остановка и настройка функций мониторинга и диагностики</li>
						<li>Сброс или установка функций подключения (RDP, SSH)</li>
						<li>Диагностика, мониторинг и управление ВМ</li>
						<li>Расширения можно запускать с помощью интерфейса командной строки, PowerShell, шаблонов Resource Manager и UI портала
						</li>
					</ul>
				</section>
				<section>
					<h3>Агент виртуальной машины</h3>
					<blockquote>
						Защищенный и нетребовательный к ресурсам процесс, который устанавливает, настраивает и удаляет расширения ВМ на экземплярах
						виртуальных машин Azure из коллекции образов и на пользовательских экземплярах виртуальных машин при наличии установленного
						агента ВМ
					</blockquote>
					<ul>
						<li>Два вида агента: для Windows и Linux</li>
						<li>Устанавливается автоматически при создании виртуальной машины из коллекции образов</li>
						<li>Возможность конфигурирования для собственных образов ВМ</li>
					</ul>
				</section>
				<section>
					<h3>Примеры расширений</h3>
					<table>
						<tr>
							<td>Расширение Custom Script в ОС Windows</td>
							<td>Выполняет скрипты на виртуальной машине Azure</td>
						</tr>
						<tr>
							<td>Расширение DSC в ОС Windows</td>
							<td>Расширение PowerShell DSC (настройка требуемого состояния) для Docker</td>
						</tr>
						<tr>
							<td>Расширение системы диагностики</td>
							<td>Управляет системой диагностики Azure</td>
						</tr>
					</table>
				</section>
			</section>
			<section>
				<h2>Таблица связанных ресурсов</h2>
				<table>
					<thead>
						<tr>
							<th>Ресурс</th>
							<th>*</th>
							<!--обязательно -->
							<th>Описание</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Группа ресурсов</td>
							<td>+</td>
							<td>ВМ должна входить в группу ресурсов</td>
						</tr>
						<tr>
							<td>Учетная запись хранения</td>
							<td>+</td>
							<td>ВМ требуется учетная запись для хранения виртуальных жестких дисков</td>
						</tr>
						<tr>
							<td>Виртуальная сеть</td>
							<td>+</td>
							<td>ВМ должна быть подключена к виртуальной сети</td>
						</tr>
						<tr>
							<td>Общедоступный IP-адрес</td>
							<td>-</td>
							<td>Для удаленного доступа к ВМ можно назначить общедоступный IP-адрес</td>
						</tr>
						<tr>
							<td>Сетевой интерфейс</td>
							<td>+</td>
							<td>Для обмена данными в сети нужен сетевой интерфейс</td>
						</tr>
						<tr>
							<td>Диски данных</td>
							<td>-</td>
							<td>ВМ может содержать диски данных для расширения объема ресурсов хранения</td>
						</tr>
					</tbody>
				</table>
			</section>
			<section>
				<section>
					<h2>Контейнеры</h2>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Различные способы создания узлов в соответствии с конкретной ситуацией</li>
						<li>Создание контейнеров с помощью таких оркестраторов, как Marathon или Swarm</li>
						<li>Resource Manager и шаблоны ресурсов для упрощения развертывание и обновление распределенных приложений</li>
						<li>Интеграция с большим массивом инструментов управления конфигурациями</li>
						<li>Автоматическое создание образов с использованием dockerfile и простых команд</li>
						<li>Используются системы контроля версий в качестве источников приложений контейнера</li>
						<li>Могут использовать изолированные компоненты приложений вместо компьютеров</li>
					</ul>
				</section>
				<section>
					<h3>Разница между ВМ и контейнерами</h3>
					<ul>
						<li>Контейнеры не требуют и не используют гипервизор для изоляции</li>
						<li>Контейнеры использует изоляцию процессов и файловой системы в ядре Linux для получения контейнером доступа только к
							определенным компонентам ядра и собственной изолированной файловой системе
						</li>
						<li>Контейнер является экземпляром уникальной ОС (с точки зрения приложения)</li>
						<li>Приложения в контейнере не могут видеть процессы или другие ресурсы за пределами своего контейнера</li>
						<li>Время запуска контейнера и дополнительные затраты на дисковое пространство для хранения гораздо ниже</li>
						<li>Контейнеры Windows поддерживают формат образов Docker и API Docker, но ими можно также управлять с помощью PowerShell</li>
					</ul>
				</section>
				<section>
					<h3>Сравнение основных функций ВМ и контейнеров</h3>
					<table>
						<thead>
							<tr>
								<th>Функция</th>
								<th>Виртуальные машины</th>
								<th>Контейнеры</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Безопасность</td>
								<td>В большей степени</td>
								<td>В меньшей степени</td>
							</tr>
							<tr>
								<td>Память на диске</td>
								<td>Полная версия ОС и приложения</td>
								<td>Только требования приложений</td>
							</tr>
							<tr>
								<td>Время для запуска</td>
								<td>Загрузка ОС и приложений</td>
								<td>Только запуск приложений, ядро уже работает</td>
							</tr>
							<tr>
								<td>Переносимость</td>
								<td>Много вариантов</td>
								<td>Переносимость в формате образа (хуже)</td>
							</tr>
							<tr>
								<td>Автоматизация образов</td>
								<td>Зависит от ОС и приложений</td>
								<td>Docker и т.д.</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример создания ВМ</h2>
				</section>
				<section>
					<h3>Переход из главного меню</h3>
					<img src="img/WM_1.png" alt="" height="550">
				</section>
				<section>
					<h3>Список решений</h3>
					<img src="img/WM_3.png" alt="" height="550">
				</section>
				<section>
					<h3>Список решений</h3>
					<img src="img/WM_4.png" alt="" height="550">
				</section>
				<section>
					<h3>Список решений</h3>
					<img src="img/WM_5.png" alt="" height="550">
				</section>
				<section>
					<h3>ОС от Microsoft</h3>
					<img src="img/WM_6.png" alt="" height="550">
				</section>
				<section>
					<h3>ОС от Microsoft</h3>
					<img src="img/WM_7.png" alt="" height="550">
				</section>
				<section>
					<h3>Visual Studio</h3>
					<img src="img/WM_9.png" alt="" height="550">
				</section>
				<section>
					<h3>Подписка от MSDN</h3>
					<img src="img/WM_12.png" alt="" height="550">
				</section>
				<section>
					<h3>Ubuntu Server</h3>
					<img src="img/WM_10.png" alt="" height="550">
				</section>
				<section>
					<h3>JDK</h3>
					<img src="img/WM_8.png" alt="" height="550">
				</section>
				<section>
					<h3>Создание ВМ</h3>
					<img src="img/WM_13.png" alt="" height="550">
				</section>
				<section>
					<h3>Базовые настройки</h3>
					<img src="img/WM_14.png" alt="" height="550">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/WM_15.png" alt="" height="550">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/WM_16.png" alt="" height="550">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/WM_17.png" alt="" height="550">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/WM_18.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: Storage</h3>
					<img src="img/WM_19.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: Virtual Network</h3>
					<img src="img/WM_20.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: Subnetwork</h3>
					<img src="img/WM_21.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: IP</h3>
					<img src="img/WM_22.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: Security Group</h3>
					<img src="img/WM_23.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: Extensions</h3>
					<img src="img/WM_24.png" alt="" height="550">
				</section>
				<section>
					<h3>Настройки: Availability</h3>
					<img src="img/WM_25.png" alt="" height="550">
				</section>
				<section>
					<h3>Итоговые параметры настройки</h3>
					<img src="img/WM_26.png" alt="" height="550">
				</section>
				<section>
					<h3>Процесс развертывания</h3>
					<img src="img/WM_27.png" alt="" height="550">
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/WM_28.png" alt="" height="550">
				</section>
				<section>
					<h3>RDP</h3>
					<img src="img/WM_29.png" alt="" height="550">
				</section>
				<section>
					<h3>Мониторинг нагрузки</h3>
					<img src="img/WM_30.png" alt="" height="550">
				</section>
				<section>
					<h3>Подключение по RDP</h3>
					<img src="img/WM_32.png" alt="" height="550">
				</section>
				<section>
					<h3>Установленные приложения</h3>
					<img src="img/WM_33.png" alt="" height="550">
				</section>
				<section>
					<h3>Локальные диски</h3>
					<img src="img/WM_34.png" alt="" height="550">
				</section>
				<section>
					<h3>Hello World</h3>
					<img src="img/WM_35.png" alt="" height="550">
				</section>
				<section>
					<h3>Результат выполнения</h3>
					<img src="img/WM_36.png" alt="" height="550">
				</section>
				<section>
					<h3>Мониторинг нагрузки</h3>
					<img src="img/WM_37.png" alt="" height="550">
				</section>
				<section>
					<h3>Мониторинг нагрузки</h3>
					<img src="img/WM_38.png" alt="" height="550">
				</section>
				<section>
					<h3>Мониторинг нагрузки</h3>
					<img src="img/WM_39.png" alt="" height="550">
				</section>
			</section>

			<section>
				<h1>Облачные службы</h1>
			</section>
			<section>
				<h3>Определение</h3>
				<blockquote>
					Позволяют быстро создавать, развертывать многоуровневые приложения в облаке и управлять ими. Таким образом, можно сконцентрироваться
					на разработке, тестировании, развертывании и управлении ПО, а не тратить время на обслуживание нижележащей инфраструктуры
				</blockquote>
				<blockquote>
					Облачные службы являются примером PaaS. Так же как и служба приложений, эта технология предназначена для поддержки масштабируемых,
					надежных и недорогих в эксплуатации приложений. Облачные службы размещаются на ВМ, однако пользователь обладает большим
					контролем над ВМ, чем служба приложений. Можно установить собственное программное обеспечение в ВМ, в которых выполняются
					облачные службы, а также удаленно управлять ими
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Особенности</h2>
					<ul>
						<li>Назначение нескольких ролей приложению при распределенной обработке либо гибком масштабировании его ресурсов</li>
						<li>Приложения облачных служб можно создать практически на любой популярной платформе разработки (.NET, Node.js, PHP, Java,
							Python и Ruby)</li>
						<li>Возможность интегрировать мобильные и мультимедийные службы Azure в приложения</li>
						<li>Автомасштабирования - приложение автоматически получает или отдает ресурсы по мере необходимости</li>
						<li>Облачные службы предоставляются как PaaS, а не IaaS - пользователю нужно всего лишь развернуть свое приложение. Управление
							платформой (включая развертывание новых версий ОС) осуществляется без его участия</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Пользователь не создает ВМ - предоставляется файл конфигурации, сообщающий Azure, сколько ресурсов ему требуется (например,
							2 экземпляра веб-роли)</li>
						<li>Расширенный мониторинг - обнаруживает аппаратные сбои, неисправные ВМ и приложения. Для этого агент используется внутри
							каждой веб-роли и рабочей роли, что позволяет в случае сбоя запустить новые ВМ и экземпляры приложений
						</li>
						<li>Механизм оповещения в реальном времени о сбоях в работе служб или снижении их производительности</li>
						<li>Приложение облачных служб не сохраняет состояние в файловой системе ВМ. Оно должно явным образом записывать все данные
							о состоянии в БД, BLOB-объекты и т.д. (упрощает масштабирование, повышает отказоустойчивость)</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Два варианта запуска</h2>
				<ul>
					<li><span class="highlight-blue">Веб-роль</span> - сервер Windows запускается с автоматическим развертыванием приложения
						в IIS</li>
					<li><span class="highlight-blue">Рабочая роль</span> - сервер Windows запускается без служб IIS</li>
				</ul>
			</section>
			<section>
				<h2>Общая схема</h2>
				<img src="img/облачная_служба.png" alt="" height="500">
			</section>
			<section>
				<h2>Настройка облачных служб</h2>
				<ul>
					<li>Изменение облачной службы (свойства и конфигурация, правила оповещений, управление сертификатами и доступом пользователей)</li>
					<li>Управление версией гостевой ОС - Azure периодически обновляет гостевые ОС до последнего поддерживаемого образа в семействе
						ОС, указанном в конфигурации службы (CSCFG-файл). Можно изменить параметры данного файла</li>
					<li>Мониторинг - управление оповещениями для определенных типов данных (скорость чтения с диска, процент использования ЦП,
						входящая скорость сети и т.д.)
					</li>
					<li>Конфигурация параметров использования удаленного рабочего стола</li>
					<li>Средства развертывания </li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Использование служб автоматизации</h2>
					<blockquote>
						Служба автоматизации Azure — это служба Azure для упрощения управления облаком путем автоматизации процессов. С помощью службы
						автоматизации можно автоматизировать длительные, выполняемые вручную, ненадежные и часто повторяющиеся задачи для повышения
						надежности, эффективности и ускорения вывода продукта пользователя на рынок
					</blockquote>
				</section>
				<section>
					<h3>Средства автоматизации</h3>
					<ul>
						<li>Командлеты PowerShell</li>
						<li>Готовые скрипты в разделе "Инструменты Azure PowerShell"</li>
						<li>Возможность связать командлеты в службе автоматизации Azure с командлетами для других служб Azure для автоматизации
							сложных задач в службах Azure и системах сторонних производителей</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Принцип выделения ресурсов</h2>
				<ul>
					<li>Серверы в центрах обработки данных Azure разделены на кластеры</li>
					<li>Запрос о выделении новой облачной службы отправляется в несколько кластеров</li>
					<li>Когда первый экземпляр развертывается в облачной службе (в тестовой или рабочей области), эта облачная служба прикрепляется
						к кластеру</li>
					<li>Все последующие развертывания облачной службы выполняются в том же кластере</li>
				</ul>
			</section>
			<section>
				<h2>Схема выделения ресурсов</h2>
				<img src="img/выделение_ресурсов.png" alt="" height="500">
			</section>
			<section>
				<h2>Причины возникновения ошибок</h2>
				<ul>
					<li>Если запрос на выделение прикреплен к одному кластеру, возрастает вероятность того, что не удастся найти свободные ресурсы,
						так как пул доступных ресурсов ограничен размером кластера</li>
					<li>Если запрос на выделение прикреплен к одному кластеру, а тип запрошенного ресурса не поддерживается, запрос завершится
						ошибкой, даже если в кластере есть свободные ресурсы</li>
				</ul>
			</section>
			<section>
				<h2>Сценарии выделения ресурсов</h2>
				<ul>
					<li>Развертывание в промежуточном слоте - если развертывание уже существует в рабочей области, то новое промежуточное развертывание
						может быть выделено только в том же кластере, что и рабочая область</li>
					<li>Масштабирование - для добавления новых экземпляров в существующую облачную службу требуется выделение ресурсов в том
						же кластере. Для мелких запросов масштабирования ресурсы обычно выделяются, но это происходит не всегда. Если кластер
						близок к заполнению, запрос может завершиться ошибкой</li>
					<li>Территориальная группа - если облачная служба не прикреплена ни к какой территориальной группе, структура может распределить
						новое развертывание в пустую облачную службу в любом кластере соответствующего региона</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>сертификаты службы</h2>
					<blockquote>
						Сертификаты используются в Azure для облачных служб (сертификаты службы), а также для проверки подлинности с помощью API
						управления. Используются сертификаты x.509 v3. Они могут содержать закрытый и открытый ключ, а также имеют отпечаток,
						служащий для их однозначной идентификации. Этот отпечаток включен в файл конфигурации Azure для определения сертификата,
						который будет использоваться облачной службой, и может быть заверен другим доверенным сертификатом или быть самозаверяющими
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Сертификаты службы присоединяются к облачным службам, обеспечивая безопасное взаимодействие со службой. Например, при
							развертывании веб-роли нужно указать сертификат, который может выполнять проверку подлинности доступной конечной точки
							HTTPS. Сертификаты службы, определенные в службе, автоматически развертываются в ВМ с запущенным экземпляром роли
						</li>
						<li>Сертификатами службы можно управлять отдельно от служб. Это могут делать разные пользователи (например, разработчик
							и ИТ-менеджер Azure)
						</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Диагностические данные облачных служб</h2>
					<table>
						<thead>
							<tr>
								<th>Источник данных</th>
								<th>Формат хранения</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Журналы Azure</td>
								<td>Таблица</td>
							</tr>
							<tr>
								<td>Журналы IIS</td>
								<td>BLOB-объект</td>
							</tr>
							<tr>
								<td>Журналы инфраструктуры системы диагностики Azure</td>
								<td>Таблица</td>
							</tr>
							<tr>
								<td>Журналы трассировки невыполненных запросов</td>
								<td> BLOB-объект</td>
							</tr>
							<tr>
								<td>Журналы событий Windows</td>
								<td> Таблица</td>
							</tr>
							<tr>
								<td>Счетчики производительности</td>
								<td>Таблица</td>
							</tr>
							<tr>
								<td>Аварийные дампы</td>
								<td> BLOB-объект</td>
							</tr>
							<tr>
								<td>Пользовательские журналы ошибок</td>
								<td>BLOB-объект</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Средства для просмотра диагностических данных</h3>
					<ul>
						<li>Обозреватель сервера в Visual Studio - позволяет просматривать больших двоичных объектов, доступных только для чтения,
							и табличных данных из учетных записей хранения Azure (необходимо интегрировать инструменты Azure в VS)
						</li>
						<li>Обозреватель службы хранилища — это автономное приложение, которое упрощает работу с данными из службы хранилища Azure
							на платформе Windows, OSX и Linux</li>
						<li>Azure Management Studio - содержит диспетчер диагностики Azure, который позволяет просматривать и скачивать данные
							диагностики, которые собирают выполняемые в Azure приложения, а также управлять этими данными</li>
					</ul>
				</section>
			</section>
			<!-- Application Insights -->
			<section>
				<h1>Application Insights</h1>
			</section>
			<section>
				<h2>Определение</h2>
				<blockquote>
					Application Insights позволяет осуществлять мониторинг доступности, производительности и использования веб-приложения. Благодаря
					получаемым данным о производительности и эффективности работы приложения на практике пользователь Azure может принимать
					осознанные решения о направлении разработки в каждом жизненном цикле
				</blockquote>
			</section>
			<section>
				<h2>Типы данных</h2>
				<ul>
					<li>Частота HTTP-запросов, время ответа, частота успешных выполнений</li>
					<li>Частота вызовов зависимостей (HTTP и SQL), время ответа, частота успешных выполнений</li>
					<li>Трассировки исключений из сервера и клиента</li>
					<li>Трассировки журналов диагностики</li>
					<li>Количество просмотров страниц, количество пользователей и сеансов, время загрузки браузера, исключения</li>
					<li>Счетчики производительности сервера</li>
					<li>Пользовательская телеметрия клиента и сервера</li>
					<li>Cегментация с учетом расположения клиента, версии браузера, версии ОС, экземпляра сервера, пользовательских измерений
						и многого другого</li>
					<li>Тесты доступности</li>
				</ul>
			</section>
			<section>
				<h2>Средства диагностики и анализа</h2>
				<ul>
					<li>Интеллектуальные и настраиваемые вручную оповещения о частоте сбоев, доступности и других показателях</li>
					<li>Диаграммы сводных показателей за определенный период времени</li>
					<li>Поиск экземпляров запросов, исключений, пользовательских событий, трассировок журналов, количества просмотров страниц,
						зависимостей и вызовов AJAX по журналам диагностики</li>
					<li>Аналитика — эффективный язык запросов для телеметрии</li>
					<li>Панели мониторинга — на них формируются диаграммы, необходимые для отслеживания компонентов приложения</li>
				</ul>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/insight_схема.png" alt="" height="550">
			</section>
			<section>
				<section>
					<h2>Аналитические средства для разработчиков</h2>
				</section>
				<section>
					<h3>Языки</h3>
					<ul>
						<li>.NET</li>
						<li>Java</li>
						<li>JavaScript</li>
						<li>Objective-C</li>
						<li>PHP</li>
						<li>Python</li>
						<li>Ruby</li>
						<li>Другие</li>
					</ul>
				</section>
				<section>
					<h3>Платформы и среды</h3>
					<ul>
						<li>Angular</li>
						<li>ASP.NET</li>
						<li>Android </li>
						<li>Docker</li>
						<li>iOS</li>
						<li>J2EE</li>
						<li>Приложение Mac OS X </li>
						<li>Node.JS</li>
						<li>UWP</li>
						<li>Другие</li>
					</ul>
				</section>
				<section>
					<h3>Платформы ведения журналов</h3>
					<ul>
						<li>Log4Net, NLog</li>
						<li>Java, Log4J или Logback</li>
						<li>Semantic Logging (SLAB)</li>
						<li>Облачное нагрузочное тестирование</li>
						<li>Подключаемый модуль LogStash</li>
					</ul>
				</section>
				<section>
					<h3>Системы управления содержимым</h3>
					<ul>
						<li>Concrete</li>
						<li>Drupal</li>
						<li>Joomla</li>
						<li>Orchard</li>
						<li>SharePoint</li>
						<li>WordPress</li>
					</ul>
				</section>
				<section>
					<h3>Экспорт и анализ данных</h3>
					<ul>
						<li>Alooma</li>
						<li>Power</li>
						<li>BI</li>
					</ul>
				</section>
				<section>
					<h3>Создание собственного пакета SDK</h3>
					<blockquote>
						Если для языка или платформы не существует пакета SDK, можно легко создать его
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Оповещения</h2>
				<ul>
					<li>Автоматическое получение оповещения превентивной диагностики, которые сообщают о необычных изменениях в частоте сбоев
						и других метриках</li>
					<li>Тесты доступности для постоянного тестирования веб-сайта из расположений по всему миру и немедленного получения сообщений
						электронной почты в случае сбоя проверки</li>
					<li>Конфигурация оповещений для получения информации о выходе метрик, таких как время отклика или доля исключений, за допустимые
						границы
					</li>
				</ul>
			</section>
			<section>
				<h2>Фильтрация и предварительная обработка</h2>
				<ul>
					<li>Выборка сокращает объем данных телеметрии, не искажая статистические данные. Благодаря выборке связанные точки данных
						хранятся вместе, что облегчает навигацию между ними во время диагностики проблемы</li>
					<li>Фильтрация позволяет выбирать или изменять данные телеметрии в пакете SDK перед отправкой на сервер. Например, можно
						исключить запросы от роботов. При помощи фильтрации сократить трафик проще, чем при помощи выборки</li>
					<li>Инициализаторы телеметрии добавляют свойства к любым данным телеметрии, включая данные из стандартных модулей</li>
					<li>API пакета SDK используется для отправки пользовательских событий и показателей</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Настройка App Insights</h2>
				</section>
				<section>
					<h3>Добавление новой службы</h3>
					<img src="img/IN_1.png" alt="">
				</section>
				<section>
					<h3>Настройка параметров</h3>
					<img src="img/IN_2.png" alt="">
				</section>
				<section>
					<h3>Результат настройки</h3>
					<img src="img/IN_3.png" alt="">
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/IN_4.png" alt="">
				</section>
			</section>
			<section>
				<h2>Интерфейс ITelemetry</h2>
				<pre>
						<code class="hljs">
public interface ITelemetry
{
    //  Контекст связанный с текущей телеметрией
    TelemetryContext Context { get; }

    // Отслеживания абсолютного порядка телеметрий. Состоит из двух частей: 
    // постоянный идентификатор для текущего сеанса 
    // и идентификатор для каждого события добавляется в очередь (инкрементален)
    string Sequence { get; set; }

    //  Время записи данных телеметрии
    DateTimeOffset Timestamp { get; set; }

    //  Проверяет наличие потенциально опасных (или не валидных) данных 
    void Sanitize();
}
						</code>
					</pre>
			</section>
			<section>
				<h2>
					Класс TelemetryContext
				</h2>
				<pre>
					<code class="hljs">
public sealed class TelemetryContext
{
    public TelemetryContext();
    public CloudContext Cloud { get; }
    public ComponentContext Component { get; }
    public DeviceContext Device { get; }
    public string InstrumentationKey { get; set; }
    public LocationContext Location { get; }
    public OperationContext Operation { get; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public SessionContext Session { get; }
    public UserContext User { get; }
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Класс TelemetryConfiguration</h2>
				<pre>
					<code class="hljs">
public sealed class TelemetryConfiguration : IDisposable
{
    public TelemetryConfiguration();
    public static TelemetryConfiguration Active { get; }
    public bool DisableTelemetry { get; set; }
    public string InstrumentationKey { get; set; }
    public ITelemetryChannel TelemetryChannel { get; set; }
    public IList&lt;ITelemetryInitializer&gt; TelemetryInitializers { get; }
    public TelemetryProcessorChainBuilder TelemetryProcessorChainBuilder { get; }
    public ReadOnlyCollection&lt;ITelemetryProcessor&gt; TelemetryProcessors { get; }
    public static TelemetryConfiguration CreateDefault();
    public static TelemetryConfiguration CreateFromConfiguration(string config);
    public void Dispose();
}
					</code>
				</pre>
			</section>
			<section>
				<h2>Класс TelemetryClient</h2>
				<pre>
					<code class="hljs" data-trim>
public sealed class TelemetryClient
{
    public TelemetryClient();
    public TelemetryClient(TelemetryConfiguration configuration);
    public TelemetryContext Context { get; }
    public string InstrumentationKey { get; set; }
    public void Flush();
    public void Initialize(ITelemetry telemetry);
    public bool IsEnabled();
    public void Track(ITelemetry telemetry);
    public void TrackAvailability(AvailabilityTelemetry telemetry);
    public void TrackAvailability(string name, DateTimeOffset timeStamp, TimeSpan duration, string runLocation, bool success, string message = null);
    public void TrackEvent(EventTelemetry telemetry);
    public void TrackEvent(string eventName, IDictionary&lt;string, string&gt; properties = null, IDictionary&lt;string, double&gt; metrics = null);
    public void TrackException(ExceptionTelemetry telemetry);
    public void TrackException(Exception exception, IDictionary&lt;string, string&gt; properties = null, IDictionary&lt;string, double&gt; metrics = null);
    public void TrackMetric(MetricTelemetry telemetry);
    public void TrackMetric(string name, double value, IDictionary&lt;string, string&gt; properties = null);
    public void TrackPageView(string name);
    public void TrackPageView(PageViewTelemetry telemetry);
    public void TrackRequest(RequestTelemetry request);
    public void TrackRequest(string name, DateTimeOffset startTime, TimeSpan duration, string responseCode, bool success);
    public void TrackTrace(TraceTelemetry telemetry);
    public void TrackTrace(string message);
    public void TrackTrace(string message, IDictionary&lt;string, string&gt; properties);
    public void TrackTrace(string message, SeverityLevel severityLevel);
    public void TrackTrace(string message, SeverityLevel severityLevel, IDictionary&lt;string, string&gt; properties);
}
					</code>
				</pre>
			</section>
			<section>
				<section>
					<h2>Основные методы класса TelemetryClient</h2>
				</section>
				<section>
					<h3>Метод TrackTrace</h3>
					<blockquote>
						Используется для диагностики проблемных мест (анализ и диагностический поиск) приложения. Может использоваться как "обертка"
						для системы логирования
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message, IDictionary&lt;string, string&gt; properties);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(string message, SeverityLevel severityLevel);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(
    string message, 
    SeverityLevel severityLevel, 
    IDictionary&lt;string, string&gt; properties
);
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim>
public void TrackTrace(TraceTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>SeverityLevel</h3>
					<pre>
						<code class="hljs">
public enum SeverityLevel
{
    Verbose = 0,
    Information = 1,
    Warning = 2,
    Error = 3,
    Critical = 4
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс TraceTelemetry</h3>
					<blockquote>
						Используется для логирования данных. Оперирует сообщением, временем активации и дополнительными параметрами
					</blockquote>
					<pre>
						<code class="hljs">
public sealed class TraceTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public TraceTelemetry();
    public TraceTelemetry(string message);
    public TraceTelemetry(string message, SeverityLevel severityLevel);
    public TelemetryContext Context { get; }
    public string Message { get; set; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    public SeverityLevel? SeverityLevel { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackPageView</h3>
					<blockquote>
						Логирует название страницы (web, mobile, desktop)-приложения, с которой пользователь работает в данный момент
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackPageView(string name);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackPageView(PageViewTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс PageViewTelemetry</h3>
					<blockquote>
						Отслеживание посещаемости страниц пользователями
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public sealed class PageViewTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public PageViewTelemetry();
    public PageViewTelemetry(string pageName);
    public TelemetryContext Context { get; }
    //  Длительность посещения страницы
    public TimeSpan Duration { get; set; }
    //  Пользовательские метрики
    public IDictionary&lt;string, double&gt; Metrics { get; }
	// Имя страницы
    public string Name { get; set; }
    // Словарь для дополнительных параметров
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    // Время, когда событие произошло
    public DateTimeOffset Timestamp { get; set; }
    // URL-страницы
    public Uri Url { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackEvent</h3>
					<blockquote>
						Позволяет логировать вызовы событий в приложении для определения частотности выбора пользователем определенной функции, цели
						и т.д.
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackEvent(EventTelemetry telemetry);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackEvent(
    string eventName, 
    IDictionary&lt;string, string&gt; properties = null, 
    IDictionary&lt;string, double&gt; metrics = null
);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackRequest</h3>
					<blockquote>
						Применяется для логирования или имитации выполнения HTTP-запросов в приложении
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackRequest(RequestTelemetry request);
						</code>
					</pre>
					<pre>
						<code class="hljs">
// name: имя запроса или путь
// startTime: время инициализации запроса
// duration: продолжительность выполнения
// responseCode: status code
// success: True, если обработан успешно
public void TrackRequest(
    string name, 
    DateTimeOffset startTime, 
    TimeSpan duration, 
    string responseCode, 
    bool success
);				
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс RequestTelemetry</h3>
					<blockquote>
						Инкапсулирует информацию о HTTP-запросах в приложении
					</blockquote>
					<pre>
						<code class="hljs" data-trim>
public sealed class RequestTelemetry : 
    OperationTelemetry, ITelemetry, ISupportProperties, ISupportSampling
{
    public RequestTelemetry();
    public RequestTelemetry(string name, DateTimeOffset startTime, 
	   TimeSpan duration, string responseCode, bool success);
    public override TelemetryContext Context { get; }
    public override TimeSpan Duration { get; set; }
    public string HttpMethod { get; set; }
    // Идентификатор запроса
    public override string Id { get; set; }
    public IDictionary&lt;string, double&gt; Metrics { get; }
    //  Имя человека, выполнявшего запрос
    public override string Name { get; set; }
    public override IDictionary&lt;string, string&gt; Properties { get; }
    public string ResponseCode { get; set; }
    public override string Sequence { get; set; }
    // Идентифицирует субъект, обычно записывается хеш
    public string Source { get; set; }
    public override bool? Success { get; set; }
    public override DateTimeOffset Timestamp { get; set; }
    public Uri Url { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackMetric</h3>
					<blockquote>
						Используется для отправки метрик, которые не привязаны к конкретным событиям. Метрики отображаются в виде статистических
						графиков, но в отличие от событий, можно выполнить диагностический поиск по отдельным значениям
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackMetric(
    string name, // имя метрики
    double value, // значение метрики
    IDictionary&lt;string, string&gt; properties = null
    // дополнительные свойства для классификации и фильтрации
);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackMetric(MetricTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс MetricTelemetry</h3>
					<blockquote>
						Инкапсулирует логику отслеживания метрик
					</blockquote>
					<pre>
						<code class="hlsj" data-trim>
public sealed class MetricTelemetry : 
    ITelemetry, ISupportProperties
{
    public MetricTelemetry();
    public MetricTelemetry(string metricName, double metricValue);
    public TelemetryContext Context { get; }
    //  количество элементов
    public int? Count { get; set; }
    //  максимальное значение для метрики
    public double? Max { get; set; }
    // минимальное значение для метрики
    public double? Min { get; set; }
    public string Name { get; set; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    //  Стандартное отклонение для значения метрики
    public double? StandardDeviation { get; set; }
    public DateTimeOffset Timestamp { get; set; }
	// Значение метрики
    public double Value { get; set; }
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод TrackException</h3>
					<blockquote>
						Логирует отловленные исключения. Используется для подсчета показателя частоты возникновения проблем. Включает в отчеты результат
						стека вызова функций
					</blockquote>
					<pre>
						<code class="hljs">
public void TrackException(
    Exception exception, 
    IDictionary&lt;string, string&gt; properties = null, 
    IDictionary&lt;string, double&gt; metrics = null
);
						</code>
					</pre>
					<pre>
						<code class="hljs">
public void TrackException(ExceptionTelemetry telemetry);
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс ExceptionTelemetry</h3>
					<blockquote>
						Инкапсулирует логику логирования искулючительных ситуаций
					</blockquote>
					<pre>
						<code class="hljs">
public sealed class ExceptionTelemetry : 
    ITelemetry, ISupportProperties, ISupportSampling
{
    public ExceptionTelemetry();
    public ExceptionTelemetry(Exception exception);
    public TelemetryContext Context { get; }
    public Exception Exception { get; set; }
	// Информация о месте обработки и отлова исключения
    public ExceptionHandledAt HandledAt { get; set; }
    public string Message { get; set; }
    public IDictionary&lt;string, double&gt; Metrics { get; }
    public IDictionary&lt;string, string&gt; Properties { get; }
    public string Sequence { get; set; }
    public SeverityLevel? SeverityLevel { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Интерфейс ITelemetryProcessor</h2>
					<pre>
					<code class="hljs">
public interface ITelemetryProcessor
{
    void Process(ITelemetry item);
}
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs" data-trim>
public class SuccessfulDependencyFilter : ITelemetryProcessor
{
    private ITelemetryProcessor Next { get; set; }
    public SuccessfulDependencyFilter(ITelemetryProcessor next)
    {
        this.Next = next;
    }
    public void Process(ITelemetry item)
    {
        if (!OKtoSend(item)) { return; }
        ModifyItem(item);

        this.Next.Process(item);
    }
    private bool OKtoSend(ITelemetry item)
    {
        var dependency = item as DependencyTelemetry;
        if (dependency == null) return true;

        return dependency.Success != true;
    }
    private void ModifyItem(ITelemetry item)
    {
        item.Context.Properties.Add("app-time", DateTime.Now.ToLongTimeString());
    }
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Простой пример</h2>
				</section>
				<section>
					<h3>Nuget-пакет</h3>
					<img src="img/IN_nuget.png" alt="">
				</section>
				<section>
					<h3>Какой-то класс (псевдокод)</h3>
					<pre>
							<code class="hljs" data-trim>
public class ApplicationInsight
{
    private static readonly Lazy&lt;ApplicationInsight&gt; _instance;

    private readonly TelemetryClient _tc;

    private ApplicationInsight()

    public static ApplicationInsight Instance {get;}

    private TelemetryClient InitializeTelemetry(){/**/}

    public void TrackPageView(string name){/**/}

    public void TrackException(Exception ex){/**/}

    public void TrackMetric(string metricName, int value){/**/}

    public void TrackTrace(string eventName, int number){/**/}

    public void Flush(){/**/}
}
							</code>
					</pre>
				</section>
				<section>
					<h3>Singleton</h3>
					<pre>
						<code class="hljs" data-trim>
public class ApplicationInsight
{
    private static readonly Lazy&lt;ApplicationInsight&gt; _instance = 
		new Lazy&lt;ApplicationInsight&gt;(() =&gt; new ApplicationInsight());
    private readonly TelemetryClient _tc;

    private ApplicationInsight()
    {
        _tc = InitializeTelemetry();
    }

    public static ApplicationInsight Instance
    {
        get { return _instance.Value; }
    }
    //.......................	
}					
						</code>
					</pre>
				</section>
				<section>
					<h3>Инициализация параметров</h3>
					<pre>
						<code class="hljs">
private TelemetryClient InitializeTelemetry()
{
    var tc = new TelemetryClient
    {
        InstrumentationKey =
            @"clientNotification-ddadd7d9-4bd5-411a-ab5c-c1fe3322e005;
             a518aea0-2971-4fd4-9c38-595b8ffee7ab;
             a518aea0-2971-4fd4-9c38-595b8ffee7ab"
    };

    tc.Context.User.Id = Environment.UserName;
    tc.Context.Session.Id = Guid.NewGuid().ToString();
    tc.Context.Device.OperatingSystem = Environment.OSVersion.ToString();

    return tc;
}
						</code>						
					</pre>
				</section>
				<section>
					<h3>Пример использования</h3>
					<pre>
						<code class="hljs" data-trim>
static void Main(string[] args)
{
    ApplicationInsight.Instance.TrackPageView("Home");
    ApplicationInsight.Instance.TrackPageView("Account");

    ApplicationInsight.Instance.TrackEvent("Login");
    ApplicationInsight.Instance.TrackException(
		new AuthenticationException("User not found"));

    ApplicationInsight.Instance.TrackEvent("Redirect",
        new Dictionary&lt;string, string&gt;
        {
            { "From", "Account" },
            { "To", "Shop" },
            { "DailyKey" , "DSJU-WERDT-9803"}
        });
	
    ApplicationInsight.Instance.TrackPageView("Shop");
    ApplicationInsight.Instance.TrackTrace("Overtime", 100);
    ApplicationInsight.Instance.TrackMetric("Total count", 32);

    ApplicationInsight.Instance.Flush();
}							
						</code>
					</pre>
				</section>
				<section>
					<h3>Результаты в Azure</h3>
					<img src="img/IN_5.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Аналитика</h2>
					<blockquote>
						Аналитика — это мощный инструмент поиска Application Insights
					</blockquote>
				</section>
				<section>
					<h3>Особенности языка</h3>
					<ul>
						<li>Фильтрация необработанных данных телеметрии приложения по любым полям, включая пользовательские свойства и метрики.</li>
						<li>Соединение нескольких таблиц — соотношение запросов с просмотрами страниц, вызовами зависимостей, исключениями и трассировками
							журнала
						</li>
						<li>Сложные статистические агрегаты</li>
						<li>Такие же мощные, как в SQL, но гораздо проще для составления сложных запросов: вместо вложенных инструкций данные передаются
							из одной простой операции в другую</li>
						<li>Мгновенные яркие визуализации</li>
						<li>Типичный запрос содержит исходную таблицу и ряд операторов, разделенных <span class="highlight-blue">|</span></li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Поддерживаемые конструкции языка</h2>
					<ul>
						<li>Let: присвоение имени таблице</li>
						<li>Запросы и операторы: count, evaluate, extend, join, limit, mvexpand, parse, project, project-away, range, reduce, render
							directive, restrict clause, sort, summarize, take, top, top-nested, union, where, where-in</li>
						<li>Статистические функции: any, argmax, argmin, avg, buildschema, count, countif, dcount, dcountif, makelist, makeset,
							max, min, percentile, percentiles, percentilesw, percentilew, stdev, sum, variance</li>
						<li>Скаляры: логические литералы, логические операторы, приведения, скалярные сравнения, gettype, hash, iff, isnotnull,
							isnull, notnull, toscalar</li>
						<li>Числа: арифметические операторы, числовые литералы, abs, bin, exp, floor, gamma, log, rand, sqrt, todouble, toint,
							tolong
						</li>
					</ul>
				</section>
				<section>
					<h3>Поддерживаемые конструкции</h3>
					<ul>
						<li>Дата и время: выражения даты и времени, литералы даты и времени, ago, datepart, dayofmonth, dayofweek, dayofyear, endofday,
							endofmonth, endofweek, endofyear, getmonth, getyear, now, startofday, startofmonth, startofweek, startofyear, todatetime,
							totimespan, weekofyear</li>
						<li>Строка: GUID, маскируемые строковые литералы, cтроковые литералы, cравнение строк, countof, extract, isempty, isnot,
							empty, empty, notempty, parseurl, replace, split, strcat, strlen, substring, tolower, toupper</li>
						<li>Массивы, объекты и динамические типы: литералы массива и объекта, функции динамического объекта, динамические объекты,
							выражения пути JSON, arraylength, extractjson, parsejson, range, todynamic, treepath</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Основные операторы запроса</h2>
				<ul>
					<li>take - отображение n строк</li>
					<li>top - выборка n строк</li>
					<li>sort - сортировка для всей таблицы</li>
					<li>project - выбор, переименование и вычисление столбцов</li>
					<li>extend - вычисление столбцов</li>
					<li>summarize - агрегирование групп строк</li>
					<li>where - фильтрация по условию</li>
					<li>join - доступ к нескольким таблицам, включая запросы и исключения</li>
					<li>let - присвоение результата переменной</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Примеры запросов</h2>
				</section>
				<section>
					<h3>Пример 1</h3>
					<pre>
						<code class="hljs">
requests | top 10 by timestamp desc 

requests | sort by timestamp desc | take 10
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 2</h3>
					<pre>
						<code class="hljs">					
requests | top 10 by timestamp desc
         | project timestamp, name, resultCode
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 3</h3>
					<pre>
						<code class="hljs">
requests 
      | top 10 by timestamp desc 
      | project  
            name, 
            response = resultCode,
            timestamp, 
            ['time of day'] = floor(timestamp % 1d, 1s)
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 4</h3>
					<pre>
						<code class="hljs">
exceptions 
      | where device_Id == "browser" 
      | summarize count() 
	    by device_BrowserVersion, outerExceptionMessage 
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 5</h3>
					<pre>
						<code class="hljs">				
dependencies
    | where timestamp > ago(1d) and  client_Type == "Browser"
    | join (browserTimings | where timestamp > ago(1d))
      on operation_Id
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 6</h3>
					<pre>
					<code class="hljs">
requests 
    | where timestamp > ago(7d) and client_City == "Hyderabad"
    | summarize clients = dcount(client_IP) 
      by tod_UTC=bin(timestamp % 1d, 1h), resultCode
    | extend local_hour = (tod_UTC + 5h + 30min) % 24h + datetime("2001-01-01") 
					</code>
				</pre>
				</section>
				<section>
					<h3>Пример 7</h3>
					<img src="img/insight_analytics.png" alt="">
				</section>
			</section>
			<!-- END Application Insights -->
			<section>
				<h1>SQL Azure</h1>
			</section>

			<section>
				<h2>Определение</h2>
				<blockquote>
					База данных SQL — это реляционная служба баз данных в Microsoft Cloud на основе ядра Microsoft SQL Server, которая подходит
					для выполнения критически важных рабочих нагрузок. База данных SQL обеспечивает прогнозируемую производительность на
					нескольких уровнях службы, динамическую масштабируемость без простоев, встроенную непрерывность бизнес-процессов и защиту
					данных
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Преимущества</h2>
					<ul>
						<li>Развитие и адаптация - динамически увеличивает производительность, надежность и безопасность данных с минимальными
							усилиями со стороны клиента</li>
						<li>Обнаружение угроз и оповещения - встроенный поведенческий анализ, оповещения в реальном времени, настраиваемые политики
							угроз, журнал аудита</li>
						<li>Автоматическая настройка - непрерывный анализ типовых действий приложений, адаптивная настройка и автоматическая коррекция
							производительности
						</li>
						<li>Своевременные рекомендации - БД отслеживает каждый запрос и оценивать его длительность, частоту и затраты ресурсов.
							Автоматические алгоритмы корректируют настройки базы данных оптимальным образом в соответствии с характером запросов</li>
					</ul>
				</section>
				<section>
					<h3>Преимущества</h3>
					<ul>
						<li>Не требует администрирования - автоматическое резервное копирование, аварийное восстановление, обслуживание инфраструктуры,
							исправления систем безопасности, обновления компонентов</li>
						<li>Использование пулов эластичных баз данных для создания более эффективных мультитенантных приложений</li>
						<li>Управляемое автомасштабирование - пулы автоматически в режиме реального времени масштабируют производительность и емкость
							хранилища для эластичных баз данных</li>
						<li>Простота освоения - можно использовать привычные инструменты: cheetah, sql-cli и VS Code, Visual Studio, SQL Server
							Management Studio
						</li>
						<li>Управление через портал, PowerShell, REST API</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h3>Уровни служб</h3>
					<ul>
						<li><span class="highlight-blue">Базовый</span> - подходит для небольшой базы данных, для которой в определенный момент
							времени обычно выполняется одна активная операция (БД для разработки или тестирования, редко используемое приложение)</li>
						<li><span class="highlight-blue">Стандартный</span> - оптимальный вариант для облачных приложений с низкими или средними
							требованиями к производительности операций ввода-вывода, поддерживающий несколько параллельных запросов (веб-приложения)</li>
						<li><span class="highlight-blue">Премиум</span> - большой объем транзакций с высокими требованиями к производительности
							операций ввода-вывода. Поддерживается параллельная работа множества пользователей (БД для поддержки критически важных
							приложений)
						</li>
					</ul>
				</section>
				<section>
					<h3>Сравнение</h3>
					<table>
						<tr>
							<td>Максимальный размер БД</td>
							<td>2 ГБ</td>
							<td>250 ГБ</td>
							<td>1 ТБ</td>
						</tr>
						<tr>
							<td>Максимальный размер хранилища</td>
							<td>117 ГБ</td>
							<td>750 ГБ</td>
							<td>1200 ГБ</td>
						</tr>
						<tr>
							<td>Число баз в пуле</td>
							<td>400</td>
							<td>400</td>
							<td>50</td>
						</tr>
						<tr>
							<td>Период хранения резервной копии</td>
							<td>7 дней</td>
							<td>35 дней</td>
							<td>35 дней</td>
						</tr>
					</table>
				</section>

				<section>
					<h3>Правила масштабирования от Microsoft</h3>
					<table>
						<thead>
							<tr>
								<th>Тип</th>
								<th>Пользователи</th>
								<th>Размер БД</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Basic</td>
								<td>5 </td>
								<td>720 МБ</td>
							</tr>
							<tr>
								<td>Standard (S0)</td>
								<td>10</td>
								<td> 1 GB</td>
							</tr>
							<tr>
								<td>Standard (S1)</td>
								<td>20 </td>
								<td>2,1 ГБ</td>
							</tr>
							<tr>
								<td>Standard (S2)</td>
								<td>50 </td>
								<td>7,1 ГБ</td>
							</tr>
							<tr>
								<td>Premium (P1)</td>
								<td>100 </td>
								<td>14 ГБ</td>
							</tr>
							<tr>
								<td>Premium (P2)</td>
								<td>200 </td>
								<td>28 ГБ</td>
							</tr>
							<tr>
								<td>Premium (P6/P3)</td>
								<td>800 </td>
								<td>114 ГБ</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<h2>Возможности SQL Azure</h2>
				<ul>
					<li>Может представлять собой отдельную базу данных с собственным набором ресурсов (DTU)</li>
					<li>Может входить в состав пула баз данных, в котором набор ресурсов используется совместно (eDTU)</li>
					<li>Может входить в состав масштабируемого набора сегментированных баз данных, которые могут быть отдельными базами данных
						или частью пула</li>
					<li>Может входить в состав набора баз данных, использующихся в шаблоне разработки для мультитенантных приложений SaaS, которые
						могут быть отдельными базами данных или быть частью пула (или этот набор может иметь смешанную конфигурацию)</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Поддерживаемые функции</h2>
					<!-- https://github.com/Microsoft/azure-docs.ru-ru/blob/master/articles/sql-database/sql-database-features.md-->
					<img src="img/fight_logo.png" alt="">
				</section>
				<section>
					<h3>Часть 1</h3>
					<table>
						<thead>
							<tr>
								<th>Компонент</th>
								<th>SQL Server</th>
								<th>SQL Azure</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Активная георепликация</td>
								<td>-</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Постоянное шифрование</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Группы доступности AlwaysOn</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Присоединение базы данных</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Роли приложений</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Автомасштабирование</td>
								<td>-</td>
								<td>+</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Часть 2</h3>
					<table>
						<thead>
							<tr>
								<th>Компонент</th>
								<th>SQL Server</th>
								<th>SQL Azure</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Azure Active Directory</td>
								<td>-</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Фабрика данных Azure</td>
								<td>-</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Аудит</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Инструкции BACKUP и RESTORE</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Встроенные функции</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
							<tr>
								<td>Среда CLR</td>
								<td>+</td>
								<td>-</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Часть 3</h3>
					<table>
						<thead>
							<tr>
								<th>Компонент</th>
								<th>SQL Server</th>
								<th>SQL Azure</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Курсоры</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Сжатие данных</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Зеркальное отображение базы данных</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Моментальные снимки базы данных</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Инструкции языка DDL</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
							<tr>
								<td>Триггеры DDL</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Часть 4</h3>
					<table>
						<thead>
							<tr>
								<th>Компонент</th>
								<th>SQL Server</th>
								<th>SQL Azure</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Инструкции языка DML</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
							<tr>
								<td>Триггеры DML</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Эластичные пулы</td>
								<td>-</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Файловый поток</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Функции</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
							<tr>
								<td>Поддержка данных JSON</td>
								<td>+</td>
								<td>+</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Часть 5</h3>
					<table>
						<thead>
							<tr>
								<th>Компонент</th>
								<th>SQL Server</th>
								<th>SQL Azure</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Управление на основе политик</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Предикаты</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Безопасность на уровне строк</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Семантический поиск</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Порядковые номера</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Агент SQL Server</td>
								<td>+</td>
								<td>-</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>Часть 6</h3>
					<table>
						<thead>
							<tr>
								<th>Компонент</th>
								<th>SQL Server</th>
								<th>SQL Azure</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>PowerShell</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Репликация SQL Server</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
							<tr>
								<td>Хранимые процедуры</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Секционирование таблиц.</td>
								<td>+</td>
								<td>-/+</td>
							</tr>
							<tr>
								<td>Временные таблицы</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>XML-индексы</td>
								<td>+</td>
								<td>+</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Эластичеые пулы</h2>
				</section>
				<section>
					<h3>Определение</h3>
					<blockquote>
						Пулы эластичных БД SQL обеспечивают простое и экономически выгодное решение для управления целевыми показателями производительности
						для нескольких баз данных с совершенно разными и непредсказуемыми моделями функционирования
					</blockquote>
					<!--https://github.com/Microsoft/azure-docs.ru-ru/blob/master/articles/sql-database/sql-database-elastic-pool-guidance.md https://docs.microsoft.com/ru-ru/azure/sql-database/sql-database-elastic-pool-->
				</section>
				<section>
					<h3>Проблема распределения ресурсов</h3>
					<ol>
						<li>Подготовка избыточного количества ресурсов, соответствующего пиковой нагрузке (ведет к повышению затрат)</li>
						<li>Подготовка недостаточного количества ресурсов для экономии (ведет к снижению производительности и удовлетворенности
							клиентов во время пиковой нагрузки)</li>
					</ol>
					<blockquote>
						Пулы эластичных БД решают эту проблему, обеспечивая базы данных необходимыми ресурсами производительности, когда они нужны.
						Они предоставляют простой механизм распределения ресурсов в рамках прогнозируемого бюджета
					</blockquote>
				</section>
				<section>
					<h3>Принцип работы</h3>
					<ul>
						<li>
							Пулу предоставляется заданное количество единиц eDTU по фиксированной цене
						</li>
						<li>Отдельным БД в пуле предоставляется возможность автоматического масштабирования
						</li>
						<li>В условиях интенсивной нагрузки база данных может использовать дополнительные единицы eDTU для удовлетворения потребности
							в ресурсах</li>
						<li>При небольших нагрузках базы данных используют меньше ресурсов (eDTU), а при отсутствии нагрузок не используют их вовсе.
						</li>
						<li>Подготовка ресурсов для всего пула, а не для отдельной базы данных упрощает задачи управления. Кроме того, используя
							пул, вы можете спрогнозировать расходы</li>
						<li>Добавить дополнительные единицы eDTU в существующий пул можно без простоя баз данных</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Eдиницы передачи данных (DTU)</h2>
				</section>
				<section>
					<h3>Определение</h3>
					<blockquote>
						DTU — это единица измерения ресурсов, которые гарантированно доступны любой отдельной базе данных SQL Azure с определенным
						уровнем производительности в рамках уровня службы для отдельных баз данных
					</blockquote>
				</section>
				<section>
					<h3>Структура единицы</h3>
					<ul>
						<li>Показатели ЦП</li>
						<li>Показатели памяти</li>
						<li>Показатели ввода-вывода данных</li>
						<li>Показатели ввода-вывода журналов транзакций</li>
					</ul>
				</section>
				<section>
					<h3>Повышение произодительности БД</h3>
					<blockquote>
						Повысить производительность базы данных означает удвоить количество ресурсов, доступных для этой базы данных
					</blockquote>
					<p class="text">
						Например, база данных P11 уровня "Премиум" с 1750 единицами DTU обеспечивает в 350 раз больше вычислительной мощи, чем база
						данных уровня "Базовый" с 5 единицами DTU
					</p>
				</section>
				<section>
					<h3>Пример</h3>
					<img src="img/single_db_dtus.png" alt="" height="500">
				</section>
				<section>
					<h3>Как выбрать нужный тип на основе DTU?</h3>
					<ul>
						<li>Использовать калькулятр</li>
						<li>Использовать PowerShell-скрипт</li>
						<li>Использовать Command Line Utility</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Eдиницы передачи данных (eDTU)</h2>
				</section>
				<section>
					<h3>Определение</h3>
					<blockquote>
						eDTU — это единица измерения набора ресурсов (DTU), которые совместно используют несколько баз данных на сервере SQL Azure.
						Эти базы данных вместе называются пулом эластичных БД
					</blockquote>
					<blockquote>
						Пулы эластичных БД обеспечивают простое и экономически выгодное решение для управления целевыми показателями производительности
						для нескольких баз данных с совершенно разными и непредсказуемыми моделями функционирования
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Пулу предоставляется заданное количество единиц eDTU по фиксированной цене</li>
						<li>Отдельным БД в эластичном пуле предоставляется возможность гибкого автоматического масштабирования в рамках заданных
							границ
						</li>
						<li>БД, на которые приходится значительная нагрузка, могут потреблять больше eDTU, чтобы обслужить имеющийся спрос, при
							этом базы данных с меньшей нагрузкой смогут потреблять меньше eDTU</li>
						<li>Если у базы данных прогнозируемо низкие показатели использования ресурсов, ее можно переместить из пула и настроить
							в качестве отдельной базы данных с прогнозируемым объемом ресурсов, который ей необходим</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<img src="img/sqldb_elastic_pools.png" alt="" height="500">
				</section>
			</section>
			<section>
				<section>
					<h2>Эластичные запросы</h2>
					<blockquote>
						С помощью функции запросов к эластичной базе данных можно выполнять запросы Transact-SQL для обращения сразу к нескольким
						базам данных в базе данных SQL Azure. Эта возможность позволяет создавать межбазовые запросы для доступа к удаленным
						таблицам. С помощью этой функции можно разворачивать запросы до уровней большого объема данных в базе данных SQL и
						визуализировать результаты в отчетах по бизнес-аналитике
					</blockquote>
				</section>
				<section>
					<h3>Преимущества эластичных запросов</h3>
					<ul>
						<li>Выполнение запросов к нескольким базам данных SQL Azure на языке T-SQL
						</li>
						<li>Доступно для всех тарифных планов без ограничения</li>
						<li>Эластичные запросы к удаленным базам данных теперь могут отправлять параметры SQL для выполнения
						</li>
						<li>Выполнение вызовов удаленных хранимых процедур или удаленных функций с помощью процедуры sp_execute _remote</li>
						<li>Эластичные запросов позволют внешним таблицам ссылаться на удаленные таблицы с разными именами схем или таблиц</li>
					</ul>
				</section>
				<section>
					<h3>Схема работы</h3>
					<img src="img/overview_sql.png" alt="">
					<!-- https://docs.microsoft.com/ru-ru/azure/sql-database/sql-database-elastic-query-overview -->
				</section>

			</section>
			<section>
				<section>
					<h2>Способы применения эластичных запросов</h2>
					<ul>
						<li>Вертикальное секционирование — межбазовые запросы (топология 1): вертикальное разделение данных между несколькими базами
							данных в рамках одного уровня. Например, все таблицы, связанные с данными инвентаризации, хранятся в одной базе данных,
							а таблицы, связанные с учетом, — в другой</li>
						<li>Горизонтальное секционирование — сегментирование (топология 2): горизонтальное разделение данных для распределения
							строк в рамках масштабируемого уровня данных. При таком подходе схемы всех включенных баз данных являются идентичными.
							Сегментирование может выполняться с помощью библиотеки средств эластичной базы данных или как самостоятельное сегментирование
						</li>
					</ul>
				</section>
				<section>
					<h3>Пример вертикального секционирования</h3>
					<img src="img/verticalpartitioning.png" alt="">
				</section>
				<section>
					<h3>Пример горизонтального секционирования</h3>
					<img src="img/horizontalpartitioning.png" alt="">
				</section>
				<section>
					<h3>Пример запроса</h3>
					<pre>
						<code class="hljs">
select  
     w_id as warehouse,
     o_c_id as customer,
     count(*) as cnt_orderline,
     max(ol_quantity) as max_quantity,
     avg(ol_amount) as avg_amount, 
     min(ol_delivery_d) as min_deliv_date
from warehouse 
join orders 
on w_id = o_w_id
join order_line 
on o_id = ol_o_id and o_w_id = ol_w_id 
where w_id > 100 and w_id < 200 
group by w_id, o_c_id 
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример</h2>
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/sql_1.png" alt="">
				</section>
				<section>
					<h3>Создание БД</h3>
					<img src="img/sql_2.png" alt="">
				</section>
				<section>
					<h3>Панель управления экземпляров</h3>
					<img src="img/sql_3.png" alt="">
				</section>
				<section>
					<h3>Выбор региона</h3>
					<img src="img/sql_4.png" alt="">
				</section>
				<section>
					<h3>Строка подключения</h3>
					<img src="img/sql_5.png" alt="">
				</section>
			</section>
			<section>
				<h1>Azure DocumentDB</h1>
			</section>

			<section>
				<h2>Определение</h2>
				<blockquote>
					Полностью управляемая служба баз данных NoSQL, созданная для быстрой и прогнозируемой работы, высокой доступности, гибкого
					масштабирования, глобального распространения данных и простоты разработки
				</blockquote>
				<blockquote>
					DocumentDB — это служба баз данных NoSQL без схемы, обеспечивающая широкие возможности запросов SQL со знакомым синтаксисом,
					согласованность и небольшую продолжительность задержек для данных JSON: 99 % операций чтения обрабатываются менее 10
					миллисекунд, а 99 % операций записи — менее 15 миллисекунд
				</blockquote>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/documentdb.png" alt="" height="500">
			</section>
			<section>
				<section>
					<h2>Особенности</h2>
					<ul>
						<li>Гибко масштабируемые пропускная способность и объем хранения - база данных легко масштабируется в соответствии с потребностями,
							хранятся на SSD, поддерживает контейнеры для хранения данных JSON, практически неограниченный размеров хранилища и
							пропускная способность
						</li>
						<li>Репликация между несколькими регионами - позволяет разрабатывать приложения, которым требуется глобальный доступ к
							данным, при этом обеспечивая компромиссы между согласованностью, доступностью и производительностью с соответствующими
							гарантиями
						</li>
						<li>Классический SQL-синтаксис</li>
						<li>Безблокировочную технологию индексирования с высокой степенью параллелизма и структурированием журналов для автоматического
							индексирования содержимого JSON документов</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Настраиваемые уровни согласованности — 4 уровня согласованности: strong (сильная), bounded-staleness (ограниченная),
							session (уровень сеанса) и eventual (согласованная в конечном счете)</li>
						<li>Полная управляемость - отсутствие необходимости управления БД и вычислительными ресурсами. Автоматическое сохранение
							и защита от региональных сбоев
						</li>
						<li>
							Открытая структура - получение доступа ко всей функциональности БД (CRUD, запросы и обработку JS) через REST API
						</li>
						<li>Выполнение операторов (DML) из кода JS в изолированной транзакции</li>
						<li>Выполнение JS в БД — реализация логики приложения в виде хранимых процедур, триггеров и пользовательских функций (UDF),
							использующих стандартный JS</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Все ресурсы в DocumentDB моделируются и хранятся в виде документов JSON</li>
						<li>Ресурсы управляют элементами (документы JSON и метаданные) и потоками (коллекции элементов). Наборы элементов содержатся
							внутри соответствующих потоков</li>
						<li>Учетная запись базы данных состоит из набора баз данных, каждая из которых содержит несколько коллекций
						</li>
						<li>Коллекция содержит хранимые процедуры, триггеры, определяемые пользователем функции, документы и соответствующие вложения
						</li>
						<li>БД включает связанных с ней пользователей, каждый из которых обладает набором разрешений для доступа к коллекциям,
							хранимым процедурам, триггерам, определяемым пользователем функциям, документам и вложениям</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Запросы SQL</h2>
				<ul>
					<li>Специальный итерфейс для запроса документов JSON</li>
					<li>Язык поддерживает грамматику подмножества ANSI SQL и добавляет глубокую интеграцию объектов, массивов, создания объектов
						и вызова функций JS</li>
					<li>Предоставляет свою модель запросов без явных схем или подсказок индексации от разработчика</li>
					<li>Пользовательские функции (UDF) могут быть зарегистрированы в DocumentDB, и ссылаться на них можно как на часть SQL-запроса,
						тем самым расширяя грамматику для поддержки логики пользовательского приложения</li>
					<li>Пользовательские функции записываются в виде программ JS и выполняются в базе данных</li>
					<li>Для .NET DocumentDB предоставляет поставщик запросов LINQ в составе пакета SDK</li>
				</ul>
			</section>
			<section>
				<h2>Транзакции и выполнение JavaScript</h2>
				<ul>
					<li>JavaScript может быть зарегистрирован для выполнения в качестве триггера, хранимой процедуры или пользовательской функции
						(UDF)
					</li>
					<li>Триггеры и хранимые процедуры могут создавать, читать, обновлять и удалять документы, в то время как определяемые пользователем
						функции выполняются в рамках логики выполнения запроса без доступа на запись в коллекции</li>
					<li>Выполнение JavaScript в DocumentDB моделируется по принципам, поддерживаемым реляционными СУБД, с JavaScript в качестве
						современной замены Transact-SQL</li>
					<li> Вся логика JavaScript выполняется в транзакции ACID с изоляцией моментального снимка. В ходе его исполнения, если код
						JavaScript генерирует исключение, то вся транзакция прерывается</li>
				</ul>
			</section>
			<section>
				<h2>Коллекции</h2>
				<blockquote>
					Коллекция DocumentDB — контейнер для документов JSON, является единицей масштабирования для транзакций и запросов
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Особенности</h2>
					<ul>
						<li>Гибкое хранилище документов на базе SSD - коллекция автоматически увеличивается и уменьшается по мере добавления или
							удаления документов</li>
						<li>Автоматическое секционирование - число секций в коллекции определяется по размеру хранилища и пропускной способности,
							выделенных для коллекции</li>
						<li>Автоматическое индексирование - автоматическая индексация документов, не требующая указания схемы или вторичных индексов
							и доступна благодаря оптимизации записи, безблокировочной и оптимизированной журнально-структурированной технологии
							обслуживания индексов</li>
						<li>Настраиваемые политики индексирования - позволяет настроить соотношения объема и производительности для интервала и
							хэш-запросов для конкретных шаблонов пути</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Изначально секционирует данные для обеспечения высокой доступности и масштабируемости</li>
						<li>Хранилище на базе SSD с низкой задержкой и временем ответа</li>
						<li>Поддержка уровней согласованности, таких как bounded-staleness (ограниченная), session (уровень сеанса) и eventual
							(согласованная в конечном счете), обеспечивает оптимальное соотношение затрат и производительности</li>
						<li>Гибкая модель ценообразования, в которой место для хранения и пропускная способность измеряются независимо
						</li>
						<li>Модель зарезервированной пропускной способности DocumentDB позволяет вести учет по количеству операций чтения и записи,
							а не по ресурсам ЦП, памяти и операций ввода-вывода базового оборудования</li>
					</ul>
				</section>
			</section>

			<!--<section>
					https://github.com/Microsoft/azure-docs.ru-ru/blob/master/articles/documentdb/documentdb-sql-query.md
				</section>-->

			<section>
				<section>
					<h2>Пример</h2>
				</section>
				<section>
					<h3>Структура документа</h3>
					<pre>
						<code class="hljs">
{
    "id": "AndersenFamily",
    "lastName": "Andersen",
    "parents": [
       { "firstName": "Thomas" },
       { "firstName": "Mary Kay"}
    ],
    "children": [
       {
           "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
           "pets": [{ "givenName": "Fluffy" }]
       }
    ],
    "address": { "state": "WA", "county": "King", "city": "seattle" },
    "creationDate": 1431620472,
    "isRegistered": true
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Запрос 1</h3>
					<pre>
						<code class="hljs">
SELECT * FROM Families f 
         WHERE f.id = "AndersenFamily";
						</code>
					</pre>
				</section>
				<section>
					<h3>Результат</h3>
					<pre>
						<code class="hljs">
[{
    "id": "AndersenFamily",
    "lastName": "Andersen",
    "parents": [
       { "firstName": "Thomas" },
       { "firstName": "Mary Kay"}
    ],
    "children": [
       {
           "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
           "pets": [{ "givenName": "Fluffy" }]
       }
    ],
    "address": { "state": "WA", "county": "King", "city": "seattle" },
    "creationDate": 1431620472,
    "isRegistered": true
}]
						</code>
					</pre>
				</section>
				<section>
					<h3>Запрос 2</h3>
					<pre>
						<code class="hljs">
SELECT {"Name":f.id, "City":f.address.city} AS Family 
       FROM Families f 
       WHERE f.address.city != f.address.state
						</code>
					</pre>
				</section>
				<section>
					<h3>Результат</h3>
					<pre>
						<code class="hljs">
[{
    "Family": {
        "Name": "AndersenFamily", 
        "City": "seattle"
    }
}]
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример</h2>
				</section>
				<section>
					<h3>Панель управления экземплярами</h3>
					<img src="img/nosql_1.png" alt="">
				</section>
				<section>
					<h3>Создание БД</h3>
					<img src="img/nosql_2.png" alt="">
				</section>
				<section>
					<h3>Панель упраления экземпляром</h3>
					<img src="img/nosql_3.png" alt="">
				</section>
				<section>
					<h3>Выбор SDK</h3>
					<img src="img/nosql_4.png" alt="">
				</section>
				<section>
					<h3>Создание коллекции</h3>
					<img src="img/nosql_5.png" alt="">
				</section>
				<section>
					<h3>Упраление коллекцией</h3>
					<img src="img/nosql_6.png" alt="">
				</section>
				<section>
					<h3>Ключи</h3>
					<img src="img/nosql_7.png" alt="">
				</section>
			</section>
			<section>
				<h1>Virtual Network</h1>
			</section>
			<section>
				<h2>Определение</h2>
				<blockquote>
					Виртуальная сеть (VNet) Azure — это представление сети в облаке. Это логическая изоляция облака Azure, выделенного по подписке
					с возможностью полного контроля блоков IP-адресов, параметров DNS, политик безопасности и таблиц маршрутизации
				</blockquote>
			</section>
			<section>
				<h2>Схема локальной сети</h2>
				<img src="img/classic_network.png" alt="" height="550">
			</section>
			<section>
				<h2>Схема виртуальной сети</h2>
				<img src="img/azure_network.png" alt="" height="550">
			</section>
			<section>
				<h2>Преимущества виртуальных сетей</h2>
				<ul>
					<li>Изоляция - сети изолированы друг от друга. Позволяет создавать отдельные сети для разработки, тестирования и эксплуатации,
						использующие одинаковые блоки адресов CIDR</li>
					<li>Доступ к Интернету - интернет доступен по умолчанию для ВМ IaaS и экземпляров PaaS. Контроль доступа на основе групп
						безопасности сети</li>
					<li>Доступ в виртуальной сети - PaaS и IaaS могут запускаться в одной виртуальной сети и подключаться друг к другу с помощью
						частных IP, даже если они находятся в разных подсетях, без шлюзов, пиринга и общедоступных IP</li>
					<li>Разрешение имен - автоматическое разрешение имен. Можно развернуть собственные DNS-серверы
					</li>
					<li>Подключение - виртуальные сети подключаются к локальным ЦОД через VPN "сеть—сеть" или Azure ExpressRoute</li>
				</ul>
			</section>
			<section>
				<h2>Типы IP-адресов в виртуальной сети</h2>
				<ul>
					<li>Общедоступные - позволяют ресурсам Azure подключаться к Интернету и другим общедоступным службам Azure, таким как кэш
						Redis для Azure и концентраторы событий Azure</li>
					<li>Частные - обеспечивают связь между ресурсами в виртуальной сети, а также теми, которые подключаются через VPN, без использования
						IP-адресов с поддержкой маршрутизации в Интернет</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Общедоступные IP-адреса</h2>
					<ul>
						<li>Виртуальные машины</li>
						<li>Балансировщики нагрузки, доступные в Интернете</li>
						<li>VPN-шлюзы</li>
						<li>Шлюзы приложений</li>
					</ul>
				</section>
				<section>
					<h3>Способ выделения</h3>
					<ul>
						<li>Динамический (по умолчанию) - IP-адрес выделяется когда клиент запускает (или создает) связанный ресурс (ВМ, балансировщик
							нагрузки и т.д.). Если остановить или удалить ресурс, IP-адрес освобождается. При перезапуске ресурса адрес изменяется</li>
						<li>Статический - IP-адрес назначается немедленно и освобождается только тогда, когда клиент удаляете ресурс или задаете
							динамический способ выделения. Используется, если IP-адрес связанного ресурса не должен изменяться</li>
					</ul>
				</section>
				<section>
					<h3>Причины использования статических адресов</h3>
					<ul>
						<li>Конечным пользователям необходимо обновлять правила брандмауэра для взаимодействия с ресурсами Azure</li>
						<li>Разрешение DNS-имени, в рамках которого изменение IP-адреса влечет за собой необходимость обновить записи A</li>
						<li>Ресурсы Azure взаимодействуют с другими веб-приложениями или службами, которые используют модель безопасности, основанную
							на IP-адресах</li>
						<li>Клиент использует SSL-сертификаты, связанные с IP-адресом</li>
					</ul>
				</section>
				<section>
					<h3>Ценовая политика</h3>
					<blockquote>
						В большинстве случаев общедоступные IP-адреса бесплатны. Существует номинальная плата за использование дополнительных или
						статических общедоступных IP-адресов
					</blockquote>
				</section>
				<section>
					<h3>Итого</h3>
					<table>
						<thead>
							<tr>
								<th>Ресурс</th>
								<th>Связанный IP</th>
								<th>Дин.</th>
								<!-- динамический и статический -->
								<th>Ст.</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Виртуальная машина</td>
								<td>Сетевой интерфейс</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Подсистема балансировки нагрузки</td>
								<td>Конфигурация клиентской части </td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>VPN-шлюз</td>
								<td>Конфигурация IP шлюза</td>
								<td>+</td>
								<td>-</td>
							</tr>
							<tr>
								<td>Шлюз приложений</td>
								<td>Конфигурация клиентской части</td>
								<td>+</td>
								<td>-</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Частные IP-адреса</h2>
					<blockquote>
						Частный IP-адрес выделяется из диапазона адресов подсети, к которой подключен ресурс
					</blockquote>
					<ul>
						<li>Виртуальные машины</li>
						<li>Внутренние балансировщики нагрузки</li>
						<li>Шлюзы приложений</li>
					</ul>
				</section>
				<section>
					<h3>Способ выделения</h3>
					<ul>
						<li>Динамический (по умолчанию) - IP-адрес выделяется из подсети ресурса через протокол DHCP. Во время остановки и запуска
							ресурса этот IP-адрес изменяется</li>
						<li>Статический - необходимо указать допустимый IP-адрес, который является частью подсети ресурса. Не изменяется при перезапуске
							ресурса
						</li>
					</ul>
				</section>
				<section>
					<h3>Причины использования частных статических адресов</h3>
					<ul>
						<li>Для виртуальных машин, работающих в качестве контроллеров домена или DNS-серверов</li>
						<li>Для ресурсов, в которых правилам брандмауэра нужно использовать IP-адреса</li>
						<li>Для ресурсов, доступ к которым другие приложения и другие ресурсы получают через IP-адрес</li>
					</ul>
				</section>
				<section>
					<h3>Итого</h3>
					<table>
						<thead>
							<tr>
								<th>Ресурс</th>
								<th>Связанный IP</th>
								<th>Дин.</th>
								<th>Ст.</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Виртуальная машина</td>
								<td>Сетевой интерфейс</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>Подсистема балансировки нагрузки</td>
								<td>Конфигурация клиентской части</td>
								<td>+</td>
								<td>+</td>
							</tr>
							<tr>
								<td>шлюзу приложений</td>
								<td>Конфигурация клиентской части</td>
								<td>+</td>
								<td>+</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Подсети</h2>
					<blockquote>
						Подсеть — это диапазон IP-адресов в виртуальной сети. Виртуальную сеть можно разделить на несколько подсетей для организационного
						удобства и безопасности. Имеется механизм настройки таблиц маршрутизации и групп безопасности сети для подсети
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Автоматическое связывание - ВМ и другие компоненты связываются между собой атоматически даже если они находяься в разных
							подсетях, не нужно указывать шлюз</li>
						<li>Автоматическое подключение через Интернет</li>
						<li>Автоматическое подключение в локальной сети (при наличии гибридного подключения Azure к локальному ЦОД)</li>
						<li>Ипользование системных маршрутов для определения передачи IP-трафика</li>
					</ul>
				</section>
				<section>
					<h3>Случаи применение системных маршрутов</h3>
					<ul>
						<li>В одной и той же подсети</li>
						<li>Из одной подсети в другую в виртуальной сети</li>
						<li>Из виртуальных машин в Интернет</li>
						<li>Из одной виртуальной сети в другую через VPN-шлюз</li>
						<li>Из виртуальной сети в локальную сеть через VPN-шлюз</li>
					</ul>
				</section>
				<section>
					<h3>Правила системных марсшрутов</h3>
					<ul>
						<li>Локальное правило виртуальной сети - правило создается автоматически для каждой подсети в виртуальной сети. Указывает,
							что существует прямая связь между виртуальными машинами в виртуальной сети, без промежуточного следующего прыжка
						</li>
						<li>Правило локальной среды - правило применяется для всего трафика, предназначенного для локального диапазона адресов;
							использует VPN-шлюз в качестве назначения следующего прыжка</li>
						<li>Правило Интернета - правило обрабатывает весь трафик, направляемый в общедоступный Интернет (префикс адреса 0.0.0.0/0).
							Использует шлюз Интернета инфраструктуры в качестве следующего прыжка для всего трафика, предназначенного для Интернета
						</li>
					</ul>
				</section>
				<section>
					<h3>Пример 1</h3>
					<img src="img/system_network.png" alt="" height="550">
					<!-- На следующем рисунке показан пример определяемых пользователем маршрутов и IP-пересылки для принудительной отправки пакетов, передаваемых из одной подсети во вторую подсеть, в виртуальным модуль в третьей подсети. -->
				</section>
				<section>
					<h3>Пример 2</h3>
					<img src="img/user_network.png" alt="" height="550">
				</section>
			</section>
			<section>
				<section>
					<h2>Пользовательский маршрут</h2>
					<blockquote>
						Принудительное туннелирование для доступа к Интернету виртуальных устройств в среде Azure через локальную сеть клиента
					</blockquote>
					<blockquote>
						Инфраструктура предоставляет возможности пользователю создавать свою таблицу маршрутов. Можно использовать несколько таблиц
						маршрутов, и одна таблица маршрутов может быть связана с одной или несколькими подсетями. НО каждая подсеть может быть
						связана только с одной таблицей маршрутов!
					</blockquote>
				</section>
				<section>
					<h3>Принцип работы</h3>
					<ol>
						<li>Пока c подсетью не связана таблица маршрутов, она использует системные маршруты</li>
						<li>После установления связи маршрутизация выполняется по совпадению наиболее длинного префикса (LPM) среди определяемых
							пользователем маршрутов и системных маршрутов</li>
						<li>При наличии более одного маршрута с одинаковыми совпадающими значениями LPM маршрут выбирается по источнику в следующем
							порядке: 1) определяемый пользователем маршрут; 2) маршрут BGP (если используется ExpressRoute); 3) Системные маршруты</li>
					</ol>
				</section>
			</section>
			<section>
				<section>
					<h2>Пиринг</h2>
				</section>
				<section>
					<h3>Определение</h3>
					<blockquote>
						Пиринговая связь между виртуальными сетями — механизм подключения между двумя виртуальными сетями, находящимися в одном регионе,
						через магистральную сеть Azure. После создания пиринговой связи две виртуальные сети выглядят как одна при любом подключении.
						Они по-прежнему управляются как отдельные ресурсы, но теперь находящиеся в них виртуальные машины могут взаимодействовать
						друг с другом напрямую через частные IP-адреса
					</blockquote>
				</section>
				<section>
					<h3>Преимущества</h3>
					<ul>
						<li>Подключение между ресурсами в разных виртуальных сетях, характеризующееся низкой задержкой и высокой пропускной способностью</li>
						<li>Возможность использовать ресурсы, такие как сетевые устройства и VPN-шлюзы, в качестве транзитных точек в пиринговой
							виртуальной сети</li>
						<li>Возможность подключения виртуальной сети, в которой используется модель Azure Resource Manager, к виртуальной сети,
							в которой используется классическая модель развертывания, с обеспечением полной связи между ресурсами в этих виртуальных
							сетях
						</li>
					</ul>
				</section>
				<section>
					<h3>Требования</h3>
					<ul>
						<li>Две виртуальные сети должны находиться в одном регионе</li>
						<li>Для настройки пиринговой связи пространства IP-адресов используемых виртуальных сетей не должны перекрываться</li>
						<li>Пиринговая связь устанавливается между двумя виртуальными сетями. Производные переходные связи не поддерживаются
							<!--(А имеет свзяь с B, B - с С, A не имеет свзяь с С)-->
						</li>
						<li>Пиринговую связь можно установить между виртуальными сетями в двух разных подписках, если ее разрешает привилегированный
							пользователь обеих подписок и подписки связаны с одним и тем же клиентом Active Directory</li>
						<li>Для обмена данными между ВМ в пиринговых виртуальных сетях нет дополнительных ограничений пропускной способности, НО
							объем передаваемого трафика ограничивается размером ВМ</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<img src="img/piring.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Сетевые интерфейсы</h2>
				</section>
				<section>
					<h3>Определение</h3>
					<blockquote>
						Сетевой интерфейс обеспечивает взаимодействие между виртуальной машиной и сетью с базовым программным обеспечением
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Это ресурс, который можно создать, настроить, удалить</li>
						<li>При создании должен быть подключен к одной подсети в одной виртуальной сети. Для созданного интерфейса можно изменить
							подсеть, но нельзя изменить виртуальную сеть</li>
						<li>Имеет назначенное имя, которое нельзя изменить после создания. Имя должно быть уникальным в пределах группы ресурсов
							Azure, но не обязательно уникальным в пределах подписки, расположения Azure или виртуальной сети, к которой он подключен.
							В одной подписке может быть создано несколько интерфейсов</li>
						<li>Может быть подключен к виртуальной машине, но только к одной и обязательно созданной в том же расположении, что и сам
							сетевой интерфейс</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Имеет MAC-адрес, который закрепляется за сетевым интерфейсом до тех пор, пока он подключен к виртуальной машине. Сохраняется
							при перезапуске ВМ (с помощью функций ОС) или при остановке (освобождении) с последующим запуском через портал</li>
						<li>Должен иметь один основной частный (статический или динамический) IPv4</li>
						<li>Может иметь один присвоенный общедоступный IP-адрес</li>
						<li>Поддерживает ускорение сети с технологией виртуализации операций ввода-вывода с единым корнем (SR-IOV) для ВМ с ОС
							Windows Server</li>
						<li>Может получать трафик, не предназначенный для присвоенных ему частных IP-адресов, если для этого сетевого интерфейса
							включена IP-пересылка</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример</h2>
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/vn_1.png" alt="">
				</section>
				<section>
					<h3>Параметры</h3>
					<img src="img/vn_2.png" alt="">
				</section>
				<section>
					<h3>Обзор виртуальной сети</h3>
					<img src="img/vn_3.png" alt="">
				</section>
			</section>
			<!-- END Virtual Network -->
			<section>
				<h1>Service Bus</h1>
			</section>
			<section>
				<h2>Сервисная шина предприятия</h2>
				<blockquote>
					Сервисная шина предприятия (enterprise service bus) — связующее программное обеспечение, обеспечивающее централизованный
					и унифицированный событийно-ориентированный обмен сообщениями между различными информационными системами на принципах
					сервис-ориентированной архитектуры
				</blockquote>
			</section>
			<section>
				<h2>Назначение</h2>
				<ul>
					<li>Концентрация обмена сообщениями между различными системами через единую точку</li>
					<li>Обеспечивается транзакционный контроль</li>
					<li>Единым механизм преобразование данных </li>
					<li>Единый механиз обеспечения сохранности сообщений</li>
				</ul>
			</section>
			<section>
				<h2>Основные характеристики</h2>
				<ul>
					<li>Поддержка синхронного и асинхронного способа вызова служб</li>
					<li>Использование защищенного транспорта, с гарантированной доставкой сообщений, поддерживающего транзакции</li>
					<li>Статическая и алгоритмическая маршрутизация сообщений</li>
					<li>Доступ к данным из сторонних информационных систем с помощью специально разработанных адаптеров</li>
					<li>Обработка и преобразование сообщений</li>
					<li>Оркестровка служб (описывает как сервисы должны взаимодействовать между собой, используя для этого обмен сообщениями,
						включая бизнес-логику и последовательность действий)</li>
					<li>Разнообразные механизмы контроля и управления (аудиты, протоколирование)</li>
				</ul>
			</section>
			<section>
				<h2>Способы работы</h2>
				<ul>
					<li>Синхронный - потребитель использует один поток для вызова службы; поток передает запрос, блокируется на время выполнения
						службы и ждет ответ. Если у потребителя возникает аварийная ситуация во время блокирования при работе службы, нельзя
						повторно подключиться к этой службе после перезапуска, поэтому ответ теряется</li>
					<li>Асинхронный - потребитель использует два потока для вызова службы; один - для передачи запроса, второй – для приема
						ответ. Если у потребителя возникает аварийная ситуация во время ожидания ответа на запрос, после перезапуска потребитель
						может продолжать ожидать ответ, ответ не теряется</li>
				</ul>
			</section>
			<section>
				<h2>Примеры программных продуктов</h2>
				<ul>
					<li>Active Directory</li>
					<li>UDDI</li>
					<li>BizTalk Server</li>
					<li>MSMQ</li>
					<li>WCF</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Пример схем использований</h2>
				</section>
				<section>
					<h3>Схема канала точка-точка</h3>
					<img src="img/точка_точка.png" alt="" height="550">
				</section>
				<section>
					<h3>Схема канала публикация-подписка</h3>
					<img src="img/публикация_подписка.png" alt="" height="500">
				</section>
				<section>
					<h3>Схема канала недоставленных сообщений</h3>
					<img src="img/недоставленное_сообщение.png" alt="" height="500">
				</section>
				<section>
					<h3>Схема гарантированной доставки</h3>
					<img src="img/гарантированная_доставка.png" alt="" height="500">
				</section>
				<section>
					<h3>Схема шины сообщений</h3>
					<img src="img/шина_сообщений.png" alt="" height="500">
				</section>
			</section>
			<section>
				<!-- https://msdn.microsoft.com/ru-ru/library/ee872418.aspx -->
				<h2>Пример схемы функционирования ПО</h2>
				<img src="img/servicebus_scheme.jpg" alt="" height="400">
			</section>
			<section>
				<h1>Очередь сообщений</h1>
			</section>
			<section>
				<section>
					<h2>Причины использования</h2>
					<ul>
						<li>Слабое связывание — создают неявные интерфейсы обмена данными (приложения независимыми друг от друга)</li>
						<li>Избыточность — позволяют избежать случаев неэкономного использования ресурсов процесса в результате хранения необработанной
							информации
						</li>
						<li>Масштабируемость — позволяют распределить процессы обработки информации. Увеличивается скорость, с которой сообщения
							добавляются в очередь и обрабатываются</li>
						<li>Эластичность — выполняют роль буфера для накопления данных в случае пиковой нагрузки, и не допуская отказа системы</li>
						<li>Отказоустойчивость — позволяют отделить процессы друг от друга. Если процесс, обрабатывающий сообщение, падает, то
							сообщения могут быть добавлены в очередь позднее, когда система восстановится</li>
					</ul>
				</section>
				<section>
					<h3>Причины использования</h3>
					<ul>
						<li>Гарантированная доставка — сообщение будет доставлено и обработано в любом случае</li>
						<li>Гарантированный порядок доставки — гарантии того, что данные будут обрабатываться в определённом порядке (чаще всего
							в том порядке в котором они поступили)</li>
						<li>Буферизация — позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный
							слой
						</li>
						<li>Понимание потоков данных — позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая
							из очередей забивается, какая простаивает и т.д.</li>
						<li>Асинхронная связь — возможность асинхронной обработки данных, которая позволяет поместить сообщение в очередь без обработки,
							позволяя системе обработать сообщение позднее, когда появится возможность
						</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Область применения</h2>
				<ul>
					<li>Обработка данных</li>
					<li>Буферизация потоков данных</li>
					<li>Управление процессами</li>
					<li>Интеграция и взаимодействие систем</li>
				</ul>
			</section>
			<section>
				<h2>Примеры очередей</h2>
				<ul>
					<li>RabbitMQ</li>
					<li>MSMQ</li>
					<li>Amazon SQS</li>
					<li>IronMQ</li>
					<li>StormMQ</li>
					<li>Azure Queues</li>
				</ul>
			</section>
			<!-- -->
			<section>
				<h1>Microsoft Message Queue</h1>
			</section>
			<section>
				<h2>Определение</h2>
				<blockquote>
					Технология предоставляет приложениям, выполняющимся в разное время, возможность обмениваться информацией, не принимая во
					внимание гетерогенность сетей и операционных систем, которые могут быть временно недоступны. MSMQ обеспечивает гарантированную
					доставку сообщений, эффективную маршрутизацию, безопасность и передачу сообщений на основе приоритетов. Служба может
					использоваться в программных решениях, основанных на асинхронном и синхронном способе доставки сообщений
				</blockquote>
			</section>
			<section>
				<h2>История развития</h2>
				<ul>
					<li>Версия 1.0 (Windows 95) - базовые возможности</li>
					<li>Версия 2.0 (Windows 2000) - поддержка Active Directory, 128-шифрование, цифровые сертификаты, работа с многопоточными
						приложениями
					</li>
					<li>Версия 3.0 (Windows XP) - Internet Messaging (HTTP, SOAP), поддержка IIS, мультикаст сообщений</li>
					<li>Версия 4.0 (Windows Vista) - поддержка транзакий для удаленных очередей</li>
					<li>Версия 5.0 (Windows 7) - поддержка SHA 2 и других хеш-алгоритмов</li>
					<li>Вепсия 6.0 (Windows 8)</li>
					<li>Версия 10.0 (Windows 8.1)</li>
					<li>Версия 13.0 (Windows 10)</li>
				</ul>
			</section>
			<section>
				<h2>Функциональные возможности</h2>
				<ul>
					<li>Сообщения могут пересылаться в автономной среде. То есть приложению-отправителю и приложению-получателю вовсе не обязательно
						выполняться в одно и то же время</li>
					<li>В экспресс-режиме сообщения могут пересылаться очень быстро за счет сохранения в памяти</li>
					<li>Для механизма восстановления сообщения могут отправляться с гарантированной доставкой. Такие сообщения сохраняются в
						файлах и доставляются даже в случае перезагрузки сервера</li>
					<li>Очереди могут защищаться с применением списков контроля доступа и указания в них, каким пользователям разрешено отправлять
						или получать сообщения из очереди. Сообщения могут шифроваться, а также снабжаться приоритетами, чтобы те из них, которые
						имеют более высокий приоритет, обрабатывались быстрее</li>
				</ul>
			</section>
			<section>
				<h2>Порты по умолчанию</h2>
				<ul>
					<li>TCP: 1801</li>
					<li>RPC: 135, 2101, 2103, 2105</li>
					<li>UDP: 3527, 1801</li>
				</ul>
			</section>
			<section>
				<h2>Продукты Message Queuing</h2>
				<ul>
					<li>Microsoft Message Queue Server Core - основные компоненты сервера очереди сообщений, которые необходимы для получения
						базовой функциональности Message Queuing</li>
					<li>Active Directory Domain Services Integration - интеграция MSMQ с Active Directory. Позволяет записывать имена очередей
						сообщений, находить нужные очереди в AD и защищать их на основе пользователей и групп пользователей Windows</li>
					<li>MSMQ HTTP Support - поддержка протокола HTTP MSMQ</li>
					<li>Triggers - с помощью триггеров создаются экземпляры приложений при поступлении нового сообщения</li>
					<li>Multicast Support - поддержка многоадресной рассылки. Позволяет отправлять сообщения группам серверов</li>
					<li>MSMQ DCOM Proxy - система может подключаться к удаленному серверу, используя API-интерфейс DCOM</li>
				</ul>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/MSMQ_7.gif" alt="" height="500">
			</section>
			<section>
				<section>
					<h2>Настройка MSMQ</h2>
				</section>
				<section>
					<h3>Включение или отключение компонентов</h3>
					<img src="img/MSMQ_1.png" alt="">
				</section>
				<section>
					<h3>Службы</h3>
					<img src="img/MSMQ_2.png" alt="">
				</section>
				<section>
					<h3>Панель упраления</h3>
					<img src="img/MSMQ_3.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Типы очередей</h2>
					<ul>
						<li>Общедоступная очередь - публикуется в AD. Можно обращаться, не зная имени компьютера</li>
						<li>Частные очереди - не публикуются в AD. Доступны только по полному путевому имени</li>
						<li>Журнальные очереди - сохраняют копий сообщений после того, как они были получены или отправлены</li>
						<li>Очереди мертвых писем - сообщения, которые не были доставлены за определенный период времени</li>
						<li>Административные очереди - содержат подтверждения об успешно отправленных сообщениях</li>
						<li>Очередь ответов - особый вариант подтверждения (принимающее приложение может посылать ответные сообщения отправителю)</li>
						<li>Очередь отчетов - тестирование и отслеживание маршрутов</li>
						<li>Системные очереди - используются MSMQ для административных сообщений, хранения уведомлений и обеспечения правильного
							порядка доставки транзакционных сообщений</li>
					</ul>
				</section>
				<section>
					<h3>Создание очереди</h3>
					<img src="img/MSMQ_5.png" alt="">
				</section>
			</section>
			<section>
				<h2>Структура сообщения</h2>
				<ul>
					<li>Метка - заголовок сообщения</li>
					<li>Тело - пересылаемые данные</li>
					<li>Дополнительная информация - отправитель, конфигурация таймаута, идентификатор транзакции, приоритет</li>
				</ul>
			</section>
			<section>
				<h2>Типы сообщений</h2>
				<ul>
					<li>Нормальное сообщение - отправляется любым приложением</li>
					<li>Подтверждающее сообщение - уведомляет о состоянии нормального сообщения. Подтверждающие сообщения отправляются в административные
						очереди, чтобы уведомить об успехе или сбое при отправке нормальных сообщений</li>
					<li>Ответные сообщения - отправляются принимающим приложением, когда исходный отправитель требует некоторого специального
						ответа
					</li>
					<li>Отчетные сообщения - генерируются системой Message Queuing. К этой категории относятся тестовые сообщения и сообщения
						отслеживания маршрутизации</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Свойства сообщения</h2>
					<ul>
						<li>Label - имя очереди, которое используется для ее поиска</li>
						<li>Type ID - используется для отображения множественных очередей на единственную категорию типа (по умолчанию {00000000-0000-0000-0000-000000000000})</li>
						<li>Authenticated - позволяет записывать и читать сообщения в очереди только аутентифицированным пользователям</li>
						<li>Privacy Level - позволяет шифровать содержимое сообщения. Значения: None, Optional или Body</li>
						<li>Journal - обеспечивается сохранение в журнале копий принятых сообщений</li>
						<li>Multicast - оппределяет групповой IP-адрес для очереди</li>
					</ul>
				</section>
				<section>
					<h3>Пример интерфейса</h3>
					<img src="img/MSMQ_4.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Класс MessageQueue</h2>
				</section>
				<section>
					<h3>Основные методы</h3>
					<table>
						<tr>
							<td>Create</td>
							<td>создает очередь по определенному пути</td>
						</tr>
						<tr>
							<td>GetPrivate QueuesByMachine
							</td>
							<td>нахождение приватных очередей по путевому либо форматному имени</td>
						</tr>
						<tr>
							<td>Exists</td>
							<td>проверка существования очереди</td>
						</tr>
						<tr>
							<td>Delete</td>
							<td>удаление очереди</td>
						</tr>
						<tr>
							<td>Send</td>
							<td>отправка сообщение в очередь</td>
						</tr>
						<tr>
							<td>Receive</td>
							<td>извлекает певое сообщение из очереди</td>
						</tr>
						<tr>
							<td>GetAllMessages</td>
							<td>получает все сообщения из очереди</td>
						</tr>
						<tr>
							<td>Peek</td>
							<td>получает сообщение без его извлечения</td>
						</tr>
						<tr>
							<td>PeekById</td>
							<td>получение сообщения из очереди по Id, но не извлекает его</td>
						</tr>
						<tr>
							<td>Purge</td>
							<td>удаляет все сообщения из очереди</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Метод Create</h3>
					<pre>
						<code class="hljs">
public static MessageQueue Create(string path);
public static MessageQueue Create(string path, bool transactional);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = MessageQueue.Create(".\\private$\\MyNewPrivateQueue");
						</code>
					</pre>
				</section>
				<section>
					<h3>Имена каналов</h3>
					<table>
						<tr>
							<td>Public</td>
							<td>{Имя машины}\{Имя очереди}</td>
						</tr>
						<tr>
							<td>Private</td>
							<td>{Имя машины}\Private$\{Имя очереди}</td>
						</tr>
						<tr>
							<td>Journal</td>
							<td>{Имя машины}\{Имя очереди}\Journal$</td>
						</tr>
						<tr>
							<td>Machine journal</td>
							<td>{Имя машины}\Journal$</td>
						</tr>
						<tr>
							<td>Machine dead-letter</td>
							<td>{Имя машины}\Deadletter$</td>
						</tr>
						<tr>
							<td>Machine transactional dead-letter</td>
							<td>{Имя машины}\XactDeadletter$</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Метод GetPrivateQueuesByMachine</h3>
					<pre>
						<code class="hljs">
public static MessageQueue[] GetPrivateQueuesByMachine(string machineName);
						</code>
					</pre>
					<pre>
						<code class="hljs">
foreach (var queue in MessageQueue.GetPrivateQueuesByMachine(Environment.MachineName))
                Console.WriteLine("Очередь: {0}\n", queue.Path);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Exists</h3>
					<pre>
						<code class="hljs">
public static bool Exists(string path);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queueName = @".\private$\MyPrivateQueue";

if (MessageQueue.Exists(queueName))
{
    var queue = new MessageQueue(queueName);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Delete</h3>
					<pre>
						<code class="hljs">
public static void Delete(string path);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queueName = @".\private$\MyPrivateQueue";

if (MessageQueue.Exists(queueName))
{
    MessageQueue.Delete(queueName);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Send</h3>
					<pre>
						<code class="hljs">
public void Send(object obj);
public void Send(object obj, MessageQueueTransaction transaction);
public void Send(object obj, MessageQueueTransactionType transactionType);
public void Send(object obj, string label);
public void Send(object obj, string label, MessageQueueTransactionType transactionType);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
queue.Send("Sample Message", "Label");
						</code>
					</pre>
				</section>
				<section>
					<h3>Класс MessageQueueTransaction</h3>
					<pre>
						<code class="hljs">
    public class MessageQueueTransaction : IDisposable
    {
        public MessageQueueTransaction();
        ~MessageQueueTransaction();
        public MessageQueueTransactionStatus Status { get; }
        public void Abort();
        public void Begin();
        public void Commit();
        public void Dispose();
        protected virtual void Dispose(bool disposing);
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Receive</h3>
					<pre>
						<code class="hljs">
public Message Receive();
public Message Receive(MessageQueueTransactionType transactionType);
public Message Receive(MessageQueueTransaction transaction);
public Message Receive(TimeSpan timeout);
public Message Receive(TimeSpan timeout, Cursor cursor);
public Message Receive(TimeSpan timeout, MessageQueueTransactionType transactionType);
public Message Receive(TimeSpan timeout, MessageQueueTransaction transaction);
public Message Receive(TimeSpan timeout, Cursor cursor, MessageQueueTransactionType transactionType);
public Message Receive(TimeSpan timeout, Cursor cursor, MessageQueueTransaction transaction);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
var message = queue.Receive();				
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод GetAllMessages</h3>
					<pre>
						<code class="hljs">
public Message[] GetAllMessages();
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
var messages = queue.GetAllMessages();
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Peek</h3>
					<pre>
						<code class="hljs">
public Message Peek();
public Message Peek(TimeSpan timeout);
public Message Peek(TimeSpan timeout, Cursor cursor, PeekAction action);
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод PeekById</h3>
					<pre>
						<code class="hljs">
public Message PeekById(string id);
public Message PeekById(string id, TimeSpan timeout);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
var message = queue.PeekById("035e0464-4ed2-434d-95ce-f7ab1b2c8ff6\12");
						</code>
					</pre>
				</section>
				<section>
					<h3>Метод Purge</h3>
					<pre>
						<code class="hljs">
public void Purge();
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Класс Message</h2>
				</section>
				<section>
					<h3>Основные свойства</h3>
					<table>
						<tr>
							<td>ArrivedTime</td>
							<td>DateTime</td>
							<td>время прибытия в очередь назначения</td>
						</tr>
						<tr>
							<td>Authenticated</td>
							<td>bool</td>
							<td>проверяет, аутентифицировано ли сообщение (только геттер)</td>
						</tr>
						<tr>
							<td>Body</td>
							<td>object</td>
							<td>тело сообщения</td>
						</tr>
						<tr>
							<td>BodyStream</td>
							<td>Stream</td>
							<td>установка/получения тела сообщения через поток</td>
						</tr>
						<tr>
							<td>Formatter</td>
							<td>IMessageFormatter</td>
							<td>форматтер для сериализации/десериализации сообщения</td>
						</tr>
						<tr>
							<td>HashAlgorithm</td>
							<td>HashAlgorithm</td>
							<td>алгоритм для аутентификации</td>
						</tr>
					</table>
				</section>
				<section>
					<h3>Основные свойства</h3>
					<table>
						<tr>
							<td>Id</td>
							<td>string</td>
							<td>идентификатор сообщения в очереди (только геттер)</td>
						</tr>
						<tr>
							<td>Label</td>
							<td>string</td>
							<td>заголовок сообщения</td>
						</tr>
						<tr>
							<td>MessageType</td>
							<td>MessageType</td>
							<td>тип сообщения (Acknowledgment, Normal, Report)</td>
						</tr>
						<tr>
							<td>Priority</td>
							<td>MessagePriority</td>
							<td>приоритет сообщения</td>
						</tr>
						<tr>
							<td>SentTime</td>
							<td>DateTime</td>
							<td>время отправки</td>
						</tr>
						<tr>
							<td>TransactionId</td>
							<td>string</td>
							<td>идентификатор транзакции</td>
						</tr>
					</table>
				</section>

				<section>
					<h3>Приоритет сообщения</h3>
					<pre>
						<code class="hljs">
public enum MessagePriority
{
    Lowest = 0,
    VeryLow = 1,
    Low = 2,
    Normal = 3,
    AboveNormal = 4,
    High = 5,
    VeryHigh = 6,
    Highest = 7
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 1</h3>
					<pre>
						<code class="hljs">
Image myImage = Bitmap.FromFile("SentImage.bmp");

// присоединяемся к очереди на локальной машине
MessageQueue myQueue = new MessageQueue(".\\myQueue");

Message myMessage = new Message(myImage, new BinaryMessageFormatter());

// отправляем сообщение в очередь
myQueue.Send(myMessage);
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример 2</h3>
					<pre>
						<code class="hljs">
MessageQueue myQueue = new MessageQueue(".\\myQueue");

// устанавливаем форматтер для сообщения
myQueue.Formatter = new BinaryMessageFormatter();

// получаем сообщение 
System.Messaging.Message myMessage = myQueue.Receive(); 
Bitmap myImage = (Bitmap)myMessage.Body;

// сохраняем результат
myImage.Save("ReceivedImage.bmp",System.Drawing.Imaging.ImageFormat.Bmp);
						</code>
					</pre>
				</section>

				<section>
					<h3>Вид сообщения в системе</h3>
					<img src="img/MSMQ_6.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Форматировщик сообщений</h2>
				</section>
				<section>
					<h3>Типы формартировщиков</h3>
					<ul>
						<li>XmlMessageFormatter - форматировщик по умолчанию. Сериализует объекты, используя XML</li>
						<li>BinaryMessageFormatter -собщения сериализуются в двоичный формат. Эти сообщения короче, чем сформатированные с применением
							XML
						</li>
						<li>ActiveXMessageFormatter - двоичный форматировщик, так что сообщения могут быть прочитаны и записаны объектами COM.
							Используя этот форматировщик, можно записывать сообщения в очередь с помощью классов .NET и читать их оттуда объектами
							COM
						</li>
					</ul>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
queue.Formatter = new XmlMessageFormatter(
      new String[] { "System.String" });
Message message = queue.Receive();
Console.WriteLine(message.Body);
						</code>
					</pre>
					<pre>
						<code class="hljs">
var queue = new MessageQueue(@".\private$\MyPrivateQueue");
      queue.Formatter = new BinaryMessageFormatter();

foreach (Message message in queue)
      Console.WriteLine(message.Body);
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Использование транзакций</h2>
				</section>
				<section>
					<h3>Класс MessageQueueTransaction</h3>
					<pre>
						<code class="hljs">
    public class MessageQueueTransaction : IDisposable
    {
        public MessageQueueTransaction();
        ~MessageQueueTransaction();
        public MessageQueueTransactionStatus Status { get; }
        public void Abort();

        public void Begin();

        public void Commit();
        public void Dispose();

        protected virtual void Dispose(bool disposing);
    }
						</code>
					</pre>
				</section>
				<section>
					<h3>Пример</h3>
					<pre>
						<code class="hljs">
MessageQueue queue = new MessageQueue(@".\private$\MyPrivateQueue");
Message msg = new Message("Example Message Body");
MessageQueueTransaction transaction = new MessageQueueTransaction();

try
{
    transaction.Begin();
    queue.Send(msg, "Example Message Label", transaction);
    transaction.Commit();
}
catch(System.Exception e)
{
    transaction.Abort();
    throw e;
}
finally
{
    transaction.Dispose();
}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h1>Azure Service Bus</h1>
			</section>
			<section>
				<h2>Служебная шина Azure</h2>
				<blockquote>
					Высоконадежная облачная система для обмена сообщениями между приложениями и службами, которая эффективно работает, даже если
					некоторые элементы инфраструктуры недоступны в сети
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Основное назначение</h2>
				</section>
				<section>
					<h3>Создание масштабируемых облачных решений</h3>
					<blockquote>
						Асинхронный обмен сообщениями не только обеспечивает устойчивую работу приложений, но и дает возможность надежно масштабировать
						используемое решение. Интеграция облачных ресурсов, таких как база данных SQL, служба хранилища и веб-приложения службы
						приложепний, со службой обмена сообщениями служебной шины гарантирует надежную работу в условиях любых нагрузок и позволяет
						избежать простоев в случае сбоя
					</blockquote>
				</section>
				<section>
					<h3>Внедрение сложных процессов обмена сообщениями</h3>
					<blockquote>
						Служебная шина позволяет создавать надежные топологии обмена сообщениями со сложными параметрами маршрутизации, одновременно
						повышая общую доступность решения. С ее помощью можно доставлять сообщения одновременно нескольким подписчикам, а также
						рассылать сообщения в системы, расположенные на нижних уровнях архитектуры системы
					</blockquote>
				</section>
				<section>
					<h3>Повышение безопасности между гибридными облаками</h3>
					<blockquote>
						Функция гибридных подключений в ретрансляторе служебной шины позволяет безопасно работать с имеющимися ресурсами, где бы
						они ни находились, не используя сложные VPN-конфигурации, настройки брандмауэра или параметры сети. Эта функция обеспечивает
						расширенную проверку подлинности и подключение через облако, а также позволяет просматривать и отслеживать активность
					</blockquote>
				</section>
				<section>
					<h3>Использование одного подключения несколькими приложениями</h3>
					<blockquote>
						Благодаря гибридным подключениям и ретранслятору служебной шины не нужно никуда переносить свои локальные данные, чтобы настроить
						к ним доступ из облака или любого другого расположения
					</blockquote>
				</section>
			</section>
			<section>
				<h2>Схема работы</h2>
				<img src="img/servicebus_architecture.png" alt="">
			</section>
			<section>
				<h2>Механизмы взаимодействия</h2>
				<ul>
					<li><span class="highlight-blue">Очереди</span> (однонаправленное взаимодействие) - действует как посредник (брокер), который
						хранит отправленные сообщения, пока они не будут получены. Каждое сообщение получает один получатель</li>
					<li><span class="highlight-blue">Разделы</span> (однонаправленное взаимодействие с использованием подписок) - подобно очереди,
						действует как брокер, но каждая подписка может при необходимости применить фильтр, чтобы получать только те сообщения,
						которые соответствуют определенным условиям. В одном разделе может быть несколько подписок</li>
					<li><span class="highlight-blue">Ретрансляторы</span> (двунаправленное взаимодействие) - не хранит передаваемые сообщения,
						так как не является брокером</li>
				</ul>
			</section>
			<section>
				<h2>Ключевые моменты</h2>
				<blockquote>
					При создании очереди, раздела или ретранслятора задается имя. В комбинации с именем пространства имен это имя создает уникальный
					идентификатор объекта. Приложения могут передать это имя службе Service Bus, а затем использовать соответствующую очередь,
					раздел или ретранслятор для взаимодействия с другими приложениями
				</blockquote>
				<blockquote>
					Каждое сообщение состоит из двух частей: набора свойств (пар ключ/значение) и двоичного тела сообщения
				</blockquote>
			</section>
			<section>
				<section>
					<h2>Очереди</h2>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Два способа считывания сообщения: ReceiveAndDelete (извлекает сообщение из очереди и сразу удаляет его) и PeekLock
							(извлекает сообщение из очереди, блокирует сообщение, делая его невидимым для других получателей, а затем ожидает
							определенного события)
						</li>
						<li>
							Получатели принимают и обрабатывают сообщения в том порядке, в котором они были добавлены в очередь
						</li>
						<li>Может отправлять и получать сообщения с разной скоростью (выравнивание нагрузки). Это сокращает расходы на инфраструктуру,
							необходимую для обработки нагрузки приложения</li>
						<li>
							Уменьшает зависимость между компонентами. Обновление потребителя не будут оказывать влияния на производителя
						</li>
					</ul>
				</section>
				<section>
					<h3>Схема обмена данными через очередь</h3>
					<img src="img/servicebus_queues.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Разделы</h2>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Позволяют каждому принимающему приложению создавать собственную подписку, определив фильтр. Подписчик будет видеть
							только те сообщения, которые соответствуют фильтру
						</li>
						<li>Два способа считывания сообщения: ReceiveAndDelete и PeekLock)
						</li>
						<li>Каждое опубликованное сообщение становится доступным в рамках каждой подписки, зарегистрированной в разделе. Сообщения
							отправляются в раздел и доставляются в одну или несколько связанных подписок в зависимости от правил фильтрации</li>
						<li>Нельзя непосредственно получить сообщение из раздела (только из подписок). Подписка раздела напоминает виртуальную
							очередь, которая получает копии сообщений, отправленных в раздел</li>
					</ul>
				</section>
				<section>
					<h3>Схема обмена данными через разделы</h3>
					<img src="img/servicebus_topicsandsubscriptions.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Ретрансляторы</h2>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Обходит ограничения реобразование сетевых адресов (NAT) и блокировки брандмауэром внешних портов через NAT</li>
						<li>Для двунаправленного взаимодействия через ретранслятор каждое приложение устанавливает исходящее TCP-соединение с Service
							Bus и держит его открытым</li>
						<li>Удержание соединение позволяет брандмауэру разрешать входящий трафик для каждого приложения без открытия новых портов.
							Этот подход также решает проблему NAT, так как каждое приложение имеет постоянную конечную точку в облаке на протяжении
							всего обмена данными</li>
						<li>Service Bus предоставляет привязки WCF, которые упрощают взаимодействие приложений через ретрансляторы</li>
					</ul>
				</section>
				<section>
					<h3>Схема обмена данными через ретранслятор</h3>
					<img src="img/servicebus_relay.png" alt="">
				</section>
			</section>
			<section>
				<section>
					<h2>Схемы работы Azure Service Bus Queues</h2>
				</section>
				<section>
					<h3>Пример 1</h3>
					<img src="img/servicebus_azure_combination_1.png" alt="">
				</section>
				<section>
					<h3>Пример 2</h3>
					<img src="img/servicebus_azure_combination_2.png" alt="">
				</section>
			</section>
			<section>
				<h1>Архитектура служебной шины Azure</h1>
			</section>
			<section>
				<section>
					<!--https://github.com/Microsoft/azure-docs.ru-ru/blob/master/articles/service-bus/service-bus-architecture.md -->
					<h2>Единицы масштабирования</h2>
					<blockquote>
						Содержимое служебной шины упорядочено по единицам масштабирования
					</blockquote>
					<blockquote>
						Единица масштабирования — это единица развертывания, которая содержит все компоненты, необходимые для запуска службы. Для
						каждой области развертывается одна или несколько единиц масштабирования служебной шины
					</blockquote>
				</section>
				<section>
					<h3>Структура единиц масштабирования</h3>
					<ul>
						<li>Набор узлов шлюза - проверяют подлинность входящих запросов и обрабатывают запросы на ретрансляцию. У каждого узла
							шлюза есть общедоступный IP-адрес</li>
						<li>Набор узлов брокера сообщений - обрабатывают запросы к сущностям обмена сообщениями</li>
						<li>Единое хранилище шлюза - содержит данные по каждой сущности, определенной в соответствующей единице масштабирования.
							Хранилище шлюза реализуется на основе базы данных SQL Azure</li>
						<li>Хранилища сообщений - содержат сообщения из всех очередей, разделов и подписок, определенных в соответствующей единице
							масштабирования. Здесь же хранятся все данные подписки. Если не включены секционированные сущности обмена сообщениями,
							очередь или раздел сопоставляется с одним хранилищем</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Контейнеры</h2>
					<blockquote>
						Контейнер — логическая конструкция, которая использует одно единственное хранилище сообщений для хранения всех соответствующих
						данных в этом контейнере. Каждый контейнер назначается узлу брокера сообщений
					</blockquote>
				</section>
				<section>
					<h3>Особенности контейнеров</h3>
					<ul>
						<li>Определенный контейнер назначается каждой сущности обмена сообщениями</li>
						<li>Каждый контейнер назначается узлу брокера сообщений</li>
						<li>Каждый узел брокера сообщений загружает несколько контейнеров. Контейнеры назначаются узлу брокера сообщений таким
							образом, чтобы все узлы брокера сообщений были загружены в равной мере</li>
						<li>Если шаблон нагрузки меняется (один из контейнеров загружается слишком сильно) или узел брокера сообщений становится
							временно недоступным, контейнеры перераспределяются между узлами брокера сообщений</li>
					</ul>
				</section>
				<section>
					<h3>Пространства имен</h3>
					<blockquote>
						Пространство имен — это общий контейнер для всех компонентов обмена сообщениями. В одном пространстве имен могут содержаться
						несколько очередей и разделов. Часто пространства имен выполняют роль контейнеров приложений
					</blockquote>
				</section>
			</section>
			<section>
				<section>
					<h2>Обработка входящих запросов обмена сообщениями</h2>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<ol>
						<li>Клиент отправляет запрос на служебную шину, подсистема балансировки нагрузки передает его в один из узлов шлюза</li>
						<li>Узел шлюза авторизует запрос</li>
						<li>Если запрос относится к сущности обмена сообщениями (очереди, разделу или подписке), узел шлюза выполняет поиск этой
							сущности в хранилище шлюза и определяет, в каком хранилище сообщений она находится</li>
						<li>Определяется какой узел брокера сообщений обслуживает контейнер в данный момент, и отправляет запрос на этот узел
						</li>
						<li>Узел брокера обрабатывает запрос и обновляет состояние сущности в хранилище контейнера</li>
						<li>Узел отправляет ответ обратно на узел шлюза, который пересылает соответствующий ответ клиенту, отправившему исходный
							запрос
						</li>
					</ol>
				</section>
				<section>
					<h3>Графическое представление</h3>
					<img src="img/Обработка_входящих_запросов_обмена_сообщениями.png" alt="" height="300">
				</section>
			</section>
			<section>
				<section>
					<h2>Обработка входящих запросов на ретрансляцию</h2>
				</section>
				<section>
					<h3>Алгоритм работы</h3>
					<ol>
						<li>Клиент отправляет запрос на служебную шину, подсистема балансировки нагрузки передает его в один из узлов шлюза
						</li>
						<li>Если запрос связан с прослушиванием, узел шлюза создает новую ретрансляцию</li>
						<li>Если запрос связан с подключением к определенной ретрансляции, узел шлюза переадресовывает его на узел шлюза, которому
							принадлежит ретрансляция</li>
						<li>Узел шлюза, которому принадлежит ретрансляция, отправляет запрос о подключении клиенту прослушивания, чтобы прослушиватель
							создал временный канал к узлу шлюза, получившему запрос на подключение</li>
						<li>При установки подключения ретрансляции, клиенты могут обмениваться сообщениями через узел шлюза, используемый для связи</li>
					</ol>
				</section>
				<section>
					<h3>Графическое представление</h3>
					<img src="img/Обработка_входящих_запросов_на_ретрансляцию.png" alt="" height="350">
				</section>
			</section>
			<section>
				<section>
					<h2>Аутентификация и авторизация</h2>
					<blockquote>
						Приложения могут проходить проверку подлинности в служебной шине Azure, используя либо проверку подлинности подписанного
						URL-адреса (SAS), либо службу контроля доступа Azure Active Directory (ACS)
					</blockquote>
				</section>
				<section>
					<h3>Проверка подлинности с помощью подписанного URL-адреса (SAS)</h3>
					<ul>
						<li>Позволяет предоставлять пользователю доступ к ресурсам служебной шины с определенными правами</li>
						<li>Предусматривает настройку соответствующих прав для криптографического ключа в ресурсе служебной шин</li>
						<li>Поддерживается в ретрансляторах служебной шины</li>
						<li>Для получения доступа к сущности, клиенту требуется маркер SAS, который создается с помощью правила SharedAccessAuthorizationRule
						</li>
						<li>Маркер создается с помощью хэш-функции HMAC-SHA256 строки ресурса, состоящей из URI ресурса, к которому запрашивается
							доступ, и срока действия с криптографическим ключом, связанным с правилом авторизации</li>
					</ul>
				</section>
				<section>
					<h3>Объект SharedAccessAuthorizationRule</h3>
					<ul>
						<li>KeyName — определяет правило</li>
						<li>PrimaryKey — криптографический ключ, используемый для подписи и проверки маркеров SAS</li>
						<li>SecondaryKey — криптографический ключ, используемый для подписи и проверки маркеров SAS</li>
						<li>Rights — набор прав на прослушивание, отправку или управление</li>
					</ul>
				</section>
				<section>
					<h3>Проверка подлинности ACS</h3>
					<blockquote>
						Аутентификация с помощью ACS осуществляется с помощью связанного пространства имен ACS
					</blockquote>
					<ul>
						<li>Необходимо настроить соответствующие отношения доверия</li>
						<li>Для получения доступа к сущности, клиент запрашивает маркер SWT из ACS с соответствующими утверждениями, предоставляя
							свои учетные данные. Затем маркер SWT необходимо отправить в служебную шину как часть запроса. Это позволит авторизовать
							клиента для получения доступа к сущности</li>
						<li>Проверка подлинности импользует объект SharedSecretTokenProvider</li>
						<li>Все интерфейсы API, которые принимают строку подключения в качестве параметра, поддерживают строки подключения ACS</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Пример</h2>
				</section>
				<section>
					<h3>Панель управления</h3>
					<img src="img/SB_1.png" alt="">
				</section>
				<section>
					<h3>Создание пространства имен службы</h3>
					<img src="img/SB_2.png" alt="">
				</section>
				<section>
					<h3>Тарифный план</h3>
					<img src="img/SB_3.png" alt="">
				</section>
				<section>
					<h3>Результат создания namespace</h3>
					<img src="img/SB_4.png" alt="">
				</section>
				<section>
					<h3>Создание очереди</h3>
					<img src="img/SB_5.png" alt="">
				</section>
				<section>
					<h3>Результат создания очереди</h3>
					<img src="img/SB_6.png" alt="">
				</section>
				<section>
					<h3>Получение учетных данных управления</h3>
					<img src="img/SB_7.png" alt="">
				</section>
				<section>
					<h3>Строка подключения</h3>
					<img src="img/SB_8.png" alt="">
				</section>
				<section>
					<h3>Nuget-пакет</h3>
					<img src="img/SB_9.png" alt="">
				</section>
				<section>
					<h3>Отправка сообщения</h3>
					<pre>
						<code class="hljs">
static void Main(string[] args)
{
    //CONNECTION STRING–PRIMARY KEY
    var connectionString = @"Endpoint=
            sb://makshlservicebus.servicebus.windows.net/;
            SharedAccessKeyName=RootManageSharedAccessKey;
            SharedAccessKey=Jha3oP0D5jZku5Fs2nS/nhVW9bd6W9+00SqKW5T1Upw=";
    var queueName = "queue1";

    var client = QueueClient.CreateFromConnectionString(
          connectionString, 
          queueName
    );
    var message = new BrokeredMessage("This is a test message!");

    client.Send(message);
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Статистика</h3>
					<img src="img/SB_10.png" alt="">
				</section>
				<section>
					<h3>Получение сообщения</h3>
					<pre>
						<code class="hljs">
static void Main(string[] args)
{
    //CONNECTION STRING–PRIMARY KEY
    var connectionString = @"Endpoint=
            sb://makshlservicebus.servicebus.windows.net/;
            SharedAccessKeyName=RootManageSharedAccessKey;
            SharedAccessKey=Jha3oP0D5jZku5Fs2nS/nhVW9bd6W9+00SqKW5T1Upw=";
    var queueName = "queue1";

    var client = QueueClient.CreateFromConnectionString(
          connectionString, 
          queueName
    );

    client.OnMessage(message =&gt;
    {
        Console.WriteLine($"Message body: {message.GetBody&lt;String&gt;()}");
        Console.WriteLine($"Message id: {message.MessageId}");
    });
}
						</code>
					</pre>
				</section>
				<section>
					<h3>Полученные сообщения</h3>
					<img src="img/SB_11.png" alt="">
				</section>
				<section>
					<h3>Статистика</h3>
					<img src="img/SB_12.png" alt="">
				</section>
			</section>

			<!-- Далее про application insights-->
			<!-- Содержимое лекции -->

			<section>
				<h1>Балансировка нагрузки</h1>
			</section>
			<section>
				<h2>Определение</h2>
				<blockquote>
					Балансировщик нагрузки Azure обеспечивает высокую доступность и производительность сети для приложений. Это балансировщик
					нагрузки уровня 4 (Layer-4) распределяет нагрузку между всеми доступными виртуальными машинами путем вычисления хеш
					функции от трафика, поступившего на данную конечную точку. Эта хеш функция вычисляется таким образом, что все пакеты,
					поступившие в рамках одного соединения (TCP или UDP) направляются на один и тот же сервер
				</blockquote>
			</section>
			<section>
				<h2>Типы балансировки</h2>
				<ul>
					<li>Балансировкой нагрузки для Интернета - балансировка нагрузки входящего интернет-трафика виртуальных машин (балансировкой
						нагрузки для Интернета)</li>
					<li>Внутренняя балансировка нагрузки - балансировка нагрузки трафика между виртуальными машинами в виртуальной сети, между
						виртуальными машинами в облачных службах или между локальными компьютерами и виртуальными машинами в распределенной
						виртуальной сети</li>
					<li>Перенаправление внешнего трафика к определенному экземпляру виртуальной машины</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Особенности</h2>
					<ul>
						<li>Распространение на основе хэша - по умолчанию для сопоставления трафика с доступными серверами используется хэш с пятью
							кортежами (исходный IP-адрес, порт источника, IP-адрес назначения, порт назначения и тип протокола). Пакеты в одном
							сеансе TCP или UDP будут направляться на один экземпляр в конечной точке с балансировкой нагрузки
						</li>
						<li>Перенаправление портов - позволяет контролировать процесс управления входящей связью. Включает в себя трафик с узлов
							Интернета, ВМ в других облачных службах или из виртуальных сетей</li>
						<li>Автоматическая перенастройка - мгновенно перенастраивает сам себя при горизонтальном и вертикальном масштабировании
							экземпляров (например, при увеличении количества экземпляров для веб-роли в облачной службе)
						</li>
					</ul>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Мониторинг служб - может проверять работоспособность различных экземпляров сервера. Если проверка не отвечает, балансировщик
							нагрузки Azure прекращает отправлять новое подключение неработоспособным экземплярам</li>
						<li>Исходящее преобразование сетевых адресов (SNAT) - весь исходящий трафик из вашей службы в Интернет подвергается исходному
							преобразованию сетевых адресов (SNAT), при этом используется тот же виртуальный IP-адрес, что и для входящего трафика</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Модели развертывания Azure</h2>
				</section>
				<section>
					<h3>Классическая модель</h3>
					<img src="img/классическая_модель_развертывания.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Облачной службе назначаются общедоступный IP-адрес и полное доменное имя.
						</li>
						<li>Подсистема балансировки нагрузки преобразует порты и балансирует нагрузку сетевого трафика, используя общедоступный
							IP-адрес для облачной службы
						</li>
						<li>Трафик с балансировкой нагрузки определяется конечными точками</li>
						<li>Конечные точки преобразования портов связывают (связь "один к одному") общедоступный порт общедоступного IP-адреса
							и локальный порт, назначенный службе на определенной виртуальной машине</li>
						<li>Конечные точки балансировки связывают (связь "один ко многим") общедоступный IP-адрес и локальные порты, назначенные
							службам на виртуальных машинах в облачной службе</li>
					</ul>
				</section>
				<section>
					<h3>Модель развертывания диспетчера ресурсов</h3>
					<img src="img/Модель_развертывания_диспетчера_ресурсов.png" alt="">
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Нет необходимости создавать облачную службу. Можно явно создать подсистему балансировки нагрузки для маршрутизации
							трафика между несколькими ВМ</li>
						<li>Общедоступный IP-адрес является отдельным ресурсом с меткой домена и связывается с ресурсом подсистемы БН. Правила
							БН и правила для входящих подключений NAT используют общедоступный IP-адрес в качестве конечной точки Интернета для
							ресурсов, получающих сетевой трафик с балансировкой нагрузки
						</li>
						<li>Частный или общедоступный IP-адрес назначается ресурсу сетевого интерфейса, подключаемому к ВМ. После добавления сетевого
							интерфейса в пул внутренних IP-адресов БН начинает отправлять сетевой трафик с балансировкой нагрузки на основе созданных
							правил
						</li>
					</ul>
				</section>
			</section>
			<section>
				<h2>Управление БН</h2>
				<ul>
					<li>API</li>
					<li>Шаблоны на основе Resource Manager</li>
					<li>PowerShell</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>Режим распределения нагрузки</h2>
				</section>
				<section>
					<h3>На основе сходства исходного IP</h3>
					<blockquote>
						Можно настроить использование 2 кортежей (исходный IP-адрес, IP-адрес назначения) или 3 кортежей (исходный IP-адрес, IP-адрес
						назначения, протокол) для сопоставления трафика с доступными серверами. При использовании соответствия исходному IP-адресу
						подключения, инициированные с одного клиентского компьютера, направляются к одной конечной точке DIP
					</blockquote>
					<blockquote>
						Режим позволяет устранить несовместимость подсистемы БН и шлюза удаленных рабочих столов. Можно создать ферму шлюза удаленных
						рабочих столов в одной облачной службе. Другой сценарий использования — передача мультимедиа, при которой фактическая
						передача данных осуществляется по протоколу UDP, а управление — по протоколу TCP
					</blockquote>
				</section>
				<section>
					<h3>Схема работы</h3>
					<img src="img/load-balancer-session-affinity.png" alt="" height="550">
				</section>
				<section>
					<h3>Схема работы</h3>
					<ul>
						<li>Клиент инициирует сеанс TCP для общедоступного IP-адреса с балансировкой нагрузки</li>
						<li>Запрос отправляется по конкретному DIP, сам канал остается активным, чтобы контролировать состояние подключения</li>
						<li>С того же клиентского ПК для той же общедоступной конечной точки с балансировкой нагрузки инициируется новый сеанс
							UDP
						</li>
						<li>Подключение будет направлено на ту же конечную точку DIP, что и предыдущее TCP-подключение</li>
					</ul>
					<blockquote>
						Таким образом можно передавать мультимедиа с более высокой пропускной способностью, поддерживая при этом канал управления
						по TCP
					</blockquote>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>При изменении набора балансировки нагрузки (при добавлении или удалении виртуальной машины) распределение запросов
							клиента вычисляется заново</li>
						<li>Нельзя надеяться на то, что новые подключения из существующих клиентских сеансов будут направлены на один сервер</li>
						<li>Кроме того, использование режима распределения соответствия исходному IP-адресу может привести к неравномерному распределению
							трафика
						</li>
						<li> Клиенты, работающие на прокси-серверах, могут рассматриваться как одно уникальное клиентское приложение</li>
					</ul>
				</section>
				<section>
					<h3>На основе сходства хэша</h3>
					<blockquote>
						В основе алгоритма распределения лежит использование хэша 5 кортежей (исходный IP-адрес, порт источника, IP-адрес назначения,
						порт назначения, тип протокола) для сопоставления трафика с доступными серверами. Он позволяет закреплять IP-адреса
						только в рамках сеанса транспорта
					</blockquote>
					<blockquote>
						Пакеты в одном сеансе TCP или UDP будут направляться на один экземпляр IP-адреса центра обработки данных (DIP) в конечной
						точке с балансировкой нагрузки. Когда клиент закрывает и снова открывает подключение или начинает новый сеанс с того
						же исходного IP-адреса, порт источника изменяется и перенаправляет трафик к другой конечной точке DIP
					</blockquote>
				</section>
				<section>
					<h3>Схема</h3>
					<img src="img/load-balancer-distribution.png" alt="" height="550">
				</section>
			</section>
			<section>
				<section>
					<h2>Примеры использования</h2>
				</section>
				<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
					<h3>Балансировка виртуальных сетей</h3>
					<img src="img/lb_ip.png" alt="">
				</section>
				<section>
					<h3>Многоуровневое приложение для Интернета</h3>
					<img src="img/многоуровневое_приложение.png" alt="" height="550">
				</section>
				<section>
					<h3>
						Серверы переднего плана в другой службе
					</h3>
					<img src="img/сервер_переднего_плана_в_другой_службе.png" alt="" height="550">
					<!-- Другой возможный сценарий для многоуровневого приложения: внутренняя подсистема балансировки нагрузки развертывается в облачной службе, отличной от той, которая использует службу для внутренней подсистемы балансировки нагрузки.
                     Облачные службы, использующие одну и ту же виртуальную сеть, будут иметь доступ к конечной точке внутренней подсистемы балансировки нагрузки. На следующем изображении показано, что веб-серверы переднего плана размещены в облачной службе, отличной от той, в которой размещен сервер базы данных. Кроме того, они используют конечную точку внутреннего балансировщика нагрузки в пределах одной и той же виртуальной сети. -->
				</section>
				<section>
					<h3>Бизнес-приложения в интрасети</h3>
					<img src="img/приложение_в_интрасети.png" alt="" height="550">
					<!-- Трафик от клиентов в локальной сети распределяется по набору серверов бизнес-приложений с помощью VPN-подключения к сети Azure.
                    Клиентский компьютер получит доступ к IP-адресу из службы VPN Azure, используя VPN подключение типа "точка — сеть". Это позволит использовать бизнес-приложение, размещенное за конечной точкой внутренней подсистемы балансировки нагрузки.-->
				</section>
			</section>
			<section>
				<h3>Создание собственного БН</h3>
				<ol>
					<li>Конфигурация интерфейсных IP-адресов: содержит общедоступные IP-адреса для входящего сетевого трафика</li>
					<li>Пул внутренних адресов: содержит сетевые интерфейсы (сетевые карты), которые позволяют виртуальным машинам получать
						трафик от балансировщика нагрузки</li>
					<li>Правила балансировки нагрузки: содержат правила сопоставления общего порта в балансировщике нагрузки с портом в пуле
						внутренних адресов</li>
					<li>Правила NAT для входящего трафика: содержат правила сопоставления общего порта в балансировщике нагрузки с портом на
						конкретной виртуальной машине в пуле внутренних адресов</li>
					<li>Пробы: содержат пробы работоспособности, которые используются для проверки доступности экземпляров виртуальных машин
						в пуле внутренних адресов</li>
				</ol>
			</section>
			<section>
				<section>
					<h2>Проблема ожидания простоя TCP-соеденений</h2>
					<blockquote>
						По умолчанию значение параметра времени ожидания простоя для балансировщика нагрузки Azure равно 4 минутам. Если период бездействия
						превышает значение времени ожидания, нет никакой гарантии, что сеанс TCP или HTTP между клиентом и облачной службой
						возобновится
					</blockquote>
				</section>
				<section>
					<h3>Как с этим бороться?</h3>
					<ol>
						<li>Постоянная проверка активности TCP. Когда проверка активности включена, пакеты отправляются в периоды простоя подключений.
							Благодаря пакетам проверки активности значение времени ожидания простоя не достигается и подключение сохраняется в
							течение длительного времени</li>
						<li>Необходимо настроить проверку активности TCP с интервалом, который должен быть меньше, чем время ожидания простоя</li>
						<li>Можно увеличить значение времени ожидания простоя</li>
						<li>Не подходят для сценариев, обусловленных коротким временем работы аккумулятора. Не рекомендуется для мобильных приложений
							и служб</li>
					</ol>
				</section>
				<section>
					<h3>Схема работы</h3>
					<img src="img/время_ожидания_простоя.png" alt="">
				</section>
			</section>

			<section>
				<h2 class="header-hide">Спасибо за внимание</h2>
				<img src="img/thanks.png" alt="" height="600">
			</section>
		</div>
	</div>
	<aside id="presentable-icon" class="revealjs">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>